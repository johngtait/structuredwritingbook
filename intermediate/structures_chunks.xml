<?xml version="1.0" encoding="UTF-8"?>
<chapter name="chapter.blocks">
<title>Blocks, fragments, paragraphs, and phrases</title>
<annotations>
<p>Concepts</p>
<p><phrase><annotation type="concept">subject domain</annotation></phrase> <phrase><annotation type="concept">media domain</annotation></phrase> <phrase><annotation type="concept">document domain</annotation></phrase> <phrase><annotation type="concept">management domain</annotation></phrase> <phrase><annotation type="concept">subject-domain</annotation></phrase> <phrase><annotation type="concept">media-domain</annotation></phrase> <phrase><annotation type="concept">document-domain</annotation></phrase> <phrase><annotation type="concept">management-domain</annotation></phrase> <phrase><annotation type="concept">hybrid tagging language</annotation></phrase> <phrase><annotation type="concept">Every Page is Page One</annotation></phrase> <phrase><annotation type="concept">abstract language</annotation></phrase> <phrase><annotation type="concept">information architecture</annotation></phrase> <phrase><annotation type="concept" specifically="top-down information architecture">top-down</annotation></phrase> <phrase><annotation type="concept">metadata</annotation></phrase></p>
<p>Languages</p>
<p><phrase><annotation type="language">SAM</annotation></phrase> <phrase><annotation type="language">DITA</annotation></phrase> <phrase><annotation type="language">DocBook</annotation></phrase> <phrase><annotation type="language">Markdown</annotation></phrase> <phrase><annotation type="language">HTML</annotation></phrase> <phrase><annotation type="language">XML</annotation></phrase></p>
<p>Algorithms</p>
<p><phrase><annotation type="algorithm">authoring algorithm</annotation></phrase> <phrase><annotation type="algorithm">authoring</annotation></phrase> <phrase><annotation type="algorithm" specifically="composition">composability</annotation></phrase> <phrase><annotation type="algorithm">composition algorithm</annotation></phrase> <phrase><annotation type="algorithm">composition</annotation></phrase> <phrase><annotation type="algorithm">conformance algorithm</annotation></phrase> <phrase><annotation type="algorithm">conformance</annotation></phrase> <phrase><annotation type="algorithm">content management algorithm</annotation></phrase> <phrase><annotation type="algorithm">content management</annotation></phrase> <phrase><annotation type="algorithm">content reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm">content reuse</annotation></phrase> <phrase><annotation type="algorithm">differential single sourcing algorithm</annotation></phrase> <phrase><annotation type="algorithm">differential single sourcing</annotation></phrase> <phrase><annotation type="algorithm">encoding algorithm</annotation></phrase> <phrase><annotation type="algorithm">encoding</annotation></phrase> <phrase><annotation type="algorithm">exchange algorithm</annotation></phrase> <phrase><annotation type="algorithm">exchange</annotation></phrase> <phrase><annotation type="algorithm">extract and merge algorithm</annotation></phrase> <phrase><annotation type="algorithm">extract and merge</annotation></phrase> <phrase><annotation type="algorithm">formatting algorithm</annotation></phrase> <phrase><annotation type="algorithm">formatting</annotation></phrase> <phrase><annotation type="algorithm">linking algorithm</annotation></phrase> <phrase><annotation type="algorithm">linking</annotation></phrase> <phrase><annotation type="algorithm">presentation algorithm</annotation></phrase> <phrase><annotation type="algorithm">presentation</annotation></phrase> <phrase><annotation type="algorithm">publishing algorithm</annotation></phrase> <phrase><annotation type="algorithm">publishing</annotation></phrase> <phrase><annotation type="algorithm">quality algorithm</annotation></phrase> <phrase><annotation type="algorithm">quality</annotation></phrase> <phrase><annotation type="algorithm">relevance algorithm</annotation></phrase> <phrase><annotation type="algorithm">relevance</annotation></phrase> <phrase><annotation type="algorithm">rendering algorithm</annotation></phrase> <phrase><annotation type="algorithm">rendering</annotation></phrase> <phrase><annotation type="algorithm">reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm">reuse</annotation></phrase> <phrase><annotation type="algorithm">separating content from formatting</annotation></phrase> <phrase><annotation type="algorithm">single source of truth algorithm</annotation></phrase> <phrase><annotation type="algorithm">single source of truth</annotation></phrase> <phrase><annotation type="algorithm">single sourcing algorithm</annotation></phrase> <phrase><annotation type="algorithm">single sourcing</annotation></phrase> <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> <phrase><annotation type="algorithm">synthesis</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance">validation</annotation></phrase></p>
<p>Tools</p>
<p><phrase><annotation type="tool">content management system</annotation></phrase> <phrase><annotation type="tool">Content management systems</annotation></phrase></p>
<p>Roles</p>
<p><phrase><annotation type="role">information architect</annotation></phrase></p>
</annotations>
<p>We said that the structure of a structured writing document is made up of nested blocks. The question is, what types of blocks are they and how do they relate to each other.</p>
<section>
<title>Semantic blocks</title>
<p>If we asked a writer to describe the things that make up a document, they would probably name things like paragraphs, tables, and lists. If we asked about a particular type of document, such as a recipe, they would probably say things like introduction, ingredients, and preparation procedure. A structured writing language will typically be much more fine grained than this. A table, for instance, may be made up of dozens of smaller structures. But these are the units that have meaning to writers independent of how they are constructed internally.</p>
<p>At the risk of adding further burden to an already overloaded term, I am going to call these recognizable objects <phrase><annotation type="concept">semantic blocks</annotation></phrase> because they are blocks that mean something in whichever domain they belong to. Higher level markup design is essentially a matter of defining semantic blocks and the ways they go together.</p>
<p>An easy example of a semantic block is a list. (Note that I am not using “semantic” to mean subject domain; blocks have semantics in all domains.) A list is a semantic block because “list” is an idea with meaning in the document domain independent of its exact internal structure. A writer can say to themselves, “I want a list here”, independent of any specifics of markup. If a structure has a name like this in the real world, the block that implements it (in the terminology I am coining for the purpose) is a semantic block.</p>
<p>Semantic blocks generally contain other blocks that we might not talk about independently if we did not need to describe the detailed construction of a semantic block. We can call these “structural blocks”. This is not to say that the building blocks of a semantic block may not also be semantic blocks. In fact, this happens frequently. Nor is it to say that the the distinction between semantic and mere structural blocks is fixed or inflexible. A semantic block is a block that implements a structure that has meaning to you independent of its function as markup, and what you regard as meaningful, I may regard as an implementation detail.</p>
<p>The point is not that we must agree on exactly what is a semantic block and what is not, but that you should think of markup design in terms of semantic blocks. Blocks, with whatever internal structure you require, that will capture the structure of something that is real and meaningful to you. Don’t get bogged down in the precise structure of semantic blocks until you figure out which semantic blocks you need.</p>
<p>Different markup languages often construct the same semantic block differently. <phrase><annotation type="language">DITA</annotation></phrase>, <phrase><annotation type="language">DocBook</annotation></phrase>, and <phrase><annotation type="language">HTML</annotation></phrase> all define lists, and each of them defines the internals of a list differently. Nonetheless we recognize that each of them is an implementation of the idea of a list.</p>
<p>A list is made up of structural blocks that build the shape of a list. I’ll illustrate this with XML since it makes the blocks explicit:</p>
<codeblock language="xml">
&lt;ol&gt;
    &lt;li&gt;
        &lt;p&gt;This is the first item.&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;p&gt;This is the second item.&lt;/p&gt;
    &lt;/li&gt;
&lt;/ol&gt;
</codeblock>
<p>Here the semantic block is the ordered list bounded by the <phrase><annotation type="code">ol</annotation></phrase> tags. The <phrase><annotation type="code">li</annotation></phrase> and <phrase><annotation type="code">p</annotation></phrase> tags inside are structural blocks that together implement the structure of an ordered list.</p>
<p>Other <phrase><annotation type="concept">document domain</annotation></phrase> examples of semantic blocks include <phrase><annotation type="structure">tables</annotation></phrase> and <phrase><annotation type="structure">procedures</annotation></phrase>. (Again you will find that DocBook, DITA, and HTML, not to mention S1000D, and <phrase>reStructuredtext</phrase>, all have tables, all with different internal structures, and that both DocBook and DITA have procedures, again internally different. It is possible to disagree greatly about how to structure a semantic block while still recognizing different implementations as examples of the same semantic block.</p>
<p>In the subject domain, examples of semantic blocks would include the ingredients list from the recipe example we have been using:</p>
<codeblock language="sam">
ingredients:: ingredient, quantity, unit
    eggs, 3, each
    salt, 1, tsp
    butter, .5, cup
</codeblock>
<p>and the parameter description from an API reference:</p>
<codeblock language="sam">
parameter: string
    required: yes
    description:
        The string to print.
</codeblock>
<p>One characteristic of semantic blocks is that they often tend to repeat as a unit, as this example does in an API reference entry:</p>
<codeblock language="sam">
function: print
    return-value: none
    parameters:
        parameter: string
            required: yes
            description:
                The string to print.
        parameter: end
            required: no
            default: '\n'
            description:
                The characters to output after the {string}(parameter).
</codeblock>
<p>They may also be used as a unit in different places in a markup language, or in different markup languages. For instance, the ordered list semantic unit may be allowed in more than one place in a document domain language, such as in a section or in a table cell.</p>
<!--  Examples? -->
<p>Designing in terms of semantic blocks not only helps keep markup design and processing simpler, it also improves <phrase>functional lucidity</phrase>. Present the markup language to the writer as a set of familiar objects like lists or tables, or logical structures like ingredient list or parameter description, rather than a sea of tags, and the task becomes easier to understand (and the tags easier to remember).</p>
<p>An XML editor that implements a WYSIWYG interface to XML authoring may provide tool bar buttons for inserting semantic blocks such as list or tables as whole structures.</p>
<p>The structure of a semantic block can be strict or loose. A strict semantic block has one basic structure with few options. A loose one allows a much wider variety of structure inside, sometimes to the point that it acts more as a semantic wrapper than a defined semantic block.</p>
<p><phrase><annotation type="language">DocBook</annotation></phrase> is an example of a language with very loose semantic blocks. DocBook has the same high-level semantic blocks as any other generalized document domain tagging language, but so many tags are allowed in so many places that none of these objects are simple and easy to understand. This supports DocBook’s goal of being able to describe almost any document structure you might want to create, but at the expense of simplicity and constraint.</p>
<p>How do you balance flexibility with functional lucidity and constraint in creating semantic blocks? Sometimes it is best to have more than one implementation of a particular semantic block. For instance, both DITA and DocBook have two tables model, as simple model and a more complex one based on the CALS table model.</p>
</section>
<section>
<title>Rhetorical blocks</title>
<p>We have looked at examples of <phrase><annotation type="concept">semantic blocks</annotation></phrase> whose semantics are in the <phrase><annotation type="concept">document domain</annotation></phrase> (lists and tables) and in the <phrase><annotation type="concept">subject domain</annotation></phrase> (ingredients list and parameter description). There is another way in which some structured writing systems divide content into blocks, which is according to the rhetorical function they perform for the reader. I’m going to call these <phrase>rhetorical blocks</phrase>. (To be clear, a rhetorical block is a type of semantic block.)</p>
<p>There are as many ways of defining rhetorical blocks as there are theories of rhetoric. The think-plan-do rhetorical model that I described in <citation type="nameref" value="chapter.rhetorical_structure"/> is an example of a document types made up of three rhetorical blocks. <phrase><annotation type="tool">Information Mapping</annotation></phrase> is a structured writing system which views all content as being made up of just six types of information block: Procedure, Process, Principle, Concept, Structure, and Fact. These are functional blocks. They don’t directly describe a physical or logical element of document structure (except for procedure), nor are they specific to any one subject. They describe the kind of idea that the content conveys -- they are actually based on a theory about how humans receive information.</p>
<p>Which structured writing domain do rhetorical blocks belong to? Clearly they are not <phrase>media</phrase>, <phrase>subject</phrase>, or <phrase><annotation type="concept">management domain</annotation></phrase> structures. Are they a kind of <phrase><annotation type="concept">document domain</annotation></phrase> structure or something else again? I believe it is more useful to regard them as document domain structures than to invent another domain. Information mapping is a theory about the construction of documents to make them more effective. It regards a document as a mapping of information blocks, so IM’s information blocks are components of documents, and therefore in the document domain.</p>
<p><phrase><annotation type="language">DITA</annotation></phrase> also adopted this idea of documents being made up of rhetorical blocks. In DITA’s case, these blocks are named topics, which leads to some confusion since the word topic can be used to refer to both functional block, and also to a complete document (as in a “help topic” for instance).</p>
<p>DITA has popularized the idea that all content (or all technical content, at least) is made up of just three rhetorical blocks: concept, task, and reference.<citation type="idref" value="1"/> (DITA actually defines more topic types than this today.) This idea is appealing because it is easy to see a correspondence between these three types and the reader activities of learning (concept), doing (task), and looking stuff up (reference).</p>
<footnote id="1">
<p>There is evidence that DITA is moving away from this vision of information typing. In DITA 1.3, the technical committee puts the emphasis on topic and map as the core types, rather than concept, task and reference.</p>
<blockquote>
<citation type="citation" value="http://docs.oasis-open.org/dita/dita-1.3-why-three-editions/v1.0/cn01/dita-1.3-why-three-editions-v1.0-cn01.html#focus-of-dita"/><p>The DITA Technical Committee wants to emphasize that topic and map are the base document types in the architecture.</p>
<p>Because DITA was originally developed within IBM as a solution for technical documentation, early information about DITA stressed the importance of the concept, task, and reference topics.</p>
<p>Many regarded the topic document type as nothing more than a specialization base for concept, task, and reference.</p>
<p>While this perspective might still be valid for technical content, times have changed. DITA now is used in many other contexts, and people developing content for these other contexts need new specializations. For example, nurses who develop evidence-based care sheets might need a topic specialization that has sections for evidence, impact on current practices, and bibliographic references.</p>
</blockquote>
<p>The fact that the example of evidence-based care sheets clearly would include information from more than one of the abstract types, and that it is proposed as a specialization of topic rather than of concept, task, or reference, suggests a significant shift in thinking on this point, and that may indicate a shift away from abstract information typing towards a more concrete subject-domain approach.</p>
</footnote>
<p>This simple triptych is very appealing because it promises (though it does not necessarily deliver) easy <phrase><annotation type="algorithm" specifically="composition">composability</annotation></phrase> for <phrase><annotation type="algorithm">content reuse</annotation></phrase>. Some people also maintain that it makes content easier to access for readers, though other (myself included) criticizes it on the ground that it tends to break content down too finely for be useful and robs content of its narrative thread.</p>
<p>It can fairly be said that this depends very much on how you use it. But from a structured writing point of view, the purpose of structured writing is to use constraints to partition and direct content complexity with the goal or improving content quality and this approach, by itself, lacks some of those necessary constraints. As we have noted, some approaches to content reuse reject significant constraints in favor of easy composability. DITA does, however, provide mechanisms for creating more constrained functional blocks, though not a means to constrain how blocks are combined.</p>
<p>All of this is quite distinct from the subject-based information typing of the subject domain. The instructions in a recipe and a knitting pattern are both tasks in DITA terms and procedures in IM’s terms. But in the subject domain they are distinct types because there is a distinct way in you which write knitting instructions.</p>
<!-- EXAMPLE -->
<p><phrase><annotation type="language">DITA</annotation></phrase> and <phrase><annotation type="tool">Information Mapping</annotation></phrase>’s approaches are broad and analytical, trying to find commonalities across many different kinds of information. The subject domain is very much specific and synthetic, concerned which how specific pieces go together to successfully describe a particular subject. All three approaches break content up into blocks, and the subject-specific blocks of the subject domain can probably be categorized according to the information typology of either <phrase><annotation type="language">DITA</annotation></phrase> or <phrase><annotation type="tool">Information Mapping</annotation></phrase>. However, the specific structured writing structures that you would create in each case are different. Both the Information Mapping and DITA approaches, when reduced to specific markup structures, create abstract document domain structures. The subject domain, of course, creates subject domain structures.</p>
</section>
<section>
<title>Narrative blocks</title>
<p>What is the next unit up from the semantic block? It is the unit that combines semantic blocks to form a complete coherent content item. We might perhaps call it the narrative block.</p>
<p>The narrative block obviously comes in different sizes.  It could be a help topic, a web page, a chapter, an article in an encyclopedia, or a recipe in a cook book.</p>
<p>It is probably fair to say that the narrative block is the largest unit of content to which we can usefully assign significant constraints. Or rather, the constraints that we impose on larger collections of content are of a different type and implemented in different ways from the constraints we impose on writing and through structured writing techniques. (As we have noted, <phrase><annotation type="language">DocBook</annotation></phrase> a format primarily designed for whole books, is largely unconstrained, opting almost always to give the author multiple choices as opposed to strict guidance.)</p>
<p>The narrative block differs also between the paper world and the hypertext world of the Web. On paper a book consists of a basically linear series of chapters. On the Web, a site consists of a linked set of pages. But on the Web, pages are not restricted to linking to other pages on the same site, and search engines, which generate dynamic ad hoc links to pages rather than sites so that it is fair to say that the Web consists directly of linked pages, meaning that a narrative unit of hypertext relates itself to other content in a very different way from a narrative unit on paper.</p>
<p>Increasingly, though by no means universally, the term  is used for the narrative block in structured writing terms “topic”. There is some confusion caused by DITA’s use of the word topic for its functional blocks, and some confusion in the DITA world too about whether Concept, Task, and Reference units should be presented as narrative blocks or not.</p>
<p>While both DITA and Information Mapping define documents as made up of rhetorical blocks, neither of them offer any constraint on how rhetorical blocks (or any other type of semantic blocks) go together to create narrative blocks. These systems do nothing, therefore, to handle or to partition and redirect any complexity related to the design and construction of narrative blocks.</p>
</section>
<section>
<title>Fragments</title>
<p>Another division of content that can occur, mostly in relationship to the management domain, is the fragment. By fragment I mean a chunk of text that is not either a semantic block, a rhetorical block, or a narrative block, but is a block that you want to manage independently of the surrounding text.</p>
<p>For example, in a <phrase><annotation type="algorithm">content reuse</annotation></phrase> scenario, you might want to make a items in a list conditional based on which of the list items applies to different versions of a product.</p>
<p>Individual list items are not really semantic blocks. They are just structural blocks of a list. When you make list items conditional, what you are actually doing is creating multiple separate lists with some items in common, and recording them as a single list. You might be able to attach reasonably informative metadata to any one of those lists as a whole, but there is not a lot you can say about list items individually. They are fragments of a list. When you apply conditions to them, then, you are applying those conditions to fragments.</p>
<p>In some <phrase><annotation type="algorithm">reuse</annotation></phrase> systems, including DITA and DocBook, it is possible to apply conditions to arbitrary bits of text -- three words in sentence for instance. The block that sets off those three words in a fragment.</p>
<p>Some reuse systems also allow you to reuse arbitrary bits of text from other parts of the content set, simply because the text is the same in each case. Those bits of text would be fragments.</p>
<p>In some cases, you turn an existing structural block into a fragment by attaching <phrase><annotation type="concept">management domain</annotation></phrase> metadata to it. In other cases, you have to introduce additional markup into the document to delineate the fragment.</p>
<p>Fragments definitely solve some problems. They are also inherently unstructured and unconstrained. It is very easy to get into trouble with fragments. It is easy to create relationships and dependencies that are hard to manage because they don’t follow any structural logic. You should approach their use with great caution and restraint.</p>
</section>
<section>
<title>Paragraphs and phrases</title>
<p>Paragraphs are the thing that make structured writing the most different from other computable data sets. This is not really because of the paragraph structure per se, but because of the phrases within the paragraphs that we want to annotate. It is rare in any other data set to see a structure floating within the value of another structure. But that is exactly what happens when we annotate phrases in a paragraph.</p>
<codeblock language="sam">
In {Rio Bravo}(movie), {the Duke}(actor "John Wayne") 
plays an ex-Union colonel.
</codeblock>
<p>In this examples, the annotation on the phrases “Rio Bravo” and “the Duke” float in the middle of the paragraph block. Here is the same thing in XML:</p>
<codeblock language="xml">
&lt;p&gt;In &lt;movie&gt;Rio Bravo&lt;/movie&gt;, 
&lt;actor name="John Wayne"&gt;the Duke&lt;/actor&gt; 
plays an ex-Union colonel.&lt;/p&gt;
</codeblock>
<p>Here the <phrase><annotation type="code">movie</annotation></phrase> and <phrase><annotation type="code">actor</annotation></phrase> elements float in the content of the <phrase><annotation type="code">p</annotation></phrase> element. In XML parlance, this is called mixed content. If fact, XML breaks the structure of elements down into three kinds:</p>
<ll>
<li>
<label>element content</label>
<p>Elements that contain only other elements.</p>
</li>
<li>
<label>data content</label>
<p>Elements that contain only text data.</p>
</li>
<li>
<label>Mixed content</label>
<p>Elements that contain both text data and elements.</p>
</li>
</ll>
<p>Mixed content is the reason that most traditional data format are not a good fit for content. They may be able to model element content and data content, but they lack an elegant way to model mixed content.</p>
<p>Even conventional programming languages have trouble with mixed content. In fact most libraries for XML processing invent an additional wrapper around each string of characters in a mixed content element, effectively representing it as if it were written like this (without mixed content):</p>
<codeblock language="xml">
&lt;p&gt;&lt;text&gt;In &lt;/text&gt;&lt;movie&gt;Rio Bravo&lt;/movie&gt;&lt;text&gt;, 
&lt;/text&gt;&lt;actor name="John Wayne"&gt;the Duke&lt;/actor&gt;&lt;text&gt; 
plays an ex-Union colonel.&lt;/text&gt;&lt;/p&gt;
</codeblock>
<p>But while this makes the content palatable to conventional languages, it is clearly false to the actual structure of the document. Structured writing is essentially about reflecting the structure of thought or presentation in a narrative, and narratives have a structure that is not shared with other data. Indeed, we might say that all other data formats exist as an attempt to extract information from the narrative format to make it easier to process.</p>
<p>Thus we are taught in school that if we are presented a problem in this format:</p>
<blockquote>
<p>John had 4 apples and Mary had 5 apples. They place their apples in a basket. Bill eats 2 apples. How many apples are left in the basket?</p>
</blockquote>
<p>You solve it by first extracting the data from the narrative:</p>
<codeblock>
4 + 5 - 2 =
</codeblock>
<p>But in content processing, we cannot extract the data from the narrative because narrative is the output we are creating. Thus we have to call out the data (to make it processable by structured writing algorithms) while leaving the narrative intact.</p>
<p>When you move content to the subject domain, you will, in some cases, break down paragraphs and isolate the data. This may be done with the intention of recreating paragraphs algorithmically on output, or of switching from a narrative to a data-oriented reporting of the subject matter. Either way, it makes the data easier for algorithms to handle, and thus makes most of the structured writing algorithms work better. (You may have noticed that the subject domain provides the most constrained and elegant solution to many structured writing algorithms.)</p>
<p>Even so, it is rarely possible to do a complete breakdown of all paragraphs in refactoring content to the subject domain. Most subject domain markup languages make considerable use of paragraphs and other basic text structures, and annotate phrases within the paragraphs were necessary. Only narrative is capable of expressing the full variety and subtlety of the real world relationships between things, and only narrative is capable of conveying these things effectively to most human readers. (We noted in <citation type="nameref" value="chapter.metadata"/> that data is created by metadata and that metadata can only every finally be defined by narrative.) Even things that can be fully described to algorithms with fielded data must be described to most audiences with narrative, and even though companies like <phrase>Narrative Science</phrase> are working on how to turn data into narrative, they are far from producing a general solution -- and it is hard to see how you would get one if all data is created by metadata and all metadata is defined, ultimately, by narrative.</p>
<p><phrase>Subject-domain</phrase> structured writing extends the reach of more conventional algorithms into the world of narrative to enable specific structured writing algorithms and to provide constraints to improve the quality of the writing. Unlike <phrase><annotation type="concept">ontologies</annotation></phrase>, subject domain structured writing does not attempt to capture the whole semantics of a narrative, just to discipline and structure narrative to achieve specific content creation objectives.</p>
<p>Every domain needs to annotate phrases. <phrase>Media domain</phrase> structured writing needs to annotate phrases to describe formatting. The <phrase><annotation type="concept">document domain</annotation></phrase> needs to annotate phrases to describe their role in the document. The <phrase><annotation type="concept">management domain</annotation></phrase> needs to annotate phrases to assign conditions or extract content for reuse. The <phrase><annotation type="concept">subject domain</annotation></phrase> needs to annotate phrases to describe the subject the phrase refers to.</p>
<p>In planning your markup structures, therefore, it is important to think about which structures in your language need to be mixed content and which do not. Finding ways to avoid mixed content without violating the spirit of the essentially narrative nature of writing can pay dividends in an improved ability to express constraints and to execute virtually all the structured writing algorithms.</p>
<p>On the other hand, some of the most important subject matter that you need to model and make available to algorithms cannot effectively be factored out of paragraphs, particularly while maintaining <phrase>functional lucidity</phrase>. Be prepared, therefore, to think seriously about the types of phrases that you will need to annotate below the paragraph level and exactly which domain those annotations should be in.</p>
</section>
</chapter>
