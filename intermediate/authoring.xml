<?xml version="1.0" encoding="UTF-8"?>
<chapter>
<title>Authoring</title>
<annotations>
<p>Concepts</p>
<p><phrase><annotation type="concept">subject domain</annotation></phrase> <phrase><annotation type="concept">media domain</annotation></phrase> <phrase><annotation type="concept">document domain</annotation></phrase> <phrase><annotation type="concept">management domain</annotation></phrase> <phrase><annotation type="concept">subject-domain</annotation></phrase> <phrase><annotation type="concept">media-domain</annotation></phrase> <phrase><annotation type="concept">document-domain</annotation></phrase> <phrase><annotation type="concept">management-domain</annotation></phrase> <phrase><annotation type="concept">hybrid tagging language</annotation></phrase> <phrase><annotation type="concept">Every Page is Page One</annotation></phrase> <phrase><annotation type="concept">abstract language</annotation></phrase> <phrase><annotation type="concept">information architecture</annotation></phrase> <phrase><annotation type="concept" specifically="top-down information architecture">top-down</annotation></phrase> <phrase><annotation type="concept">metadata</annotation></phrase></p>
<p>Languages</p>
<p><phrase><annotation type="language">SAM</annotation></phrase> <phrase><annotation type="language">DITA</annotation></phrase> <phrase><annotation type="language">DocBook</annotation></phrase> <phrase><annotation type="language">Markdown</annotation></phrase> <phrase><annotation type="language">HTML</annotation></phrase> <phrase><annotation type="language">XML</annotation></phrase></p>
<p>Algorithms</p>
<p><phrase><annotation type="algorithm">publishing algorithm</annotation></phrase> <phrase><annotation type="algorithm">publishing</annotation></phrase> <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> <phrase><annotation type="algorithm">synthesis</annotation></phrase> <phrase><annotation type="algorithm">presentation algorithm</annotation></phrase> <phrase><annotation type="algorithm">presentation</annotation></phrase> <phrase><annotation type="algorithm">formatting algorithm</annotation></phrase> <phrase><annotation type="algorithm">formatting</annotation></phrase> <phrase><annotation type="algorithm">encoding algorithm</annotation></phrase> <phrase><annotation type="algorithm">encoding</annotation></phrase> <phrase><annotation type="algorithm">composition algorithm</annotation></phrase> <phrase><annotation type="algorithm">composition</annotation></phrase> <phrase><annotation type="algorithm" specifically="composition">composability</annotation></phrase> <phrase><annotation type="algorithm">conformance</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance">validation</annotation></phrase> <phrase><annotation type="algorithm">conformance algorithm</annotation></phrase> <phrase><annotation type="algorithm">separating content from formatting</annotation></phrase> <phrase><annotation type="algorithm">single sourcing</annotation></phrase> <phrase><annotation type="algorithm">single sourcing algorithm</annotation></phrase> <phrase><annotation type="algorithm">differential single sourcing</annotation></phrase> <phrase><annotation type="algorithm">differential single sourcing algorithm</annotation></phrase> <phrase><annotation type="algorithm">single source of truth</annotation></phrase> <phrase><annotation type="algorithm">single source of truth algorithm</annotation></phrase> <phrase><annotation type="algorithm">reuse</annotation></phrase> <phrase><annotation type="algorithm">content reuse</annotation></phrase> <phrase><annotation type="algorithm">content reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm">reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm">content management algorithm</annotation></phrase> <phrase><annotation type="algorithm">content management</annotation></phrase> <phrase><annotation type="algorithm">linking</annotation></phrase> <phrase><annotation type="algorithm">linking algorithm</annotation></phrase> <phrase><annotation type="algorithm">rendering algorithm</annotation></phrase> <phrase><annotation type="algorithm">authoring algorithm</annotation></phrase> <phrase><annotation type="algorithm">quality</annotation></phrase> <phrase><annotation type="algorithm">extract and merge</annotation></phrase> <phrase><annotation type="algorithm">relevance</annotation></phrase> <phrase><annotation type="algorithm">quality algorithm</annotation></phrase> <phrase><annotation type="algorithm">extract and merge algorithm</annotation></phrase> <phrase><annotation type="algorithm">relevance algorithm</annotation></phrase></p>
<p>Tools</p>
<p><phrase><annotation type="tool">content management system</annotation></phrase> <phrase><annotation type="tool">Content management systems</annotation></phrase></p>
<p>Roles</p>
<p><phrase><annotation type="role">information architect</annotation></phrase></p>
</annotations>
<p>It may not be immediately obvious that authoring is an algorithm. It is not something done to content, rather it is the process that creates content. The creation of content is obviously a process and activity, but it is (for the most part) performed by people rather than machines, and it is not obvious that it is done using a set of fixed processing rules, which would define it as an algorithm.</p>
<p>But as I have emphasized throughout the chapters on algorithms, the algorithms always begin with structures. Unstructured writing is not an algorithm (or at least, it is a more advanced AI algorithm that we yet know how to write). It is a human action, and an action of the imagination. But structured writing requires something more. It requires that authors not only create content, but that they create content in structures that can drive all the other structured writing algorithms that we want to implement.</p>
<p>Creating content in such structures is an activity over and above the pure act of writing content. The only way we get content in the right structures is if authors create those structures as they write. Our structured writing system can only be a good as the structured content our writers create. Getting the best possible structure from our writers, therefore is key to all of the algorithms and all of the benefits of structured writing. This is not something we can afford to leave to chance. We need to be systematic about it. We need an authoring algorithm.</p>
<p>Like all other structured writing algorithm, the authoring algorithm begins with the design of structures. Creating a set of content structures while thinking only about how they will feed publishing or content management structures is a recipe for a system that is difficult to use, expensive to implement and run, and subject to ongoing data problems. You will not get good data for any downstream algorithms unless your structures are engineered for ease of correct authoring.</p>
<p>All forms of structured writing, even in the <phrase><annotation type="concept">media domain</annotation></phrase> require authors to do something other than simply write. Since writing is an intellectually challenging activity that requires full attention, adding structured writing requirements into the mix necessarily takes away some of the attention that should otherwise be given to content, which obviously has the potential to reduce the quality of the content. Clearly, therefore, we need to make sure that the intrusion of structured writing requirements onto the writing process is a minimal as possible.</p>
<p>But the equation is not quite so simple as this. Structured writing may be an additional requirement, but quality writing does not result from an author simply spilling words onto a page or screen in stream of consciousness fashion. Writing is a design activity. It creates a structure of words that conveys complex ideas and information about the real world. It very much matters that the author says the right things using the right words in the right order. If structured writing techniques can help with this literary design work, they can lessen the intellectual burden on the author, and thus potentially improve the quality of the content.</p>
<p>Of course, structured writing can improve <phrase><annotation type="algorithm">content quality</annotation></phrase> in other ways. Most of the algorithms we have looked at pertain to content quality in one way or another. Still, these algorithms work on the structures that the authors create. If those structures are weak, there is a limit to what downstream algorithms can do to improve quality. It really all begins with getting the right structures correctly and reliably applied by authors as they write.</p>
<p>In media-domain systems like word processor and desktop publishing systems, the writer is asked to think about formatting structures while writing. One of the traditional arguments for structured writing is to relieve the writer of the burden of thinking about (and manipulating) formatting so they can focus on writing.</p>
<p>This means moving to the document domain. But in the document domain, the writer has a new set of structures to think about: document domain structures. Is it easier on the writer to think about and manipulate document domain structures than media domain structures? In some cases, yes. For instance, writing a blog post or a web page in MarkDown may be less cumbersome for some writers than using a WYSIWYG HTML editor.</p>
<p>However, Markdown does not contain enough structure, or enough constraints on its structure, to enable many of the algorithms we have talked about. It offers little support for <phrase><annotation type="algorithm">composition</annotation></phrase>, <phrase><annotation type="algorithm">reuse</annotation></phrase>, or <phrase><annotation type="algorithm">single sourcing</annotation></phrase>, for instance, and virtually zero support for <phrase><annotation type="algorithm">conformance</annotation></phrase>.</p>
<p>If we want to support these algorithms, we will need something more structured, and this can easily mean something that requires more of the author’s attention. If we are proposing to implement management-intensive algorithms, such as <phrase><annotation type="algorithm">reuse</annotation></phrase>, it can mean that authors need to learn and manipulate an entire management system and the management policies that the organization puts in place around it. Depending on how complex and how foreign these policies are to the author’s experience, this can create a burden far greater that that of creating and manipulating formatting according to a style guide.</p>
<p>We could look at this and say, okay, yes, authoring is now more difficult and more complex than it was before because of all this additional structure and all that they need to learn to apply that structure, but we are getting additional advantages as well, so it is worth it overall. The problem is, as authoring get more difficult, authors do all of the component tasks less well. Attention is a finite resource. The more of it is focused on structure, the less is available for content. The more of the writer’s attention is required on structure, the less is available for writing, and the quality of the writing suffers. And as the quality of the writing suffers, the writer becomes frustrated with the system, and becomes more interested in getting their ideas down than in obeying the onerous structural rules that are getting in their way. When that happens, the quality of the structure suffers as well. And if both the quality of the writing and the quality of the structures decline, the less reliable all of your algorithms become, and the more tenuous all of benefits you hoped to obtain.</p>
<p>To look at this another way, the more complex your system becomes, and the more algorithms you are attempting to support, the more important <phrase><annotation type="algorithm">conformance</annotation></phrase> becomes. But as we saw when we looked at the <phrase><annotation type="algorithm">conformance algorithm</annotation></phrase>, conformance is fundamentally a human activity. Good conformance results from creating structures that are easy to conform to.</p>
<p>One of the most familiar tropes of the content management industry is that problem with content management systems are not technology problems, they are human problems. The solution lies in better change management and more training. The presumption here is that the tools work fine if only you give them correct input. If the input is incorrect, that is the fault of the humans who create the input. But this is and argument we would not accept for any other kind of system. For any other kind of system we would say, this system is too hard to use, not the problem is everybody needs to be better trained and more accepting of change. This is really an excuse for poor system design. If humans cannot conform to the structures that the system requires, the fault is in the system design. The structures should be redesigned to be easier to conform to. The authoring algorithm has been neglected in the system design.</p>
<p>In many systems, the attempt to make authoring easy as been an afterthought, treated as a tools question rather than an question of structure design. Markup languages are designed to feed publishing or content management algorithms. The tools such as XML editors are used to provide pseudo-WYSIWY interfaces and various widgets are created to help authors create the often complex management domain metadata involved. The problem with this approach is that at best it addresses the mechanical ease of use issues of creating and managing this complex markup. It does not address the conceptual ease of use issues that arise from the author needing to understand the algorithms that act on this complex and abstract markup.</p>
<p>Hiding markup, in other words, does not factor out structure. But the bigger problem is that hiding markup also hides the structure. It makes the authoring process look superficially easier, but it actually makes things more difficult because it still asks authors to create structures while presenting an interface in which these structures are not visible. In a relatively simple document domain language, this is not the end of the world, because each document domain structure has a media domain equivalent. But any distinction that exists in the media domain that does not directly correspond to a media domain style will be hidden. And if the document domain language is loose, you will often get very poor document domain structures this way, as we have seen in the case of HTML produced by WYSIWYG HTML editors.</p>
<p>I have developed <phrase><annotation type="language">SAM</annotation></phrase>, the <phrase><annotation type="concept">hybrid tagging language</annotation></phrase> used for most of the examples in this book, to provide a markup-based solution to this problem. Other solution approaches are possible as well, such as forms-based interfaces.</p>
<p>How is engineering structures for ease of authoring consistent with engineering them to match the specific constraints that we want to impose for the sake of quality and efficient processing? As we have seen, moving content between the domains is a matter of factoring variants from invariants. By refactoring our structures we can produce radically different structures that can still be passed through the same publishing tool chain, simply by adding another processing step. To get to structures that both support our publishing and quality goals and support ease of correct authoring (which is essential to achieving those goals) we refactor our content into a form that is comfortable for our authors while still containing the structure needed for downstream processing.</p>
<p>One of the most important consequences of this, both for ease of authoring and reliability of data, is that in the subject domain, you are not asking the author to think and to structure content in terms of algorithms. In this sense, the move to the subject domain not only factors our specific constraints from the author, it factors out the need to think in algorithms at all, leaving the author free to think in terms of subject matter.</p>
<p>This kind of meta refactoring, where you are refactoring the author’s whole working model is extremely powerful. It can have profound impacts on content quality and the ease of the authoring experience. At the same time it may create resistance or confusion for some types of authors, such as technical writers, who tend to be responsible for the whole publishing process, not just the the writing piece of it. This means they have always been responsible for the publishing algorithms. When working in the media domain, they executed these algorithms themselves. When working in the document domain they have created structures that were directly related to the algorithms they understood and felt responsible for.</p>
<p>For instance, for indexing, they created index markers, for links they created xref structures. Yet as we have seen, in the subject domain both these things go away and their functions is replaced by subject annotations. This is much easier for authors who don’t want to think about linking and indexing algorithms, but disconcerting for those who are used to thinking about them.</p>
<p>There can be a conflict between ease of authoring and ease of content management as well. Content management may want to manage content down to a fine level of granularity, especially for purposes of content reuse. This content management algorithm may be best served by managing fairly small chunks of content. But for the writer, writing such small chunks may be difficult. If the chunk the author is asked to create is smaller than the piece the reader is expected to read, it is difficult for the author to get a sense of how the chunk they are writing meets the readers needs. It is hard to create parts rather than wholes unless the parts are really well defined. A writer might carry the whole of an essay in their head, for instance, and be able to structure it well on that basis. But if they are making only parts and cannot see the wholes that will be created, it is hard to correctly structure a part without very clear and explicit guidance.</p>
<p>We noted in the discussion of the <phrase><annotation type="algorithm">relevance algorithm</annotation></phrase> that the use of clearly labeled unambiguous identifiers can help algorithms determine the relevance of a piece of content. The problem is, not everything has a globally unambiguous identifier (such as a company stock ticker) and even for things that do, the author may know know what those identifies are off the top of their heads (for instance, many authors may know the names of companies like Apple, Google, and Microsoft but not know their full ticker symbol. Forcing them to look them up every time you want to to unambiguously identify a company will add a lot of overhead to the authoring process, and it will also make the markup of the information more complex, again impacting the efficiency of authoring.</p>
<p>Fortunately, we don’t have to unambiguously identify everything we write about at a global scale. We only have to ambiguously identify it within the context of the content we are writing. There is actually a universal truth about language in this. Very few words have only one meaning or identify only one thing. “Sun” is a big ball of burning gas and a computer company that was bought by Oracle. We distinguish these meaning by context, and we can distinguish content identifiers by context in the same way.</p>
<p>In fact, doing the identification in context is actually more accurate, since there is less possibility of accidentally introducing a confusion with a usage you are not aware of. The more highly contextualized an identifier is, the less ambiguous it is (as long as you specify both the context and the identifier you are looking for).</p>
</chapter>
