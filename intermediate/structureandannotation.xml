<?xml version="1.0" encoding="UTF-8"?>
<chapter>
<title>Structure and annotation</title>
<by>Mark Baker</by>
<p>Broadly speaking, structured markup provides two things: structure and annotation. Structure governs the relationship of pieces. It is structure that says that a list consists of list items, that an API reference must begin with a function signature followed by a list of parameter values, that says that an ingredient listing consists of the ingredient name followed by a quantity followed by a unit of measure, or that a section must begin with a title. It is in structure that we create, impose, and express most of the <phrase><annotation type="concept">constraints</annotation></phrase> that are fundamental to structured writing.</p>
<p>Whenever you place content in a structure, you are saying something about that content. What kind of thing you are saying about it depends on the domain of the markup.</p>
<ll>
<li>
<label>Media Domain</label>
<p>The structure says what the content should look like.</p>
</li>
<li>
<label>Document Domain</label>
<p>The structure says what role the content plays in the document.</p>
</li>
<li>
<label>Subject Domain</label>
<p>The structure relates the content to its subject matter.</p>
</li>
<li>
<label>Management Domain</label>
<p>The structure says how the content should be managed.</p>
</li>
</ll>
<p>But markup structures, such as XML elements, only allow you to say one thing about the content they contain. Suppose you want to say more than one thing about a piece of content? In that case, you can add annotations to express additional information.</p>
<p>The information in annotations does not have to be in the same domain as the structure they apply to. For instance:</p>
<ul>
<li>
<p>In <phrase><annotation type="language">DITA</annotation></phrase>, the <phrase><annotation type="attribute" namespace="DITA">keyref</annotation></phrase> attribute is used to add <phrase><annotation type="concept">management domain</annotation></phrase> metadata to a number of document structure elements.</p>
</li>
<li>
<p>In <phrase><annotation type="language">HTML</annotation></phrase>, the style attribute can be used to add <phrase><annotation type="concept">media domain</annotation></phrase> metadata to the document structure.</p>
</li>
</ul>
<p>But not all annotations add additional information to structures. It is possible to have annotations that stand alone. At a certain point in defining the structure of content we get down to what is essentially free-form narrative content -- that is, paragraphs of text. But even within a paragraph, that are pieces of text that we want to add metadata to for use by downstream processes. Examples from each of the domains include:</p>
<ll>
<li>
<label>Media Domain</label>
<p>A <phrase><annotation type="code">bold</annotation></phrase> or <phrase><annotation type="code">strong</annotation></phrase> annotation on a piece of text you want to emphasize.</p>
</li>
<li>
<label>Document Domain</label>
<p>An <phrase><annotation type="code">xref</annotation></phrase> annotation to create a reference to another part of the content.</p>
</li>
<li>
<label>Subject Domain</label>
<p>A <phrase><annotation type="code">function</annotation></phrase> annotation to identify that a piece of text is the name of a function.</p>
</li>
<li>
<label>Management Domain</label>
<p>A conditional annotation to identify a piece of text that may be conditionally included or excluded from output.</p>
</li>
</ll>
<section>
<title>Structure and annotation in SAM</title>
<p>In SAM, there are a number of types of structure, but the main extensible structure is the block. Annotations are part of the definition of the language. Annotations can be added to blocks and call also float in text.</p>
<codeblock language="SAM">
section:(#annotations) Annotations
    This is a paragraph containing an {annotation}(concept).
</codeblock>
<p>In the example above, <phrase><annotation type="code">section</annotation></phrase> is a structure containing a title and a paragraph. The <phrase><annotation type="code">section</annotation></phrase> structure has an annotation which is contained in parentheses immediately after the colon that defines the structure. In this case it is an ID annotation and assigns the ID “annotations” to the structure.</p>
<p>The word “annotation” in the paragraph is annotated with a free-floating annotation. The curly braces delineated the text that is being annotated. The parentheses contain the annotation itself, which in this case is a type annotation, indicating that the word “annotation” is a reference to concept.</p>
</section>
<section>
<title>Structure and annotation in XML</title>
<p>In XML we have two principle types of markup, the element and the attribute. These more or less correspond to the distinction I have made here between structure and annotation. Elements are for structure. Attributes are for annotation. The only caveat is that XML does not allow for free-floating annotations. To create an annotation inside a paragraph, you have to use an element. A paragraph (or any other block of text) with elements floating in it is called “mixed content”.</p>
<p>So the SAM example above could be expressed like this in XML:</p>
<codeblock language="XML">
&lt;section id="annotations"&gt;
    &lt;title&gt;Annotations&lt;/title&gt;
    &lt;p&gt;This is a paragraph containing an &lt;concept&gt;annotation&lt;/concept&gt;.
</codeblock>
</section>
<section>
<title>Structure in attributes</title>
<p>While SAM draws a distinction between structure and annotation, XML, as we have seen, does not. Its distinction between element and attribute roughly corresponds to my distinction, but not entirely so. This is a reflection of the fact that while SAM is designed for documents, XML is deliberately more general and designed for data applications where the structure and annotation distinction may not apply, or may not apply in the same way as it does in documents.</p>
<p>This means that it is possible to design XML languages that use attributes (normally an annotation mechanism) to express structure.</p>
<p>Consider these <phrase><annotation type="link" specifically="https://en.wikipedia.org/wiki/Microformat">examples of HTML Microformats from Wikipedia</annotation></phrase>. The first example shows an address formatted as a list.</p>
<codeblock language="HTML">
&lt;ul&gt;
   &lt;li&gt;Joe Doe&lt;/li&gt;
   &lt;li&gt;The Example Company&lt;/li&gt;
   &lt;li&gt;604-555-1234&lt;/li&gt;
   &lt;li&gt;&lt;a href="http://example.com/"&gt;http://example.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</codeblock>
<p>Here the phrase <phrase><annotation type="code">The Example Company</annotation></phrase> is contained in <phrase><annotation type="code">li</annotation></phrase> tags. This is part of a list structure delineated by <phrase><annotation type="code">ul</annotation></phrase> tags, so the markup is largely structural in the document domain. The <phrase><annotation type="code">li</annotation></phrase> does not really tell you anything useful about what the content itself is about. It does not tell you anything useful beyond what document structure it belongs to. It is not much use as an annotation.</p>
<p>The second example adds hCard microformat markup:</p>
<codeblock language="HTML">
&lt;ul class="vcard"&gt;
   &lt;li class="fn"&gt;Joe Doe&lt;/li&gt;
   &lt;li class="org"&gt;The Example Company&lt;/li&gt;
   &lt;li class="tel"&gt;604-555-1234&lt;/li&gt;
   &lt;li&gt;&lt;a class="url" href="http://example.com/"&gt;http://example.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</codeblock>
<p>This example adds subject domain metadata in the form of the class attribute. For example, it says that the phrase <phrase><annotation type="code">The Example Company</annotation></phrase> is a reference to an organization (<phrase><annotation type="code">org</annotation></phrase>). So far this is just regular annotation.</p>
<p>However, there is not just annotation going on here. There is actually subject domain structure being expressed. Not only is the list item <phrase><annotation type="code">The Example Company</annotation></phrase> annotated as <phrase><annotation type="code">org</annotation></phrase>, the list that contains it is annotated as <phrase><annotation type="code">vcard</annotation></phrase>. The meaning of <phrase><annotation type="code">org</annotation></phrase> is actually dependent on it being part of a <phrase><annotation type="code">vcard</annotation></phrase> structure.</p>
<p>In other words, the annotations in the sample above are equivalent to pure subject domain markup like this:</p>
<codeblock language="HTML">
&lt;vcard&gt;
   &lt;fn&gt;Joe Doe&lt;/fn&gt;
   &lt;org&gt;The Example Company&lt;/org&gt;
   &lt;tel&gt;604-555-1234&lt;/tel&gt;
   &lt;url&gt;http://example.com/&lt;/url&gt;
&lt;/vcard&gt;
</codeblock>
<p>In other words, the microformats are overlaying a second structure on the list structure. In the world of HTML, this makes sense. HTML needs to be a standardized document domain language so that browsers can display it for human reading. Humans don’t need the vCard annotations to recognize that the content is an address, but algorithms do. So the microformat adds a second, hidden, subject domain structure to the document for readers who are algorithms rather than people.</p>
<p>Authoring our content this way would obviously be inefficient. But as we have seen, we can process subject domain structures to produce document domain structures with the <phrase><annotation type="algorithm">presentation algorithm</annotation></phrase>. If you write this content in the subject using markup like the above, you could transform it to the HTML with microformats example shown above with a presentation algorithm like this:</p>
<codeblock language="pseudo">
match vcard
    create ul
        attribute class = "vcard"
        continue

match fn
    create li
        attribute class = "fn"
        continue

match org
    create li
        attribute class = "org"
        continue

match tel
    create li
        attribute class = "tel"
        continue

match url
    create li
        create a
            attribute class = "url"
            attribute href = contents
            continue
</codeblock>
<p>In other words, we can factor out the document domain structure from the HTML for authoring and storage and then factor it back in for output.</p>
</section>
<section>
<title>Structure or annotation</title>
<p>Since both structures and annotations can contain information about content, you often have to decide whether to use one of the other to capture some of the metadata you need. Here are some of the basic considerations:</p>
<p>Annotations are more difficult to constrain than structures. It is not that you can’t constrain which annotation apply to which structures. In XML, for instance, you could require that every element <phrase><annotation type="code">a</annotation></phrase> have an attribute <phrase><annotation type="code">b</annotation></phrase>. But while that may work in some cases, it only applies if <phrase><annotation type="code">b</annotation></phrase> is relevant to all instance of <phrase><annotation type="code">a</annotation></phrase>, and with most of the things you want attributes for, that is not the case. So that means the <phrase><annotation type="code">b</annotation></phrase> needs to be optional, which means it is less constrained. (There is a constraint on which attributes <phrase><annotation type="bold">may</annotation></phrase> occur, but not on which <phrase><annotation type="bold">must</annotation></phrase> occur.)</p>
<p>Structures provide superior guidance. Even if all you need for downstream processing is metadata that could be provided by annotations, using structures makes it easier to guide authors to provide the metadata you need, and to audit the content to make sure the information has been provided correctly.</p>
<p>Structures establish context. As we have seen, the ability to establish context is key to many algorithms. Annotations exist in the context established by structures, but do not create new context themselves.</p>
<p>Similarly, if you are annotating words and phrases within a paragraph, it is difficult to constrain which words should be annotated or how. If you really need a particular piece of information to be constrained consistently, you probably need to factor out the paragraph and capture it as a set of field structures that can be properly constrained and audited. (You can turn it back into a paragraph in the <phrase><annotation type="algorithm">presentation algorithm</annotation></phrase> if you want to publish it that way.}</p>
<!-- example -->
<p>Secondly, annotation are generally harder for writers to create than structures. This depends in part on which markup languages you are using, and which editing tools, but in XML, for instance, where annotation are usually created using attributes, a string of attributes on an element can make the document very hard to read in plain text view, which most XML editors, which are generally optimized for document domain editing, make it much more difficult to add attributes than elements, and generally hide attributed from view (at least by default) making it harder to edit them, or to see how they impact the overall structure of the document.</p>
<p>Of course, if you need to add more than one piece of <phrase><annotation type="concept">metadata</annotation></phrase> to a piece of content, you will have to use annotations to do it because one structure, by itself, can only express one piece of information. However, by moving your content to a different domain, you may be able to avoid the need to use as many annotations. When you write content in the document domain, for example, any media, subject, or management domain metadata you want to add to the information must be expressed as annotations. But if you move your content to the subject domain, you can often factor out the document domain, media, and management domain structures, meaning you can rely on the subject domain structures alone and have less need for additional annotations.</p>
<p>(It should be noted here that it is uncommon to have a real world tagging language that is entirely in one domain. While media domain languages are often entirely in the media domain, document domain languages commonly include some subject domain structures or annotations and often extensive management domain structures and annotations. Even subject domain languages usually need at least basic document structures like paragraphs and lists, and may also need some management domain structures and annotations for management information that cannot easily be factored out into sensible subject domain structures.)</p>
<p>Structures are more expressive than annotation. Structures break a document into pieces and label the pieces. This allows you to see the structure of the document as a whole and reflect on it as a whole. It allows you to navigate the document more easily and audit it more thoroughly. In a markup language like SAM which deliberately expresses the structure, it is easier to take in the structure of the document at a glance.</p>
<!--  Note that storing document domain content in a subject domain CMS schema is another case of overlying the domains. -->
<p>What happens when you need to format part of your document differently, but your document domain language does not have a document domain structure for the document element you are creating? For example, if your document domain language is HTML, it does not have any structures for common document domain objects like procedures, sidebars, of bibliographies?</p>
<p>Of course, you can create these things in an HTML document, using regular features like lists, divs, and paragraphs. To indicate how they are to be formatted, though, you will have to either apply style information directly in the file, or else add some kind of metadata that indicates the special role that the list, div, or paragraph is playing. In HTML, the normal strategy is to use a class attribute. So, you could support special styling of a procedure list by giving it a class attribute of “procedure”:</p>
<codeblock language="HTML">
&lt;ol class="procedure"&gt;
    &lt;li&gt;Lather.&lt;/li&gt;
    &lt;li&gt;Rinse.&lt;/li&gt;
    &lt;li&gt;Repeat.&lt;/li&gt;
&lt;ol&gt;
</codeblock>
<p>This is, in some ways, like giving HTML a procedure document domain object. We can now format as a procedure. And because we are using a hierarchical system, we don’t need to add class attributes to the li elements to format them different. We can set an invariant rule that all li elements that are children of an ol element of class “procedure” will be formatted a certain way.</p>
<codeblock language="CSS">
ol.procedure li
{
}
</codeblock>
<p>We said that when we define a style, we are extending the media domain. In the same way, if we work in the document domain, we often need to extend the document domain we are working in. HTML is not an extensible language. To fill the need for an extensible document domain language, the W3C adopted XML (eXtensible Markup Language). XML allows you to extend your document domain (or any other domain) in two ways:</p>
<ol>
<li>
<p>by creating brand new structures in that domain.</p>
</li>
<li>
<p>by using attributes to specify additional type information for an existing structure.</p>
</li>
</ol>
<p>Another method for extending the document domain is provided by <phrase><annotation type="language">DITA</annotation></phrase> through it specialization mechanism, which allows you to create a new structure by specializing an existing one. In practice, this means defining a new structure but with the difference that the system knows about the new structures relationship to the old one, so that if you specialize a numbered list, the system knows that your new list is a type of numbered list.</p>
<p>Yet another method is provided by <phrase><annotation type="tool">SPFE</annotation></phrase>, which supports creating a library of structures from which you can select the ones you want to build a set of document domain (or other domain) structures for your use.</p>
<p>We will look in detail later at ways of extending your document domain objects. For now, lets begin by looking at what the document domain looks like, and why you want to add additional kinds of document domain objects.</p>
</section>
</chapter>
