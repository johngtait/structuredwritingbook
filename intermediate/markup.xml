<?xml version="1.0" encoding="UTF-8"?>
<chapter name="chapter.markup">
<title>Markup</title>
<annotations>
<p>Concepts</p>
<p><phrase><annotation type="concept">subject domain</annotation></phrase> <phrase><annotation type="concept">media domain</annotation></phrase> <phrase><annotation type="concept">document domain</annotation></phrase> <phrase><annotation type="concept">management domain</annotation></phrase> <phrase><annotation type="concept">subject-domain</annotation></phrase> <phrase><annotation type="concept">media-domain</annotation></phrase> <phrase><annotation type="concept">document-domain</annotation></phrase> <phrase><annotation type="concept">management-domain</annotation></phrase> <phrase><annotation type="concept">hybrid tagging language</annotation></phrase> <phrase><annotation type="concept">Every Page is Page One</annotation></phrase> <phrase><annotation type="concept">abstract language</annotation></phrase> <phrase><annotation type="concept">information architecture</annotation></phrase> <phrase><annotation type="concept" specifically="top-down information architecture">top-down</annotation></phrase> <phrase><annotation type="concept">metadata</annotation></phrase></p>
<p>Languages</p>
<p><phrase><annotation type="language">SAM</annotation></phrase> <phrase><annotation type="language">DITA</annotation></phrase> <phrase><annotation type="language">DocBook</annotation></phrase> <phrase><annotation type="language">Markdown</annotation></phrase> <phrase><annotation type="language">HTML</annotation></phrase> <phrase><annotation type="language">XML</annotation></phrase></p>
<p>Algorithms</p>
<p><phrase><annotation type="algorithm">authoring algorithm</annotation></phrase> <phrase><annotation type="algorithm">authoring</annotation></phrase> <phrase><annotation type="algorithm" specifically="composition">composability</annotation></phrase> <phrase><annotation type="algorithm">composition algorithm</annotation></phrase> <phrase><annotation type="algorithm">composition</annotation></phrase> <phrase><annotation type="algorithm">conformance algorithm</annotation></phrase> <phrase><annotation type="algorithm">conformance</annotation></phrase> <phrase><annotation type="algorithm">content management algorithm</annotation></phrase> <phrase><annotation type="algorithm">content management</annotation></phrase> <phrase><annotation type="algorithm">content reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm">content reuse</annotation></phrase> <phrase><annotation type="algorithm">differential single sourcing algorithm</annotation></phrase> <phrase><annotation type="algorithm">differential single sourcing</annotation></phrase> <phrase><annotation type="algorithm">encoding algorithm</annotation></phrase> <phrase><annotation type="algorithm">encoding</annotation></phrase> <phrase><annotation type="algorithm">exchange algorithm</annotation></phrase> <phrase><annotation type="algorithm">exchange</annotation></phrase> <phrase><annotation type="algorithm">extract and merge algorithm</annotation></phrase> <phrase><annotation type="algorithm">extract and merge</annotation></phrase> <phrase><annotation type="algorithm">formatting algorithm</annotation></phrase> <phrase><annotation type="algorithm">formatting</annotation></phrase> <phrase><annotation type="algorithm">linking algorithm</annotation></phrase> <phrase><annotation type="algorithm">linking</annotation></phrase> <phrase><annotation type="algorithm">presentation algorithm</annotation></phrase> <phrase><annotation type="algorithm">presentation</annotation></phrase> <phrase><annotation type="algorithm">publishing algorithm</annotation></phrase> <phrase><annotation type="algorithm">publishing</annotation></phrase> <phrase><annotation type="algorithm">quality algorithm</annotation></phrase> <phrase><annotation type="algorithm">quality</annotation></phrase> <phrase><annotation type="algorithm">relevance algorithm</annotation></phrase> <phrase><annotation type="algorithm">relevance</annotation></phrase> <phrase><annotation type="algorithm">rendering algorithm</annotation></phrase> <phrase><annotation type="algorithm">rendering</annotation></phrase> <phrase><annotation type="algorithm">reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm">reuse</annotation></phrase> <phrase><annotation type="algorithm">separating content from formatting</annotation></phrase> <phrase><annotation type="algorithm">single source of truth algorithm</annotation></phrase> <phrase><annotation type="algorithm">single source of truth</annotation></phrase> <phrase><annotation type="algorithm">single sourcing algorithm</annotation></phrase> <phrase><annotation type="algorithm">single sourcing</annotation></phrase> <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> <phrase><annotation type="algorithm">synthesis</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance">validation</annotation></phrase></p>
<p>Tools</p>
<p><phrase><annotation type="tool">content management system</annotation></phrase> <phrase><annotation type="tool">Content management systems</annotation></phrase></p>
<p>Roles</p>
<p><phrase><annotation type="role">information architect</annotation></phrase></p>
</annotations>
<p>Through much of this book so far I have talked about markup without really explaining it. Markup is the way much, but not all, structured writing is done. Let’s look at the alternative and the varieties of approaches to markup.</p>
<p>First, structured writing, in the broadest sense, is writing that applies any form of structure (any set of constraints) to writing. As such, most forms of writing on a computer, other than perhaps in a straight text editor without the use of markup, are structured writing since they all contain text in structures.</p>
<p>All writing programs have to store the writing in files. There are two possible file types they can use: binary and text.</p>
<p>For all intents and purposes, a binary file is one that can only be read or written by a computer program, usually the program that created it. Open up a binary file in a text editor and you won’t be able to make heads or tails of it. And even if parts of it look like plain text, editing those sections and saving the file is likely to result in a corrupt file that the original application can no longer open.</p>
<p>A text file, by contrast, is one that you can open in a text editor and actually be able to read and write without breaking it. But to express structure in a text file, you need a way to interpolate information about structure into the text. The way we interpolate structure is with markup -- special sequences of text characters that are recognized as defining structure rather than  expressing text.</p>
<p>I am being careful to frame the distinction here as between “markup” and “text”. It is easy to slip into talking about “markup” and “content”, but this is a misnomer. Markup is content every bit as much as text. As we have seen, structured writing consists of factoring variants from invariants in content. They sometimes means replacing text with markup in the document or subject domains. The structures that the markup expresses are just as vital to the information being captured as the text within those structures. Markup is content just as much as text or graphics.</p>
<section>
<title>Why markup?</title>
<p>Structured writing is writing to which explicit structure has been applied. But binary formats can express such structures just a well as markup can. Why do we so often use markup rather than binary file formats for structured writing?</p>
<p>There are three main reasons:</p>
<ll>
<li>
<label>Application independence</label>
<p>With binary files, it is possible to obscure how the file is interpreted, making it more difficult to write other applications that can edit the file. With markup, it is generally much easier to create other applications that can read and write the same file. This supports the development of <phrase><annotation type="concept">tool chains</annotation></phrase>, often based on open-source tools, to implement whatever set of structured writing algorithms are important to a business.</p>
</li>
<li>
<label>Ad hoc structure definition</label>
<p>If you need to define a structure to serve a particular purpose, perhaps one that will be used for relatively few documents, then you need a simple and inexpensive way to create that structure. Markup can provide such a format. It is much easier, for instance, to define a subject-domain markup language for a particular purpose than it is to create a binary file format and a program to read and write it.</p>
</li>
<li>
<label>Human reading and writing</label>
<p>Markup makes it possible for humans to read and write files that are processable by computers. This makes it much easier to build a <phrase>tool chain</phrase> for different components and to integrate them to meet your needs. All markup formats make it possible for humans to read and write the files, but not all formats make it easy. As we shall see, some formats are much easier to write in than others.</p>
</li>
</ll>
</section>
<section>
<title>Markup vs. regular text</title>
<p>Some markup languages make the distinction between markup and regular text completely explicit. An example of explicit markup is an HTML tag. Tags are set off by opening and closing angle brackets:</p>
<codeblock language="HTML">
&lt;h1&gt;Moby Dick&lt;/h1&gt;
&lt;p&gt;Herman Melville's &lt;i&gt;Moby Dick&lt;/i&gt; is a long book about a big whale.&lt;/p&gt;      
</codeblock>
<p>HTML uses open angle brackets <phrase><annotation type="code">&lt;</annotation></phrase> to indicate the start of markup and closing angle brackets <phrase><annotation type="code">&gt;</annotation></phrase> to indicate the end of markup and a return to regular text. Actually the recognition of markup in HTML is a little more complicated than that, but that is more detail than we need to get into here. What matters is that there are certain sequences in the text which trigger a processing program (generally called a “parser”) to recognize when markup starts and when it ends.</p>
<p>What if you want to enter these “markup start” characters into the text of your document? You can’t just type them in because the parser will think they are markup. To fix this, markup languages either define “escape” characters, that signal the parser to treat the following character as content, or they include markup for inserting individual characters in a way that won’t be confused with markup characters. HTML takes the second approach. To include a <phrase><annotation type="code">&lt;</annotation></phrase> character in HTML, you use another type of markup called a “character entity.” A character entity is a code for a character. It begins with <phrase><annotation type="code">&amp;</annotation></phrase> (another “markup start character), followed by a character code and ending with a semicolon. The character entity for <phrase><annotation type="code">&lt;</annotation></phrase> in HTML and XML is <phrase><annotation type="code">&amp;lt;</annotation></phrase>. (“lt” us short for “less than”, the name of the <phrase><annotation type="code">&lt;</annotation></phrase> character.)</p>
<codeblock language="html">
&lt;p&gt;In HTML, tags start with the &amp;lt; character.&lt;/p&gt;
</codeblock>
<p>This will display as:</p>
<blockquote>
<p>In HTML, tags start with the &lt; character.</p>
</blockquote>
<p>Since <phrase><annotation type="code">&amp;</annotation></phrase> is also a markup start character, we need to replace it with a character entity as well if we want to include it literally. To include a literal <phrase><annotation type="code">&amp;</annotation></phrase> you use the character entity <phrase><annotation type="code">&amp;amp;</annotation></phrase>.</p>
<codeblock language="html">
&lt;p&gt;In HTML, character entities start with the &amp;amp; character.&lt;/p&gt;
</codeblock>
<p>This will display as:</p>
<blockquote>
<p>In HTML, character entities start with the &amp; character.</p>
</blockquote>
<p>To include the literal sting <phrase><annotation type="code">&amp;amp;</annotation></phrase> therefore, you would write <phrase><annotation type="code">&amp;amp;amp;</annotation></phrase>.</p>
<codeblock language="html">
&lt;p&gt;The character entity for an ampersand is &amp;amp;amp;.&lt;/p&gt;
</codeblock>
<p>This will display as:</p>
<blockquote>
<p>The character entity for an ampersand is &amp;.</p>
</blockquote>
<p>Other markup languages do not make such an explicit distinction between text and markup. For example, in Markdown a numbered list is created by putting numbers in front of list items:</p>
<codeblock language="markdown">
1. First
2. Second
3. Third
</codeblock>
<p>Here the numbers are markup. That is, the Markdown processor recognizes them as indicating a list and will translate them into a structure in HTML like this:</p>
<codeblock language="html">
&lt;ol&gt;
    &lt;li&gt;First&lt;/li&gt;
    &lt;li&gt;Second&lt;/li&gt;
    &lt;li&gt;Third&lt;/li&gt;
&lt;/ol&gt;
</codeblock>
<p>But at the same time, the numbers look like text to the writer or reader of the Markdown file, and there is no need escape numbers followed by periods when they occur elsewhere in the text. Thus the following markdown file:</p>
<codeblock language="markdown">
1. First comes 1.
2. Second comes 2.
3. Third comes 3.
</codeblock>
<p>will translate to HTML as:</p>
<codeblock language="html">
&lt;ol&gt;
    &lt;li&gt;First comes 1.&lt;/li&gt;
    &lt;li&gt;Second comes 2.&lt;/li&gt;
    &lt;li&gt;Third comes 3.&lt;/li&gt;
&lt;/ol&gt;
</codeblock>
<p>Rather than thinking of markup as being something entirely distinct from text, therefore, it is better to think of markup as being a pattern within a piece of text that delineates its structure. In some cases those patterns may be absolute, meaning the same thing everywhere, and sometimes they may be contextual, meaning one thing in one location and something else in another location. Sometimes the markup characters may be entirely distinct from the text characters, and sometimes a pattern in the text may serve as markup as well.</p>
</section>
<section>
<title>Markup languages</title>
<p>A set of markup conventions taken together constitutes a markup language.  <phrase><annotation type="language">Markdown</annotation></phrase>, <phrase><annotation type="language">DocBook</annotation></phrase>, and <phrase><annotation type="language">JavaDoc</annotation></phrase> are all markup languages. However, each of these languages recognizes markup in a different way. <phrase><annotation type="code">&amp;</annotation></phrase> may be a markup start character in <phrase><annotation type="language">HTML</annotation></phrase> and <phrase><annotation type="language">XML</annotation></phrase>, but it is just plain text in <phrase><annotation type="language">reStructuredText</annotation></phrase>.</p>
<p>We can usefully divide markup languages into three types which I will call: concrete, abstract, and hybrid.</p>
</section>
<section>
<title>Concrete markup languages</title>
<p>A concrete markup language has a fixed set of markup that describes a fixed set of content structures. For example, <phrase><annotation type="language">Markdown</annotation></phrase> is a concrete markup language that uses a markup that is designed to mimic the way people write plain text emails. Here is the passage about <phrase><annotation type="title">Moby Dick</annotation></phrase> written in Markdown:</p>
<codeblock language="markdown">
Moby Dick
=========

Herman Melville's _Moby Dick_ is a long book about a big whale.
</codeblock>
<p>In <phrase><annotation type="language">Markdown</annotation></phrase>, a line of text underlined with equal signs (<phrase><annotation type="code">=</annotation></phrase>) is a level one heading. A paragraph is a block of text set off by blank lines. Emphasized text is surrounded with underscores or asterisks.</p>
<p>In Markdown, these patterns correspond directly to specific document structures. You cannot invent new structures without inventing a new version of Markdown.</p>
</section>
<section>
<title>Abstract markup languages</title>
<p>An abstract markup languages does not describe specific concrete document structures directly. It describes abstract structures which can be named to represent structures in any domain.</p>
<p>XML is an example of an abstract markup language.<citation type="idref" value="1"/> The markup in an XML file does not directly indicates things like headings or paragraphs. Instead, it indicates a set of abstract structures called elements, attributes, entities, processing instructions, marked sections, and comments.</p>
<footnote id="1">
<p>The formal term for a language like XML is “meta language”, a language for describing other languages. In calling XML an “abstract” language, I am focusing on a different property, its use of structures that are not parts of a document but generic containers. A meta language needs such abstract containers. But I find that the term “meta language” is not helpful to most readers, so I have chosen instead to focus on this property of using abstract structures as opposed to the concrete structures of a language like Markdown.</p>
</footnote>
<p>None of these abstract structures describes document structures in any of the structured writing domains. Instead, specific markup languages based on XML (or its cousin, SGML) indicate <phrase>subject</phrase>, <phrase>document</phrase>, <phrase>management</phrase>, or <phrase><annotation type="concept">media domain</annotation></phrase> structures as named instances of elements and attributes.</p>
<p>Here is the <phrase><annotation type="title">Moby Dick</annotation></phrase> passage again, this time in <phrase><annotation type="language">XML</annotation></phrase> (and more specifically, in <phrase>Docbook</phrase>:</p>
<codeblock language="DocBook">
&lt;section&gt;
    &lt;title&gt;Moby Dick&lt;/title&gt;
    &lt;para&gt;Herman Melville's &lt;citetitle&gt;Moby Dick&lt;/citetitle&gt; 
    is a long book about a big whale.&lt;/para&gt;
&lt;/section&gt;
</codeblock>
<p>The structure described by the XML syntax here is that of an element which contains two other elements, one of which contains text, and the one of which contains a mix of text and another element. There is no separate syntax for titles or paragraphs as there is in Markdown. Everything is an element. To define specific document domain structures, we give names to the elements.</p>
<p>Here, the document-domain structures “section”, “title”, and “para” are defined by XML elements named, respectively, “section”, “title”, and “para”. The generic <phrase><annotation type="code">&lt;i&gt;</annotation></phrase> tag from the HTML example has been replaced with them more semantically specific <phrase><annotation type="code">&lt;citetitle&gt;</annotation></phrase> tag, which in <phrase><annotation type="language">DocBook</annotation></phrase> means the name of a literary work. Both “i” and “citetitle” are modeled as XML elements in DocBook.</p>
<p>XML elements are generic abstract structures. Named elements can be used to represent any <phrase><annotation type="concept" specifically="media domain">media</annotation></phrase>, <phrase><annotation type="concept" specifically="document domain">document</annotation></phrase>, <phrase><annotation type="concept" specifically="subject domain">subject</annotation></phrase>, or <phrase><annotation type="concept">management domain</annotation></phrase> structure that you want, thus allowing you to create a markup language that suits a specific purpose.</p>
<p>Unlike a Markdown parser, an XML parser does not see paragraphs or titles. It sees elements. It passes the elements it finds, along with their names, down to a processing application which is responsible for knowing what “section”, “title”, and “para” elements mean in a particular markup language like DocBook. The parser is common to all XML-based languages, but the processing application is specific to DocBook. Thus while processing a concrete language like Markdown is generally a one step operation, processing an abstract language like XML is a two step operation, with the first step being to parse the file to discover the structures defined by elements and the second step to process those structures according to a specific set of rules.</p>
</section>
<section>
<title>Instances of abstract markup languages</title>
<p>This means that <phrase><annotation type="language">DocBook</annotation></phrase> is a instance of the abstract language <phrase><annotation type="language">XML</annotation></phrase>. XML defines abstract structures. DocBook defines concrete structures by giving names to XML’s abstract structures. Many common markup languages are instances of XML<citation type="idref" value="2"/>. XML is virtually the only abstract language used for content these days, so it is the only abstract language I am going to talk about.</p>
<footnote id="2">
<p>Sometimes also referred to as “applications” of XML, though this usage was far more common in the days of <phrase>SGML</phrase>.</p>
</footnote>
<p>If specific markup languages like <phrase><annotation type="language">DocBook</annotation></phrase> are instances of <phrase><annotation type="language">XML</annotation></phrase>, I need to revise my earlier statement: We can usefully divide markup languages into <phrase><annotation type="bold">four</annotation></phrase> types: concrete, abstract, instances of abstract, and hybrid. In fact (spoiler alert), lets revise it again: We can usefully divide markup languages into <phrase><annotation type="bold">five</annotation></phrase> types: concrete, abstract, instances of abstract, hybrid, and instances of hybrid.</p>
<p>By these definitions, abstract and hybrid are not language types you can actually write content in, they are languages that you can use to define other languages that are instances of them. Despite how we often use the term, you don’t actually write in XML, you write in DocBook or DITA or some other language like BeerML, which happen to be instances of XML.<citation type="idref" value="3"/> Thus in terms of actually writing content, we really do have just three types of markup languages: concrete languages, instances of abstract languages, and instances of hybrid languages.</p>
<footnote id="3">
<p>Or to put it another way, you write in DocBook semantics using XML syntax. Alternatively, since DocBook originated in the days of XML’s predecessor abstract language, SGML, you can write DocBook semantics in SGML syntax.</p>
</footnote>
<p>Or to put it another way, as a designer of markup languages your can either:</p>
<ul>
<li>
<p>Design a concrete language from scratch (or modify and existing one)</p>
</li>
<li>
<p>Use an abstract language (probably XML) to design a concrete language.</p>
</li>
<li>
<p>Use a hybrid language to design a concrete language.</p>
</li>
</ul>
<p>As a writer, you will either use:</p>
<ul>
<li>
<p>A concrete language with ad-hoc syntax (like Markdown)</p>
</li>
<li>
<p>A concrete language based on an abstract language (probably XML)</p>
</li>
<li>
<p>A concrete language based on a hybrid language</p>
</li>
</ul>
</section>
<section>
<title>Concrete languages in abstract clothing</title>
<p>The key defining characteristic of an abstract language is the use of abstract named structures like XML elements. All XML elements share a common markup start sequence followed by the element name. This creates a named block of content.  But concrete languages can use named blocks too. For example, <phrase><annotation type="language">JavaDoc</annotation></phrase>, a concrete language for describing Java APIs, uses named blocks using <phrase><annotation type="code">@</annotation></phrase> as a markup start character:</p>
<codeblock language="Java">
/**
 * Validates a chess move.
 *
 * Use {@link #doMove(int theFromFile, int theFromRank, 
 int theToFile, int theToRank)} to move a piece.
 *
 * @param theFromFile file from which a piece is being moved
 * @param theFromRank rank from which a piece is being moved
 * @param theToFile   file to which a piece is being moved
 * @param theToRank   rank to which a piece is being moved
 * @return            true if the move is valid, otherwise false
 */
boolean isValidMove(int theFromFile, int theFromRank, 
int theToFile, int theToRank) {
    // ...body
}
</codeblock>
<!--  Duplicate of content in publishing algorithms chapter -->
<p>In this sample, <phrase><annotation type="code">@param</annotation></phrase> and <phrase><annotation type="code">@return</annotation></phrase> are named blocks. But in JavaDoc, there is a fixed set of named blocks that are defined as part of the language. You can’t create a new language by defining your own block names. By contrast, <phrase><annotation type="language">XML</annotation></phrase> itself defines absolutely no element names. Only instances of XML, like <phrase><annotation type="language">Docbook</annotation></phrase>, define element names.</p>
<p>A particularly notable example of a concrete language in abstract clothing is <phrase><annotation type="language">HTML</annotation></phrase>. HTML looks a lot like an instance of XML, but it is not. An XML parser cannot parse most HTML. HTML is nominally an instance of SGML but never did quite conform to it. XHTML is a version of HTML that is an instance of XML. <phrase><annotation type="language">HTML5</annotation></phrase> actually supports two different syntaxes, one of which is an instance of XML and one of which is not, meaning that it has both a concrete syntax and a syntax which is a instance of an abstract language. (Sigh. This is consequence of having made a mess early on and having to live with it for evermore. A lesson for all markup language designers.)</p>
</section>
<section>
<title>The ability to extend</title>
<p>The downside of concrete languages is that their concrete syntax defines a fixed set of structures. If you want other structures, there is no way to create them short of inventing your own concrete language, or a variant on an existing one, and coding the parser and all the other tools to interpret that language. And designing new concrete languages is non-trivial because you need to make sure that any combination of characters that the writer may type is interpreted in an unambiguous way. Many versions of Markdown, including the original, contain ambiguities about how certain sequences of characters should be interpreted, which obviously detracts from its reliability and functional lucidity.</p>
<p>If you want to define your own structures to express the constraints that matter to your business, you need an easier way to do it. Abstract languages like XML make this much easier. You just write a <phrase><annotation type="tool">schema</annotation></phrase> describing the structures you want, and any algorithms you need to process those structures.</p>
</section>
<section>
<title>The ability to constrain</title>
<p>Extensibility allows you to add structures to a language but does not place restrictions on where they can occur.</p>
<p>Extensibility allows you to have elements called <phrase><annotation type="code">ingredients</annotation></phrase> and <phrase><annotation type="code">ingredient</annotation></phrase> and <phrase><annotation type="code">wine-match</annotation></phrase>. Constraints allow you to require that <phrase><annotation type="code">ingredient</annotation></phrase> only occurs inside an <phrase><annotation type="code">ingredients</annotation></phrase> structure and that the content of the <phrase><annotation type="code">ingredients</annotation></phrase> structure must be a sequence of <phrase><annotation type="code">ingredient</annotation></phrase> elements and nothing else. Constraints lets you say that writers can’t put <phrase><annotation type="code">wine-match</annotation></phrase> in the <phrase><annotation type="code">introduction</annotation></phrase> or as a <phrase><annotation type="code">step</annotation></phrase> in the <phrase><annotation type="code">preparation</annotation></phrase>, they can only put it as a child of <phrase><annotation type="code">recipe</annotation></phrase> after the <phrase><annotation type="code">servings</annotation></phrase> field and before the <phrase><annotation type="code">prep-time</annotation></phrase> field. Constraints allow, you to require that every recipe have the full list of nutritional information.</p>
<p>Constraints are what bring discipline to structured writing. They drive content quality and enable efficient reliable processing with algorithms. Constraints make it easier to write good algorithms because they limit the number of permutation of structures that you have to deal with.</p>
<p>All markup languages have constraints. A constraint is simply something that the markup language does not let you do. With a concrete language, you get the constraints that are built into the language. Abstract languages allow you to define your own structures, and therefore your own constraints. However, as we shall see in <citation type="nameref" value="chapter.extensible"/>, not all languages that are extensible are also constrainable.</p>
</section>
<section>
<title>Showing and hiding structure</title>
<p>The whole point of structured writing it to create content that meets constraints and that records the constraints it meets so that it can be reliably validated, audited, and processed. For this to happen, authors need to see the structures they are creating as formatted structures on screen. In the <phrase><annotation type="concept">media domain</annotation></phrase> a WYSIWYG interface shows your the media domain structures you are creating. But what about in the other domains? The document domain creates abstract document structures that are deliberately separated from their formatting. The subject domain creates subject-based structures that don’t have a one-to-one relationship with any organization or formatting of a document. The management domain creates structures that have nothing to do with the representation of content at all. How does the author get to see these structures when writing in these domains?</p>
<p>This is a big problem with <phrase><annotation type="language">XML</annotation></phrase>, the only abstract language in widespread use today. XML tends to hide structure. As an abstract language, an XML document is a hierarchy of elements and attributes -- not the concrete <phrase><annotation type="concept" specifically="subject domain">subject</annotation></phrase>, <phrase><annotation type="concept" specifically="document domain">document</annotation></phrase>, <phrase>management</phrase>, or <phrase><annotation type="concept">media domain</annotation></phrase> structures the author is supposed to be create. Those concrete structures are present in the markup because their names are there, but they are not visually distinguished the way the basic document structures are in a concrete language like Markdown. And XML syntax is verbose, meaning that there is a lot of clutter in the raw text of an XML document, which makes it hard to discern both the structure and the content (and also very laborious to write).</p>
<p>To remove that clutter, many authors use XML editors that provide a graphical view of the content similar to that of a word processor. But while XML editors removes visual clutter, they also hide the structure. Even if the author is supposed to be working in the document domain or the subject domain, the editor is now displaying content in the media domain. This greatly reduces the functional lucidity of the <phrase><annotation type="concept">document domain</annotation></phrase> or <phrase><annotation type="concept">subject domain</annotation></phrase> language and encourages backsliding into the <phrase><annotation type="concept">media domain</annotation></phrase>.</p>
<p>And then there are the problems that arise when you try to edit the WYSIWYG view of an XML document. Underneath is a hierarchical XML structure, but all you can see it the flat media-domain like view of the graphical editor. Editing or cutting and pasting structures you can’t see can be an exercise in futility. You can learn to do it, but it is frustrating and it takes time, and even when you learn, the process is still more complicated than it should be.</p>
<p>Concrete markup languages like Markdown, on the other hand, show you the structure you are creating and are simple to edit.</p>
</section>
<section>
<title>Hybrid languages</title>
<p>There are significant advantages and significant disadvantages, then, in both concrete and abstract languages. Hybrid languages try to find a middle way.</p>
<p>By hybrid, I mean a language that combines both abstract and concrete markup in one language. A hybrid language has a base set of concrete syntax describing basic text structures as well as abstract structures such as XML’s elements and attributes that can be the basis of extensibility and constraint.</p>
<p>An example of a hybrid markup language is <phrase><annotation type="language">reStructuredText</annotation></phrase>. Like <phrase><annotation type="language">Markdown</annotation></phrase>, it has a basic concrete syntax for things like lists and paragraphs. But it also supports what it calls “directives”, which are essentially named block structures. For example, a codeblock in reStructuredText looks like this:</p>
<codeblock language="reST">
.. code-block:: html
    :linenos:

    for x in range(10):
        print(x+1, "Hello, World")
</codeblock>
<p>reStructuredText provides an extension mechanism that allows you to add new directives. But while reST directives are similar to XML elements, reStructuredText predefines a core set of directives for common document structures. The <phrase><annotation type="code">code-block</annotation></phrase> directive above is not an extension of reStructuredText, it is part of the core language.</p>
<p>Because it defines a large set of document-domain directives, reStructuredText is inherently a document domain language. You could, of course, add subject-domain directives to it. Most document-domain languages in use today include some subject-domain structures, reflecting the purpose they were originally designed to serve. Nonetheless, reStructuredText is inherently document domain.</p>
<p>Another important note about reST is that it has no constraint mechanism. You can add new directives, but you can’t constrain their use, or the use of the predefined directives.</p>
<p>I have developed a hybrid markup language which is designed to be both extensible and constrainable. I call it SAM (which stands either for Semantic Authoring Markdown or Semantic Authoring Markup, as you please). SAM is the language I have been using for most of the examples in this book.</p>
<p>Here is the <phrase><annotation type="title">Moby Dick</annotation></phrase> passage written in SAM:</p>
<codeblock language="sam">
section: Moby Dick

    Herman Melville's {Moby Dick}(novel) is a long book about a big whale.
</codeblock>
<p>In SAM, as in Markdown and most other concrete markup languages, a paragraph is just a block of text set off by whitespace. Thus there is no explicit  structure named <phrase><annotation type="code">p</annotation></phrase> or <phrase><annotation type="code">para</annotation></phrase>.</p>
<p>At the beginning of a line, a single word without spaces and followed by a colon is an abstract structure called a block. The word before the colon is the name of the block. Thus <phrase><annotation type="code">section:</annotation></phrase> above creates a block structure named “section” just as in XML an element named <phrase><annotation type="code">&lt;section&gt;</annotation></phrase> would create a structure named “section”.</p>
<p>Blocks can contain blocks or text structures such as paragraphs and lists. The hierarchy of a SAM document is indicated by indentation. Thus the paragraph in the sample in indented under the section block. This removes the need for end tags, which reduces verbosity and helps make the structure of the document visually clear.</p>
<p>Within a paragraph, curly braces markup a phrase, to which you can attach an annotation in parentheses. Here the phrase “Moby Dick” is annotated to indicate that it is a novel. SAM also supports decorations like the underscores in the Markdown example, so in the <phrase><annotation type="concept">media domain</annotation></phrase> “Moby Dick” could have been written <phrase><annotation type="code">_Moby Dick_</annotation></phrase>.</p>
<p>SAM is not intended to be nearly as general in scope as a purely abstract markup language like XML. It is meant for semantic authoring (which is to say, structured writing). As such it incorporates a number of shortcuts to make writing typical structured documents easier.</p>
<p>In a typical document, a block of text (larger than a paragraph) typically has a title. So in SAM, a string after a block tag is considered to be a title. That means that the markup above is equivalent to:</p>
<codeblock language="sam">
section: 
    title: Moby Dick

    Herman Melville's {Moby Dick}(novel) is a long book about a big whale.
</codeblock>
<p>Unlike <phrase>RestructuredText</phrase>, however, <phrase><annotation type="language">SAM</annotation></phrase> does not have an extensive set of predefined blocks. It has just a few, which correspond the the basic text structures for which it provides shortcuts or concrete syntax. And SAM is designed to have a constraint mechanism, allowing you to write a schema to define what blocks and annotation are allowed in s SAM document. This includes constraining the use of the concrete syntax as well. SAM thus represents a different type of hybrid.</p>
<p>Also unlike <phrase><annotation type="language">RestructuredText</annotation></phrase>, <phrase><annotation type="language">SAM</annotation></phrase> is not intended to have its own publishing tool chain. SAM is really intended for creating <phrase><annotation type="concept">subject domain</annotation></phrase> languages, with just enough basic concrete document domain structures to make writing easier. The SAM parser outputs an <phrase><annotation type="language">XML</annotation></phrase> document which can then be further processed by any existing publishing tool chains by transforming it into an appropriate document domain language. This book was written in SAM, using a simple document-domain language I created for the purpose, with a number of subject domain annotations. That language was transformed into a semantically equivalent XML document by the SAM parser. That XML document was then transformed into <phrase><annotation type="language">DocBook</annotation></phrase> according to the publisher’s specifications (the publisher has a number of constraints on the DocBook they use that are not expressed in DocBook itself). From that point the publisher’s existing DocBook tool chain took over.</p>
<p>Most concrete markup languages, at least those designed for documents, try to make their marked-up documents look and read as much as possible like a formatted document. SAM is designed to be easy and natural to read, like a concrete markup language, but it is also designed to make the structure of the content as clear and explicit as possible while requiring the minimum of markup. This is why it uses indentation to express structure. Indentation shows structure clearly with a minimum of markup noise to distract the reader’s eye.</p>
<p>Because it is meant specifically for authoring, a SAM parser outputs XML, which can then be processed by the standard XML tool chain. Below is how the SAM markup above would be output by a SAM parser:</p>
<codeblock language="XML">
&lt;section&gt;
    &lt;title&gt;Moby Dick&lt;/title&gt;

    &lt;p&gt;Herman Melville's &lt;phrase&gt;
    &lt;annotation type="novel"/&gt;Moby Dick&lt;/annotation&gt;
    &lt;/phrase&gt; is a long book about a big whale.&lt;/p&gt;
&lt;/section&gt;
</codeblock>
<p>This book is authored in SAM. Most of its examples are in SAM. I’ll describe SAM more fully another chapter.</p>
</section>
<section>
<title>Instances of hybrid markup languages</title>
<p>I said above that this book is written in SAM, but that is not quite accurate. As noted above, you can’t write anything in an abstract or hybrid language directly. You write in instances of those languages. Thus DocBook is an instance of the abstract language XML. You can write documents in DocBook. We do say, of course, that we write documents in XML, but that statement is, if not wholly inaccurate, certainly non-specific. Saying the a document is written in DocBook tells you what constraints it meets. Saying it is written in XML merely tells you which syntax it uses, which is a whole lot less informative.</p>
<p>So, to be more specific, this book is written in a markup language written in SAM, one that I created for the specific purpose of writing this book. That markup language was then transformed by a processing application into <phrase><annotation type="language">DocBook</annotation></phrase>, which is the markup language that the publisher uses for producing books. From there is was processed through the publisher’s regular DocBook-based tool chain to produce print and e-book output.</p>
</section>
</chapter>
