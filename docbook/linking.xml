<?xml version="1.0"?>
<db:chapter xmlns:db="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">
<db:title>Algorithms: Linking</db:title>

<db:para>Few readers read content straight though. Unless the content is perfectly matched to their experience and their goals, there will be points where they need more information, points where they need less, or points where they decide that they need something else altogether. These are defection points in the content, points in which the reader’s “next” may not be the thing that comes next in the linear order of the work. That may mean deflecting to other content or to a different way of finding information such as asking a friend or posting a question on a forum.</db:para>
<db:para>Deflections are a natural part of information seeking. They are part of what is called information foraging. The reader, in pursuit of their individual ends, will follow where the scent of information leads and that will not always be the next paragraph of the current text.</db:para>
<db:para>Writers know they can’t meet everyone’s needs perfectly every time so they use links and other devices to help readers deflect when they need to. If you have Model A, do this. If you have Model B do that. Supporting deflection helps readers achieve their goals and helps keep the reader in writer’s own content, or content they approve of, rather than deflecting elsewhere.</db:para>
<db:para>Deflection points can be handled in various ways. The writer may choose to do nothing, leaving it up to the reader to look up a word if they don’t understand it, for instance. They may use footnotes, cross references, sidebars, parenthetical material, or hypertext links to provide deflection choices. They may use tables or flowcharts to allow readers to choose different paths through content. They may even attempt to anticipate and forestall deflection by using information about the individual reader to dynamically reorder the content to suit the reader’s needs.</db:para>
<db:para>Deflection costs the reader more on paper than online. For paper, we may design content to minimize the need to deflect, or to keep deflections inside the local work. For the Web, we may organize content with deflection in mind, allow different readers to choose their own course, rather than trying to optimize one course for all readers. This difference in the ease of deflection between paper and the Web and other hypertext media is one of the main reasons we want to practice differential single sourcing.</db:para>
<db:para>Deflection also enters into the discussion of content reuse. We reuse content in multiple documents so that readers don’t have to deflect from one document to another to find it.</db:para>
<db:para>If we reuse content in different media, we might want to have a different reused strategy between paper and hypertext outputs. Me may want to include the same chunk of content in multiple paper documents but link to a single copy of it when creating a hypertext. (Linking, in other words, is a kind of reuse: reuse by reference rather than copying.)</db:para>
<db:para>Thus we should not be thinking solely in terms of  managing links in our content. We should be thinking about implementing the right deflection strategy in each of our outputs. To see how that works, we need to look at deflection and linking in each of the structured writing domains.</db:para>
<db:section>
<db:title>Deflection in the media domain</db:title>
<db:para>In the media domain, we simply record the various deflection devices as such: cross references, tables, links, etc. For example, in HTML a link simply specifies a page to load:</db:para>
<db:programlisting language="html">
&lt;p&gt;In Rio Bravo, &lt;a href="https://en.wikipedia.org/wiki/John_Wayne"&gt;the Duke&lt;/a&gt; plays an ex-Union colonel out for revenge.&lt;/p&gt;
</db:programlisting>
<db:para>The phrase “the Duke” is a deflection point. The reader may not know who “the Duke” is, or may want more information on him. The link supports the reader at the deflection point. The reader can either deflect by clicking the link or stay the course and read on.</db:para>
<db:para>But if the HTML page gets printed, the link is lost. The phrase “the Duke” is still a deflection point. The reader can still deflect, by doing a search for “the Duke”, perhaps, or asking a friend what it means. But the printed version lacks any support for that deflection.</db:para>
<db:para>If the content had been written for paper, the deflection point might be supported in a different way. For example, it might be supported by adding an explanation in parentheses. (Parenthetical material is a type of deflection; it may be read or skipped.):</db:para>
<db:programlisting>
In Rio Bravo, the Duke (John Wayne) plays an ex-Union colonel out for revenge.
</db:programlisting>
<db:para>Or it might be handled with a footnote:</db:para>
<db:programlisting language="text">
In Rio Bravo, the Duke* plays an ex-Union colonel out for revenge.
        
...
        
* "The Duke" is the nickname of the actor John Wayne.
</db:programlisting>
<db:para>Clearly this is a case in which we would like to do differential single sourcing and handle a deflection point differently in different media. To accomplish this, we need to move the content out of the media domain.</db:para>
</db:section>
<db:section>
<db:title>Deflection in the document domain</db:title>
<db:para>Moving to the document domain is about factoring out the formatting specific structures of the media domain. But a link is not really a piece of formatting, so conventional refactoring into abstract document structures is not going to apply. For this reason, people working in the document domain often enter hypertext links exactly the way they would in the media domain: by specifying a URL. Thus in DITA you might enter a link as:</db:para>
<db:programlisting language="DITA">
&lt;p&gt;In Rio Bravo, &lt;xref href="https://en.wikipedia.org/wiki/John_Wayne" format="html"&gt;The Duke&lt;/xref&gt; plays an ex-Union colonel out for revenge.&lt;/p&gt;
</db:programlisting>
<db:para>The difference from HTML is slight here. The link element is called <db:code>xref</db:code> rather than <db:code>a</db:code>. But the meaning of <db:code>xref</db:code> is bit more general. The HTML <db:code>a</db:code> element is saying, create a hypertext link to this address. The DITA <db:code>xref</db:code> element is saying, create some sort of reference to this resource. (As we will see in a moment, it is capable of linking to things other than HTML pages, which is why it requires the <db:code>format</db:code> attribute to specify that in this case the target is an HTML page.) This generality gives us a little more leeway in processing. We can legitimately create print output from this markup that looks like this:</db:para>
<db:programlisting>
In Rio Bravo, the Duke (see: https://en.wikipedia.org/wiki/John_Wayne) plays and ex-Union colonel out for revenge.
</db:programlisting>
<db:para>This is not the way we would handle the deflection point if we were designing for paper, but it is a small improvement from a differential single sourcing point of view. At least the link is now visible to the reader. (Technically we could do this from the HTML markup as well, but that would be cheating. The HTML markup is not really giving us permission to do this. It is telling us to create a hypertext link and nothing else. The problem with cheating is that you are assuming constraints that are not being promised or enforced, and this can fail in ways you may not expect or catch. Some cheats are more reliable than others, but you probably don’t want to get into the habit.)</db:para>
<db:para>Fundamentally, though, this is not a satisfactory differential single sourcing solution. Unless there were no alternative, you would not normally direct a reader of paper to the web for more information, nor vice versa. Linking to an already published file, such as an HTML page, commits us to a particular format for the link target. If we link to content that has not yet been published, we gain the freedom to link to any format of that content that we choose to publish. The simplest way to do that is to link to a source file rather than an output file.</db:para>
<db:para>In DITA, you can link to another DITA file (the default format, so we don’t need the <db:code>format</db:code> attribute):</db:para>
<db:programlisting language="html">
&lt;p&gt;In Rio Bravo, &lt;xref href="John_Wayne.dita"&gt;The Duke&lt;/xref&gt; plays an ex-Union colonel out for revenge.&lt;/p&gt;
</db:programlisting>
<db:para>We don’t yet know if that DITA file will be published to paper or the Web, what the address of the published topic will be, or if that topic will stand alone or be assembled into a larger page or document for publication. This means that the publishing system is taking on responsibility for both ends of the link. It has to make sure that the target page is published in a way the source page can link to, and that the source page links to the right address.  But taking on this responsibly gives us the leeway to publish this link as we see fit.</db:para>
<db:para>If we publish as a book on paper and the target resource ends up as part of a chapter in the same book, we can render the <db:code>xref</db:code> as a cross reference to the page that resource appears on. We could format that cross reference inline or as a footnote. These are all legitimate interpretations of the <db:code>xref</db:code>’s instruction to create a reference to a resource.</db:para>
<db:para>If we publish to a help system and the target resource ends up as a topic in the same help system, we could render the <db:code>xref</db:code> as a hypertext link to that topic.</db:para>
<db:para>This is a big step forward, but it still does not let us do this:</db:para>
<db:programlisting>
In Rio Bravo, the Duke (John Wayne) plays and ex-Union colonel out for revenge.
</db:programlisting>
<db:para>In other words, we can render the <db:code>xref</db:code> as a cross reference or a link or a footnote, but we can only handle the deflection point as a reference to the specified resource. We can’t decide to link to a different resource or handle it by parenthetical clarification instead. To give ourselves the ability to link to different resources, we can turn to the management domain.</db:para>
</db:section>
<db:section>
<db:title>Deflection in the management domain</db:title>
<db:para>Linking to a source file rather than to an address gives us more latitude about how the link or cross reference is published, but we are still always linking to the same resource. If we are doing content reuse, this is a problem because you do not know if the same resource will be available everywhere you reuse our topic. We need to be able to link to different resources when our topic is used in different places.</db:para>
<db:para>To accommodate this, we can factor out the file name and replace it with an ID or a key. IDs and keys are a management domain structure that we looked at in the article on the reuse algorithm. They allow us to refer to resources indirectly. Using IDs lets us use an abstract identifier rather than a file name to identify a resource. Using keys lets us remap the resources we point to. This makes keys the more efficient way to address this problem. So instead of referring to a specific resource on John Wayne, we refer to the key <db:code>John_Wayne</db:code> using a <db:code>keyref</db:code> attribute:</db:para>
<db:programlisting language="DITA">
&lt;p&gt;In Rio Bravo, &lt;xref keyref="John_Wayne"&gt;The Duke&lt;/xref&gt; plays an ex-Union colonel out for revenge.&lt;/p&gt;
</db:programlisting>
<db:para>Somewhere in the DITA map for each publication, the key <db:code>John_Wayne</db:code> points to a topic. Publications link the <db:code>keyref</db:code> to the resource pointed to by that key in each of their DITA maps. This allows you to link to different resources in each publication.</db:para>
</db:section>
<db:section>
<db:title>The problem with IDs and Keys</db:title>
<db:para>However, there is still a problem with linking based on IDs and keys. Keys will let you vary which resource a <db:code>keyref</db:code> resolves to, but what happens when there is no resource to which that key can seasonably be assigned?</db:para>
<db:para>The <db:code>xref</db:code> demands that a reference to a resource be created, but there is no resource to link to. You are going to have a broken link, and fixing it is not easy. You can’t simply go in and remove the <db:code>xref</db:code> from the source for one publication, because that defeats the purpose of content reuse if you have to edit the content every time you reuse it. Removing the key reference would fix your broken link in one publication, but that would result in the link being removed from all the publications, even where the resource does exist and the link ought to be created.</db:para>
</db:section>
<db:section>
<db:title>Relationship tables</db:title>
<db:para>One approach to the link-only-when-resource-available problem is to use a relationship table. In a conventional linking approach, the source page contains an embedded link structure pointing to the target page. The source  knows it is pointing to the target, but the target does not know it is being pointed to.</db:para>
<db:mediaobject><db:imageobject><db:imagedata fileref="../graphics/simplelink.png"/></db:imageobject></db:mediaobject>
<db:para>The idea that the target resource does not know it is being pointed to is important because it means it does not have to do anything in order for other resources to point to it. The fact that only the source and not the target has to know about the link is fundamental to the rapid growth of the Web. If the target resource had to participate in the link process, it would be impossible for the Web to grow explosively and organically as it has.</db:para>
<db:para>A relationship table takes this one step further. When you create a link using a relationship table, you factor the link out of the source document and place it in a separate table. The relationship table says resource A links to resource B, but neither resource A nor resource B knows anything about it. (Think of it like being introduced to a stranger by a third party because you share a common interest. I collect china ducklings. You make china ducklings. We don’t know each other, but our mutual friend Dave introduces us. You and I are the source and destination resource; Dave is the relationship table.</db:para>
<db:mediaobject><db:imageobject><db:imagedata fileref="../graphics/linktable.png"/></db:imageobject></db:mediaobject>
<db:para>Notice that Dave has three choices about how he does the introduction. He can tell me about you as a seller of ducklings, or you about me as a buyer of ducklings, or he can introduce us both to each other. In the same way a relationship table can describe a link A to B, B to A, or both ways.</db:para>
<db:para>One the links are factored out of a piece of content, you can reuse it anywhere you like. If there is a suitable resource available to link to, you enter it in a relationship table for that build and have the presentation algorithm create the link at build time. If no suitable resource is available for a different publication, no entry is made in the relationship table for that publication, and the presentation algorithm does not create a link.</db:para>
</db:section>
<db:section>
<db:title>The problem with link tables</db:title>
<db:para>The problem with link tables is that while they address the problem of link management in reused content and allow you to link to different targets in different publications, they separate the link from the deflection point it supports. The link that marked the deflection point has been factored out of the content so there is no way to put it back inline. Links generate by relationship tables end up in a block, usually at the end of the page.</db:para>
<db:para>Since the end of a page is a deflection point in a hypertext system, there is a legitimate case for creating and managing page-level links. But if the page is well designed to fulfill a discrete purpose for the reader, the end of the page is actually the point at which the writer knows least about what the reader might want to read next. The relationship table approach does not support the full array of foreseeable reader deflection points which occur in the body of the page rather than its end.</db:para>
<db:para>The other problem with the relationship table approach is that it is time consuming. You have to rewrite the links for each content set, and because the deflection points are not recorded in the content source, you have to figure out the appropriate links each time. This goes against the spirit of recording something once and using it many times. A mechanism intended to help you reuse content ends up forcing you to redo the work of linking for each publication you create.</db:para>
</db:section>
<db:section>
<db:title>Conditional linking</db:title>
<db:para>Before we leave the management domain, it is worth mentioning a management domain approach that we could use to address our differential single sourcing problem and get the appropriate deflection strategy for online and paper publishing. We could use conditional structures to define both options in the source file. With a little specialization to support <db:code>media</db:code> as a conditional attribute, you could do this in DITA:</db:para>
<db:programlisting language="DITA">
&lt;p&gt;In Rio Bravo, &lt;ph media="online"&gt;&lt;xref keyref="John_Wayne"&gt;The Duke&lt;/xref&gt;&lt;/ph&gt;&lt;ph media="paper"&gt;The Duke (John Wayne)&lt;/ph&gt; plays an ex-Union colonel out for revenge.&lt;/p&gt;
</db:programlisting>
<db:para>In DITA, the <db:code>ph</db:code> element is used to delineate an arbitrary phrase in the content that you want to apply management domain attributes to. Here we define two different versions of the phrase “the Duke”, each with different forms of deflection support, and each with a corresponding media condition. The synthesis algorithm would then choose the appropriate version of the phrase for each publication based on the conditions set for the build.</db:para>
<db:para>There are some pretty obvious problems with this approach. It is twice the work for authors to create every link, and it doubles the maintenance cost of the content as well. It also flies in the face of the idea of creating formatting-independent content.</db:para>
<db:para>Unfortunately, in a general purpose document domain tagging language with management domain support, it is pretty much impossible to prevent writers from doing things like this in order to achieve the effects they want. And in practice writers do end up using conditional markup like this for all kinds of differential single sourcing and reuse problems that are not easy to solve in the document and management domains. In some cases this can lead to tangles of conditions that are hard to maintain and debug.</db:para>
<db:para>For an alternate approach to this problem, and the others we have discussed, we can to turn to the subject domain.</db:para>
</db:section>
<db:section>
<db:title>Deflection in the subject domain</db:title>
<db:para>There are a number of problems with the management domain approach to links.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Like all management domain structures, they are artificial. They don’t correspond to things in the author’s everyday world, which makes them harder to learn and use.</db:para>
</db:listitem>
<db:listitem>
<db:para>You can’t link to a key or an ID that does not exist. This means that as you are developing a set of content, the first pages you write have very few other pages to link to. Authors cannot enter links to content that has not been written yet.</db:para>
</db:listitem>
<db:listitem>
<db:para>In reuse scenarios, the use of IDs and keys does not solve the whole problem because it cannot guarantee that the resource that an ID or key refers to will be present in the final publication. You can use relationship tables to address this problem, but they create additional complexity for authors and have the disadvantage the you can’t use them to create inline links in your content.</db:para>
</db:listitem>
<db:listitem>
<db:para>Unless you resort to ugly conditional structures, you can’t use media-appropriate deflection mechanism for differential single sourcing.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para><db:olink targetptr="reuse">As we have seen before</db:olink>, we can often remove the need for management domain structures by moving content to the subject domain. The same it true with deflection points.</db:para>
<db:para>In the document domain we handled a deflection point by specifying a resource to link to, specifying both that the deflection mechanism would be a link and that the link target would be a particular page.</db:para>
<db:para>In the management domain we used keys to factor out the target resource but not the deflection mechanism (it was still an <db:code>xref</db:code>).</db:para>
<db:para>In the subject domain, we can factor out the target resource as well. We do this by marking up the subject of the deflection point:</db:para>
<db:programlisting language="xml">
&lt;p&gt;In &lt;movie&gt;Rio Bravo&lt;/movie&gt;, &lt;actor name="John Wayne"&gt;the Duke&lt;/actor&gt; plays an ex-Union colonel out for revenge.&lt;/p&gt;
</db:programlisting>
<db:para>This markup clarifies that the phrase “the Duke” refers to the actor named John Wayne. These are respectively the type of the subject (actor) and its value (John Wayne).</db:para>
<db:para>Given this markup, we can easily create the paper-style deflection mechanisms we have been looking for. We simply have the presentation algorithm take the value of the <db:code>name</db:code> attribute and output it between parentheses:</db:para>
<db:programlisting language="xml">
&lt;p&gt;In Rio Bravo, The Duke (John Wayne) plays an ex-Union colonel out for revenge.&lt;/p&gt;
</db:programlisting>
<db:para>The subject domain markup is not link markup. Unlike the document domain markup, it does not insist that a reference should be created nor does it specify any resource to link to. This markup is a subject annotation. It clarifies that the phrase “the Duke” refers to the actor named John Wayne (and not the Duke of Wellington or the Duke of Earl) and that the phrase “Rio Bravo” refers to the movie (and not to the city in Texas or the nature reserve in Belize[https://en.wikipedia.org/wiki/R%C3%ADo_Bravo_\(disambiguation\)]). That clarification is what allows us to produce the parenthetical explanation of the phrase in the example above. It also allows us to create a link if we want to. We’ll look at how in a moment. But first we should look at the implications of subject annotation more deeply.</db:para>
<db:para>Subject annotation markup says, “this is an important subject that we care about in this context”. How is this an appropriate way to handle a deflection point? Writers cannot know with certainty what the deflection points will be for individual reader. But they can anticipate that important related subjects are likely deflection points. This is what they are doing when they create links in the document domain and it is what they are doing in the subject domain. The difference is that in the document domain they handle then mention of an important subject by creating markup that says “create a link to resource X” and in the subject domain they handle it by creating markup that says “this is a mention of important related subject Y”. This leaves us with more options about how to handle the deflection point, and that is what we have been looking for.</db:para>
<db:para>Marking it up a phrase as a significant subject does not oblige the publishing algorithm to create a link. If you decide to have the publishing algorithm create a link on the Web and a cross reference on paper, nothing in the markup obliges you to use any particular formatting or target any particular resource. There is no question of cheating here if you decide to create one kind of deflection device or another, or not to create one at all. The markup is giving us the information to make our own decisions rather than forcing us to create a particular structure.</db:para>
<db:para>In all our previous examples, mentions of “Rio Bravo” were not marked up, even though it is clearly an important subject and a potential deflection point. This reflects the author’s decision not to create a link to support this deflection point. But what if we want to make a different choice later? By marking up “Rio Bravo” as a significant subject, we keep our options open. Now we tell the presentation algorithm to create links on the names of movies if we want to, or not if we don’t want to.</db:para>
<db:para>But there are additional reasons to annotate Rio Bravo as a significant subject, because that annotation can be used for other purposes as well. The subject annotation says that “Rio Bravo” is the title of a movie. In the media domain, the titles of movies are commonly printed in italics. We can use the subject domain <db:code>movie</db:code> tags to generate media domain italic styling. We could also use this subject annotation to generate document domain index markers so that we can automatically build an index all mentions of movies in a work.</db:para>
<db:para>Subject annotation thus serve multiple purposes, and correspondingly reduces the amount of markup that is required to support all these different publishing functions. This is a common feature of subject domain markup. None of it is directly tied to specific document domain or media domain structures which will be required to publish the content. Each piece of subject-domain markup may be used to generate multiple document domain and media domain structures. For example, we could generate the following document domain markup from from the subject domain markup above (the example is in DocBook):</db:para>
<db:programlisting language="DocBook">
&lt;para&gt;
    In 
    &lt;indexterm&gt;
       &lt;primary&gt;Rio Bravo&lt;/primary&gt;
       &lt;secondary&gt;Movies&lt;/secondary&gt;
    &lt;/indexterm&gt;
    &lt;citetitle pubwork="movie"&gt;Rio Bravo&lt;/citetitle&gt;,
    &lt;indexterm&gt;
        &lt;primary&gt;John Wayne&lt;/primary&gt;
        &lt;secondary&gt;Actors&lt;/secondary&gt;
    &lt;/indexterm&gt;
    &lt;ulink url="https://en.wikipedia.org/wiki/John_Wayne"&gt;The Duke&lt;/ulink&gt;
    plays an ex-Union colonel out for revenge.
&lt;/para&gt;        
</db:programlisting>
<db:para>This sample contains index markers, formatting of movie titles, and links on actor’s names, all generated based on the subject annotations in the source text. It should be clear how much less work it is for an author to create the subject domain version of this content than the DocBook version. Yet all the same publishing ability is maintained in both version.</db:para>
<db:para>Generating links from subject annotations has a number of other advantages:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>In a reuse scenario, you never have to worry about broken links or creating relationship tables. You generate whatever links are appropriate to whatever topics are available in the presentation algorithm.</db:para>
</db:listitem>
<db:listitem>
<db:para>In a differential single sourcing scenario, you are never tied to one deflection mechanism. You can generate any mechanism you like in whatever media you like.</db:para>
</db:listitem>
<db:listitem>
<db:para>You don’t have to worry about maintaining the links in your content because you source content does not contain any links. The subject annotations in your content are objective statements about your subject matter, so they don’t change. All the links in the published content are generated by the presentation algorithm, so no management is required.</db:para>
</db:listitem>
<db:listitem>
<db:para>There is no issue with wanting to link to content that has not been written yet. The subject annotation refers to the subject matter, not a resource. Links to content that is written later will appear once that content becomes available to link to.</db:para>
</db:listitem>
<db:listitem>
<db:para>It is much easier for authors to write because they do not have to find content to link to or manage complex link tables or keys. They just create subject annotations when the text mentions a significant subject. This requires no knowledge of the publishing or content management system. It does not even require knowledge of any other resources in the content set. It only requires knowledge of the subject matter, which the author already has.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section>
<db:title>Finding resources to link to</db:title>
<db:para>Of course, the question remains, what resources do we link to, since they are not specified in the text? If we choose to translate subject annotations into links, we need a way to find resource to link to.  We do this by looking up resources based on the subject information (type and value) captured by the subject annotation. For this we need content that is indexed using those types and values (or their semantic equivalents). So naturally this means that we need to index our content. If you have a page on John Wayne, you can index it like this:</db:para>
<db:programlisting language="sam">
topic: 
    title: Biography of John Wayne
    index:
        type: actor
        value: John Wayne
    body:
    
        John Wayne was an American actor known for westerns.
</db:programlisting>
<db:para>Now the linking algorithm looks like this:</db:para>
<db:programlisting language="pseudo">
match actor
    $target = find href of topic with index where type = actor and name = @name
    create xref
        attribute href = $target
        continue
</db:programlisting>
<db:para>However, content stored in the subject domain may already be indexed effectively enough by its inherent subject domain structures:</db:para>
<db:programlisting language="sam">
actor: 
    name: John Wayne
    bio: 
        John Wayne was an American actor known for westerns.
    filmography:
        film: Rio Bravo
        film: The Shootist
</db:programlisting>
<db:para>Here the topic type is actor, and the name field specifies the name of the actor in question. This is all the information we need to identify this topic as a source of information on the actor John Wayne.</db:para>
<db:para>Only very minor changes to the linking algorithm are required to use this:</db:para>
<db:programlisting language="pseudo">
match actor
    $target = find href of actor topic where name = @name
    create xref
        attribute href = $target
        continue
</db:programlisting>
<db:para>There is a lot more to how this mechanism works in practice, including what you do about imperfect matches and what happens when the query returns multiple resources. But that takes us into the specifics of individual systems and that is more detail than we need for present purposes.</db:para>
<db:para>Indexing of topics may also be done by a content management system, in which case the linking algorithm would query to CMS to find topics to link to.</db:para>
<db:para>A useful feature of this approach is that you can have the publishing algorithm fall back to creating a link to an external resource if and internal one is not available. If a search of the index of your own content fails, you can search indexes of external content. You can build such an index yourself, but some external sites may also provide indexes, APIs, or search facilities that you can use to locate appropriate pages to link to.</db:para>
</db:section>
<db:section>
<db:title>Deferred Deflection</db:title>
<db:para>Readers don’t always deflect the moment they reach a deflection point. In some cases, they choose to set the alternate material aside for later reading. This is particularly easy to do on the Web, where you can simply open pages in new browser tabs for reading later.</db:para>
<db:para>The idea of the deferred deflection can also occur in document design. A document design that gathers a set of links together at the end of a document, rather than including them inline, is recommending deferred deflection to the reader. It attempts to keep the reader following the writer’s default course to the end of the document before they go off to other things. The relationship table approach to link management that we mentioned earlier can only produce deferred links.</db:para>
<db:para>The merits of deferred links are debatable. Some argue that inline links are a distraction, that they actually encourage deflection. But the lack of links does not stop the reader from deflecting if they want to, and if they do deflect, the lack of a link means they may leave your content set and land on competitor’s content or content is that is of poor quality or that contradicts what you have been saying. The fact that the debate exists suggests that we may want to factor this design choice out of our source content so that we can choose between inline and deferred links later.</db:para>
<db:para>To leave open the option of deferring or not deferring links, we have to records links at the deflection points they belong to. We can choose to defer them at publishing time if we wish, but if we defer at writing time, we can’t put the links back inline at publishing time because we don’t know where they belong.</db:para>
<db:para>But for this strategy to work, we need to be able to tell the difference between links that can be deferred and those that cannot. An simple example of a link that cannot be deferred is one that says “For more information, click here.” Obviously this link has to remain on the words “click here”.</db:para>
<db:para>But there is a more subtle issue as well. For a link to be deferred on publishing, it must be possible to contextualize the link in the deferred location. In other words, when the deflection point occurs inline in a paragraph the reader should be able to infer where the link will lead from the paragraph and from the text the link is applied to. But lifting the same link text out of the paragraph and putting is somewhere else is not guaranteed to provide the same context.</db:para>
<db:para>For example, a link marked up like this is hard to defer algorithmically:</db:para>
<db:programlisting language="DITA">
&lt;p&gt;In Rio Bravo, &lt;xref href="https://en.wikipedia.org/wiki/John_Wayne"&gt;The Duke&lt;/xref&gt; plays an ex-Union colonel out for revenge.&lt;/p&gt;        
</db:programlisting>
<db:para>We could generate a list of links and insert it later in the document. It might look like this:</db:para>
<db:programlisting language="HTML">
&lt;p&gt;For more information, see:&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/John_Wayne"&gt;The Duke&lt;/a&gt;&lt;/li&gt;
    ...
&lt;/ul&gt;
</db:programlisting>
<db:para>But will it be clear out of the context of the original text what the words “the Duke” refer to? (Than answer here is maybe, but it is not hard to image cases where it would be a definite no.)</db:para>
<db:para>On the other hand, if the deflection point is marked up in the subject domain like this:</db:para>
<db:programlisting language="xml">
&lt;p&gt;In &lt;movie&gt;Rio Bravo&lt;/movie&gt;, &lt;actor name="John Wayne"&gt;The Duke&lt;/actor&gt; plays an ex-Union colonel out for revenge.&lt;/p&gt;
</db:programlisting>
<db:para>Then, given that we know what the subject of the deflection point is, we could use it to create a list of links that are categorized by type and use the real names of actors even when the original text use a nickname:</db:para>
<db:programlisting language="html">
&lt;p&gt;For more information, see:&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;Actors:       
        &lt;ul&gt;
            &lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/John_Wayne"&gt;John Wayne&lt;/a&gt;&lt;/li&gt;
            ...
        &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;Movies:       
        &lt;ul&gt;
            &lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Rio_Bravo_(film)"&gt;Rio Bravo&lt;/a&gt;&lt;/li&gt;
            ...
        &lt;/ul&gt;
    &lt;/li&gt;
&lt;/ul&gt;
</db:programlisting>
<db:para>In short, algorithmically deferring document domain links is always tricky, but we can comfortably defer linking of subject annotations.</db:para>
</db:section>
<db:section>
<db:title>Different domain, different algorithm</db:title>
<db:para>What the linking algorithm illustrates perhaps better than any other is that the movement from one domain to another changes the algorithms in fundamental ways. While the algorithm has the same end in each domain, the way it achieves that end can be significantly different.</db:para>
<db:para>One of the points I have tried to make about structured writing algorithms is that they always start with the content structures. How you design the content structures -- the way the author records the content -- determines everything you can do with the content. You create content structures to support algorithms. You create algorithms to improve content quality or streamline content management and publishing.</db:para>
<db:para>In the document domain, the data structures tend to have a one to one correspondence with their algorithms. As system designers determine they need a particular algorithm, they create structures to support that algorithm. Thus document domain languages that require support for linking, reuse, indexing, and single sourcing have data structures for linking, for reuse, for indexing, and for single sourcing. (Some of these may be management domain structures, of course.)</db:para>
<db:para>In the subject domain, though, the data structures reflect the subject matter. If you go looking for a one to one correspondence between a structure and the algorithm it supports, you won’t find it. Thus you will not find link markup or reuse markup or index markup or single sourcing markup in the subject domain. You will find markup that clarifies and delineates the subject matter of the content it contains. Any algorithm we want to apply has to interpret that subject domain annotation and use it as the basis for creating whatever kind of document or media domain structure you want for publishing.</db:para>
<db:para>System designers do still have to think about what algorithms they want to apply, but that is to make sure that the aspects of the subject matter needed to drive the algorithms are captured. Since every subject structure can potentially drive many publishing algorithms, however, you will often find your subject domain content already supports any new algorithms you want to apply. This helps future proof your content.</db:para>
<db:para>Moving from the document domain to the subject domain is not a matter of asking what the subject domain equivalent of a document domain structure is, therefore, but a matter of asking what information in the subject domain drives the creation of document domain structures. Subject domain content can look very different from its document domain counterpart and will often be starkly simpler and easier to understand.</db:para>
</db:section>
</db:chapter>
