<?xml version="1.0"?>
<db:chapter xmlns:db="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">
<db:title>Quality algorithms</db:title>
<db:section>
<db:title>Rhetorical structure</db:title>
<db:para>The rhetorical structure of a piece of content is how it tells its story. For many types of stories, the optimal rhetorical structure is quite consistent and often well known. In other cases, the best rhetorical structure can be determined both by a careful consideration of what needs to be said and by experience and testing with readers. Content quality is greatly enhanced when the rhetorical structure is well defined and followed consistently. Also, a well defined rhetorical structured provide an effective baseline against which to compare and measure proposed improvements. Using an explicit predefined rhetorical structure helps enhance and maintain content quality.</db:para>
<db:para>In the <annotation type="link" specifically="http://techwhirl.com/structured-writing-writing-in-the-subject-domain/">subject domain article</annotation> we looked at how structured writing in the subject domain can capture the rhetorical structure of a recipe in various ways to serve various business purposes.</db:para>
</db:section>
<db:section>
<db:title>Completeness</db:title>
<db:para>Completeness is an obvious aspect of content quality. Unfortunately, lack of completeness is often hard for writers and reviewers to spot. The omission of information they already know is hard to see unless there is an obvious hole in a predefined and explicit document structure. Defining structures that highlight information requirements can significantly improve completeness.</db:para>
<db:para>In the <db:olink targetptr="chapter.subject-domain">subject domain chapter</db:olink> we saw how calling out the preparation time and number of servings for a recipe help ensure that the author always remembers to include that information, whether or not we decide to present it in fields or as part of a paragraph.</db:para>
<db:para>But this is not the only way that subject domain structured writing helps ensure completeness. By specifically calling out the subjects that are mentioned in every topic you write, you build a list of subjects that are important to your business. You can use this list to make sure that all the subjects you need to cover are actually covered.</db:para>
<db:para>For example, structured writing allows you to annotate you text to call out the types of certain phrases such as functions names, feature names, or stock symbols.</db:para>
<db:programlisting language="sam">
</db:programlisting>
<db:para>When installing widgets, use a left-handed widget wrench to tighten them to the recommended torque for your device. <db:code/>`</db:para>
<db:para>This sample annotates the phrase “left-handed widget wrench” and records that these words describe a tool. If all mentions of tools are annotated this way, you can then compile a list of all the tools you mention in all your topics and make sure that you have suitable documentation for each of them. We will look at annotations, and the ways you can use them, in later articles.</db:para>
<db:para>And yes, this is the same markup that I have been using in earlier articles, and I will explain it eventually.</db:para>
</db:section>
<db:section>
<db:title>Consistency</db:title>
<db:para>Similarly to completeness, consistency can make a big difference to readers, but lack of consistency is hard to spot if the structure of the content is not explicit in all the ways we want it to be consistent. Consistency can apply to many aspects of the content, such as structure and vocabulary.</db:para>
<db:para>We have <annotation type="link" specifically="http://techwhirl.com/what-is-structured-writing/">described structured writing as applying constraints to writing</annotation>. Being consistent simply means abiding by constraints. As we have seen, this can take the form of either enforcing the constraint through required structure or, preferably, factoring out the constraint so that it is handled by algorithms rather than people. We have looked at how you can factor out constraints in both the <annotation type="link" specifically="http://techwhirl.com/structured-writing-in-the-document-domain/">document domain</annotation> and the subject domain.</db:para>
<db:para>If you annotate the important things in your content set, such as tools in the example above, you can use the annotations to check for consistency of names. Suppose a writer accidentally writes “spanner” rather than “wrench” in the name of the tool:</db:para>
<db:programlisting language="sam">
</db:programlisting>
<db:para>When installing widgets, use a left-handed widget spanner to tighten them to the recommended torque for your device. <db:code/>`</db:para>
<db:para>Since you can now generate a list of tools mentioned in the text, you can check each mention against a list of approved tool names. This can reveal both incorrect names (consistency) and tools that may be missing from the official list (completeness).</db:para>
<db:para>The same would apply to values in fields, such as the wine match field in the recipe example. With the wine match in a separate field you can compile a list of wines mentioned or check each mention against an approved list.</db:para>
</db:section>
<db:section>
<db:title>Accuracy</db:title>
<db:para>Accuracy problems too are often hard to spot. Typos, using old names for things, or giving deprecated examples are all hard for writers and reviewers to see. But there are structured writing techniques than can catch many of these kinds of problems.</db:para>
<db:para>For example, if you were documenting an API, you could annotate each mention of a function.</db:para>
<db:programlisting language="sam">
</db:programlisting>
<db:para>Always check the return value of the <annotation type="function">rotateWidget()</annotation> to ensure the correct orientation was achieved. <db:code/>`</db:para>
<db:para>API function names can be quite tricky to remember sometimes and small typos and be difficult to spot. But with this annotation, you can validate all mentions of functions against the API reference or the code base. This technique not only catches misspellings. I have seen it catch the use of deprecated functions in examples, for instance.</db:para>
</db:section>
<db:section>
<db:title>Timeliness</db:title>
<db:para>Information tends to change quickly these days, and readers no longer have any patience with outdated content. But there are many difficulties in ensuring that content is always timely. How do you detect when content is out of date? How do you push updated content quickly? How do make sure updates in one place don’t break other content? Structured writing provides ways to address all of these questions.</db:para>
<db:para>By improving validate and automating publishing, structured writing can allow you to release content much more quickly. By changing the way content is organized and linked, it can allow you to add and remove individual pages from a content set without fear of breaking things. We will look at these techniques in more detail in later articles.</db:para>
</db:section>
<db:section>
<db:title>Media appropriateness</db:title>
<db:para>If your content is going to be delivered to multiple media, you want to make sure it works best in each media. But this is not simple. Not all media types require content in the same document structures. Conventional books and manuals have a hierarchical or linear rhetorical structure, which generally carries over into help systems as well. The Web is a hypertext medium with a hypertext structure that is non-linear and non-hierarchical. Adapting content to each media may require structures in the subject domain that do not assume a particular document structure.</db:para>
<db:section>Generated content</db:section>
</db:section>
</db:chapter>
