<?xml version="1.0"?>
<db:chapter xmlns:db="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:strings="http://exslt.org/strings" version="5.0">
<db:title>Auditing</db:title>

<db:para>If the conformance algorithm is about making sure that an individual item meets its constraints, the audit algorithm is about making sure that the content set as a whole meets its constraints.<db:footnote>
<db:para>Content strategists often use the term “content audit” to mean a current state analysis performed at the beginning of a website redevelopment project. A content strategy content audit is about cataloging, and possibly categorizing, the content you already have. I am using the word audit to refer to an ongoing and or recurring activity in which a you ensure that a content set is meeting or continuing to meet its goals.</db:para>
</db:footnote></db:para>

<db:para>As such, auditing is fundamentally a content management function. It is about making sure that:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>The definition of the content set is correct (we know what types of content it should contain, and which instances of each type)</db:para>
</db:listitem>
<db:listitem>
<db:para>The content set is complete (it contains all the items of each type that it should)</db:para>
</db:listitem>
<db:listitem>
<db:para>The content set is uncontaminated (it does not contain any items or types it should not)</db:para>
</db:listitem>
<db:listitem>
<db:para>The content set is integrated (it contains all of the relationships between items that it should)</db:para>
</db:listitem>
<db:listitem>
<db:para>Each item in the content set conforms to its constraints</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Auditing a large content set is difficult and many CMS solutions are deficient in audit capabilities. The main reason for this is that with the way most content is recorded and stored (media domain or undisciplined document domain formats), it is very difficult to mechanically assess what content you have and what state it is in. It is hard to know if you have all the pieces you should have if you can’t tell exactly what the pieces you have are.</db:para>
<db:para>Auditing is a content management function and this book is about structured writing, not content management. However, one of the biggest, and least appreciated, benefits of structured writing is that it makes content more auditable. When content management systems fails or become unmanageable, (which they do with disappointing frequency), the root cause is often either lack of attention to regular audits, or the lack of ability to auditing effectively. Without the ability to audit effectively, content sets often end up incomplete, corrupt, and poorly integrated, which reduced quality and increases costs at every stage of the process. And a viscous cycle can develop in which writers, frustrated with the difficulties of the system, create workarounds that further corrupt the information set.  Whatever expenses you may incur to implement a more structured structured writing approach could well be offset by the savings associated with more effective auditing of the content set alone.</db:para>
<db:section>
<db:title>Correctness of the definition of the content set</db:title>
<db:para>Content strategists will spend a great deal of time and effort developing a content plan (usually this is for a website, but the same principle applies to any content set). How they do this is beyond the scope of this book, but the result should be a definition of the content set: which types of information it is supposed to contain and what instances of those types. (This definition is based, of course on the goals it is designed to achieve, which is the business of the content strategist to define.)</db:para>
<db:para>The definition of a content set is not necessarily static. It is not necessarily a fixed list of topic types or of specific topics to be developed. For one thing, the subject matter may change during the course of content development, which would change the content pieces needed, and perhaps require new content types or modifications to existing types. Second, the exact set of pieces or types may not be knowable at the outset. Content development explores a complex set of relationships between subject matter and the needs and background of the reader that cannot be fully known without traveling the ground in detail. An agile approach to content planning is essential in most content projects. But remember that agile is a disciplined approach to evolving a plan. It does not mean hacking away regardless; it means constantly refining your model in a disciplined and deliberate way as learn more about you subject matter, your readers, and your business needs.</db:para>
<db:para>But is is hard to be disciplined and deliberate in evolving the big picture model of the content set if you are not disciplined and deliberate in how you create the pieces. It is hard to tell if you have the right types of information if you do not closely define those types. If the author if free to write what they will and then tag what they have written with CMS type metadata after the fact, you don’t really know what type of content you have, and so you don’t have any way to tell if the type definition is correct. The content might work despite not being the type specified, but unless the type is codified and auditable, that success won’t carry over to other content. And if the content fails, you won’t know whether it failed because it was true to a badly defined type or false to a well defined one.</db:para>
<db:para>Having strong well defined topic types makes it easier to audit your topic types to make sure they are doing the job they were designed to do. Similarly, having strong well defined topic types means that you can have greater assurance that each topic is doing the job it is supposed to do, which helps you make sure you have covered all the subjects you should have.</db:para>
<db:para>But structured writing can do more than this to help you audit the definition of the content set. If create content in the subject domain, including extensively annotating the subjects that you mention in the text, you can use algorithms to extract a list of the types and subjects that your content is actually talking about. In your initial top-down plan, you many not have thought about the need for content on a certain subject or to support a certain activity, but if that subject or that activity start showing up in the body of your content, that is a strong indication that those subjects and activities are related to the purpose of your content set and should probably be included in the definition of the content set.</db:para>
<db:para>Subject domain markup is how you know what your content is actually talking about, what every author is discovering or thinks needs saying. Without this information it is very difficult to audit that the content set is meeting its coverage goals.<db:footnote>
<db:para>With marketing content it is more common to focus on auditing whether content is meeting its behavioral goals. Are readers taking the actions you want, and does a content change produce more of the desired action. All content aims at changing reader behavior, but not all behavior changes are easy to measure. Unless the behavior in question is an interaction with the web page that contains the content, behavioral changes are both hard to observe and hard to attribute. And even where behavior is measurable, you want to be able to reproduce the qualities of content that produce the behavior you want, and that means auditing the type and coverage of your content.</db:para>
</db:footnote></db:para>

<db:para>This actually attacks two audit problems. If writers are writing about things outside you current coverage definition, either your coverage definition needs updating, or writers are polluting the content set with irrelevant material.</db:para>
</db:section>
<db:section>
<db:title>Ensuring the content set remains uncontaminated</db:title>
<db:para>Subject domain content structures and annotations can help you prevent contamination of the content set by irrelevant material. But more important than catching writers in the act is catching the flaws in content types that allow for contamination to creep in.</db:para>
<db:para>A major form of contamination in any content set is redundant content. We have to be careful in how we define redundancy, because it is not simply a matter of only addressing a subject once, it is a matter of addressing an audience need only once, and that may require several topics on the same subject addressed to different readers. But it is all too easy for duplicate content to sneak into a content set. Some of it comes in because the same functionality is repeated in many products or in content delivered to different media. Some comes in through author’s simply not knowing that suitable content already exists. Content reuse is a major motivator for structured writing for exactly this reason. But the content reuse algorithm only addresses the problem of how to reuse content. It provides a method to reuse content you are aware of. It does not prevent you from duplicating content because you did not look for or did not find existing reusable content.</db:para>
<db:para>There are natural language processing algorithms that will attempt to identify redundant content in a content set, but such algorithms focus on similar texts. But non-redundant content may have similar text, which redundant pieces of content may be expressed very differently. Even when redundancies are found, they may be very difficult to consolidate if they don’t have similar boundaries within their respective documents (the composability problem). Strongly typed content, meaning content that conforms to a model that breaks down and enforces the various components that make up a document, makes it possible to detect duplication in a much more formal and precise way.</db:para>
<db:para>A person who consults a repository to see if there is a piece of content they can use relies on the ability to query the repository in a sensible way for the type of content they are looking for. They also rely on their ability to recognize the content when they see it, and on it actually being strongly conformant so that they can use it with confidence. Strong topic typing helps with all of these things. The easier it is to correctly identify reusable content and use it, the less corruption of the repository will occur.</db:para>
</db:section>
<db:section>
<db:title>Ensuring that the content set is well integrated</db:title>
<db:para>A content set is never a collection of wholly independent pieces. The items in the set have relationships to each other that matter to the reader. Whether you express those relationships on output through links or cross references, or whether you relay entirely on tables on contents and indexes, it is still important to understand and manage the relationships between items.</db:para>
<db:para>Relationships between items may also be things that matter for management but not to readers. If your have documentation for multiple releases of a product, the relationship between the documentation for for feature X in version 3 and that for feature X in version 2 matters to you. It may matter because the feature has not changed and you can reuse the item. It may matter because an error was found in version 2 and you want to fix it in version 3 as well. (And if you put this content online, the relationship may matter for the reader as well, if they search for feature X and get the result for version 2 when they are using version 3.</db:para>
<db:para>You can describe the relationship between items externally. Items are related whenever they share any part of a metadata record in common. But the same problem exists here as it always does with external metadata -- the content may not conform to the metadata, and without structured writing in the content itself, it is hard to audit the conformance of the content to its metadata. But the bigger problem is that in may cases the important relationship are between parts of one item and the wholes of others. Are function names appearing in the programming topics all listed in the API reference? Are utensils mentions in a recipe all covered in the appendix of kitchen tools?</db:para>
<db:para>Structured writing, particularly in the subject domain, helps you discover and manage these relationships by making clear the subject on which these relationships are based.</db:para>
</db:section>
<db:section>
<db:title>Making content auditable</db:title>
<db:para>I have talked all through this chapter about how using strong topic types makes content more audible. What is a strong topic type? Fundamentally, a strong topic type is one that makes explicit those feature of the content that you need to ensure its conformance and auditability. It is possible for content to conform to all of its rhetorical constraints without the use of structured writing techniques. (Other constraints exist for processing purposes, of course, and do require the use of explicit data structures for that purpose.) But strong topics types provide explicit guidance to the author and facilitate the use of conformance algorithms. They are therefore created to meet you conformance goals. Similarly with auditing, you specify the content structures you need in order to meet your auditing goals.</db:para>
<db:para>In many cases, auditing is less of a pass/fail exercise than conformance. Auditing often requires human review. Human review of a large content set is difficult, though, due to the sheer amount of content. An audit algorithm will often work simply by creating different views of the content set that humans can review more easily.</db:para>
<db:para>Suppose, for instance, that an organization is using subject-domain annotations to drive linking. Every topic in the collection is supposed to be indexed to state the type and names of the subjects it covers. Every mention of a significant subject is supposed be annotated with its type. The linking algorithm can certainly use these annotations and index entries to link the content without any need for authors to create or manage links in the source text. But that does not guarantee that all the right links get made. There could be errors in indexing or annotation that are impossible to detect when conformance testing individual topics.</db:para>
<db:para>We can use those same index entries and annotations to create audit reports for several purposes. These are some of the things we can do:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>We can create a sorted list of all the phrases that have been annotated and see if they are being annotated consistently. (Everyone is using the same annotation type, for instance.) This will tell us a lot about the types we are using, how well they are understood, and what instances of each type we should be covered.</db:para>
</db:listitem>
<db:listitem>
<db:para>We can create a list of all the phrases that have been indexed and check it against our content plan (perhaps against a taxonomy if we have one). This will tell us a lot about if our coverage is complete, if writers are getting off track, or if our content plan or our taxonomy is off base with reality.</db:para>
</db:listitem>
<db:listitem>
<db:para>We can create a sorted list of all the index terms and check it against the list of annotated phrases to find phrases are that being indexed but not annotated or annotated but not indexed. This can tell us is there are subject we are not covering, if writers are discussing subjects they should not be, of if some topics are not being indexed or annotated properly.</db:para>
</db:listitem>
<db:listitem>
<db:para>During the content development phase, the list of things that are annotated but not indexed will inevitable grow, as subjects are being referred to before the content that describes them is written. The trend line of the growth of new subjects being annotated vs subjects being indexed will allow you to track how close a content set is to completion, even in cases were defining the boundaries in a advance is difficult.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
</db:chapter>
