<?xml version="1.0"?>
<db:chapter xmlns:db="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:strings="http://exslt.org/strings" version="5.0" xml:id="chapter.mechanical-structure">
<db:title>Mechanical Structure</db:title>

<db:para>The mechanical structure of structured writing is the structure it presents to machines, which is to say, to algorithms. To create mechanical structures to contain writing, we need a type of structure suitable to what we are capturing and what information we want to capture about it. Traditional computing structures like relational database tables do not work well for this because they are too regular to fit the shape of content. Creating structures that are regular enough for algorithms to deal with yet irregular enough to fit written language is an interesting problem to which more than one solution has been proposed.</db:para>
<db:section>
<db:title>Flags vs Boxes</db:title>
<db:para>A document is fundamentally a linear and ordered data structure. One thing comes after another. The rhetorical structure of a document is expressed using literary devices (possibly highlighted by formatting changes) within the flow of the text. To impose a topic type to formally constrain the topic pattern that is the rhetorical structure, we need to mechanically delineate the parts of the rhetorical structure.</db:para>
<db:para>Two commons ways to do this are flags and boxes.</db:para>
<db:para>The boxes approach means creating boxes for words and giving names to those boxes. It may also involve putting a label on the box with additional information on it. The name and the label on the box tells us something about the words in the box.</db:para>
<!--  Graphic -->
<db:para>To create the boxes, we insert markup into the text to define the beginning and end of the boxes. This is how it works in XML:</db:para>
<db:programlisting language="xml">
&lt;box label_1="foo" lable_2="bar"&gt;text&lt;/box&gt;
</db:programlisting>
<db:para>But not all markup systems use the boxes model. Many older systems, particularly those intended for typesetting, used the flags model. To understand the flags model, consider how road signs delineate zones on a road. As you approach a town, you may see a sign saying that you are entering the town. A little further on, you see a sign for a reduced speed limit. On the far side of the town, you pass a sign saying you are leaving the town limits. Here, however, there are still houses and businesses along the road, so the speed limit does not rise until you are past the built up area. Thus the box defined by the town limits and the box defined by the lower speed zone overlap each other. It is not a case of boxes within boxes, but of independent zones defined by begin and end signs.</db:para>
<db:para>An example of this approach in the content world is the word processor WordPerfect which takes what it calls a “streaming approach” to document structure in which features are turned on and remain on until they are turned off. Thus in Word Perfect, your could do this, with bold starting and then italic starting, the bold stopping and finally italic stopping:</db:para>
<db:programlisting>
This text is [B&gt;bold, [I&gt;this is bold and 
italic,&lt;B] and this is just italic&lt;I].
</db:programlisting>
<db:para>This would print as:</db:para>
<db:blockquote>
<db:para>This text is <db:emphasis role="bold">bold,</db:emphasis> <db:emphasis role="bold"><db:emphasis>this is bold and italic,</db:emphasis></db:emphasis> <db:emphasis>and this is just italic</db:emphasis>.</db:para>
</db:blockquote>
<db:para>This overlapping of structures is illegal in XML, so in HTML, for instance, you can’t do this:</db:para>
<db:programlisting>
&lt;p&gt;This text is &lt;b&gt;bold, &lt;i&gt;this is bold and 
italic,&lt;/b&gt; and this is just italic&lt;/i&gt;.&lt;/p&gt;
</db:programlisting>
<db:para>You have to do this, keeping everything nested with no overlapping structures:</db:para>
<db:programlisting>
&lt;p&gt;This text is &lt;b&gt;bold,&lt;/b&gt; &lt;i&gt;&lt;b&gt;this is bold 
and italic,&lt;/b&gt;&lt;/i&gt; &lt;i&gt;and this is just italic&lt;/i&gt;.&lt;/p&gt;
</db:programlisting>
<db:para>There is more to this question than trivial examples like this. In the academic study of text markup, where markup is used not for the preparation of documents but to mark them up for academic study, there is an debate about whether the hierarchical structure of XML-based languages actually reflects the real structure of the text.</db:para>
<db:para>From a structured writing perspective, we don’t have to worry so much about whether the markup is objectively true to the text. Our concern is to create structures that improve the quality of content and enable the structured writing algorithms we want to use.</db:para>
<db:para>The use of a flags model like that of WordPerfect is rare today. A hierarchical model is almost universally preferred. Whether they truly represent the structure of text or not, hierarchical models are easier to define and process and provide an easier way to express constraints. If your really want to express overlapping structures in a hierarchical language like XML, it is possible to do so by using empty element tags as flags. Thus you can define a language that lets you do this:</db:para>
<db:programlisting>
&lt;p&gt;This text is &lt;b-start/&gt;bold, &lt;i-start/&gt;this is bold 
and italic,&lt;b-end/&gt; and this is just italic&lt;i-end/&gt;.&lt;/p&gt;
</db:programlisting>
<db:para>However, you would be very hard pressed to find anyone who would tell you this was a good idea. The boxes model works best for most of what you want to do with structured writing and to introduce a flags model into the mix just to express an odd structure like this introduces far more complexity than it is worth.</db:para>
<db:para>If you really need to model the highly unlikely bit of formatting in the example above, you should do it as illustrated above:</db:para>
<db:programlisting>
&lt;p&gt;This text is &lt;b&gt;bold,&lt;/b&gt; &lt;i&gt;&lt;b&gt;this is bold and 
italic,&lt;/b&gt;&lt;/i&gt; &lt;i&gt;and this is just italic&lt;/i&gt;.&lt;/p&gt;
</db:programlisting>
<db:para>In short, structured writing today uses the boxes model, and so should you.</db:para>
</db:section>
<db:section>
<db:title>Flat vs. nested structures</db:title>
<db:para>But even when we choose the boxes model of markup design, we are still left with some fundamental choices about structure. The first is flat vs. nested structure.</db:para>
<db:para>We noted in <db:xref linkend="chapter.document-domain"/> that in HTML, you have six levels of heading (<db:code>h1</db:code> through <db:code>h6</db:code>) whereas in DocBook you have only <db:code>title</db:code>. In DocBook, you can divide a document up into sections and nest sections inside sections. You can then print the titles of sections inside sections in a smaller font that the titles of first level sections. You get to have differences in heading size without having six different heading tags.</db:para>
<db:para>But the DocBook model assumes that the real structure of a document is  a hierarchy of nested sections and that the size of titles announces the steps up and down that hierarchical tree. HTML makes no such assumption. It will let you put a <db:code>&lt;h4&gt;</db:code> immediately after an <db:code>&lt;h1&gt;</db:code> if you want to. It treats documents as essentially flat structures punctuated by headings of various sizes as and where appropriate.</db:para>
<db:para>Which model of a document is correct? You can think of a document as being organized hierarchically, with major ideas expressed in sections, sub-ideas supporting the major ideas in subsections, etc. There are doubtless documents that fit that model. But you can also think of documents as being more like a journey in which headings function more like road signs. A city gets a big sign, a hamlet a small sign, and a town a medium sign. But the town is not inside the city, not the hamlet inside the town, and there is no guarantee that on leaving the city you will come to the town before you come to a hamlet.</db:para>
<db:para>Studies by Peter Flynn indicate that most authors think of the documents they are writing much more in terms of a punctuated linear model than a hierarchical model.</db:para>
<db:blockquote>
<db:attribution>Flynn2009</db:attribution><db:para>The classical theory, derived from computer science and graph theory, is that the document is a hierarchical tree (actually inverted: a root-system) and that all necessary actions can be seen in terms of navigation around the tree, and of insertion into and withdrawal from the the nodes which form the branches and leaves.</db:para>
<db:para>The conventional writer, however — and we expressly exclude the markup expert, as well as the experienced technical authors who responded to the survey — is by repute probably only marginally aware of this tree; but we have been unable to measure this at present. In this view, the document is seen as a continuous linear narrative, broken into successive divisions along semantic lines, and interspersed with explanatory material in the form of figures, tables, lists, and their derivatives.</db:para>
</db:blockquote>
<db:para>But if the constraints that we want to express in structured writing demand hierarchy, while functional lucidity demands more of a punctuated linear model, how do we reconcile these two opposing requirements in markup language design?</db:para>
<db:para>This is of greatest concern in the design of document domain languages. The structure of media domain languages is largely dictated by the shape and relationship of the media-domain object they are modeling. In the subject domain, we have abstracted content out of strict document order. Hierarchy in the subject domain tend to match the hierarchy of relationship in the subject matter itself.<db:footnote>
<db:para>Though this is not universal. Addresses, for instance, which are based on hierarchal locations, are modeled as flat ordered lists. The order reflect the hierarchy, but the nesting of city inside country and of street within city is not reflected in the structure of an address record.</db:para>
</db:footnote> In the document domain, however, it is a real concern. The document domain consists of abstractions of document structures and the nature of their relationship to the structure of thought in the text is not obvious.</db:para>

<db:para>The options available are:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Create a really flat document domain language. Examples are HTML and Markdown. The problem here is that they impose few constraints, and the lack of context-setting hierarchy makes it hard to model different types of document structures without creating hundred of tags -- which would negate any functional lucidity that you gained by keeping the language flat.</db:para>
</db:listitem>
<db:listitem>
<db:para>Create a hierarchical language that has a really permissive structure, so that you can put boxes inside boxes in lots of different ways. An example of this is DocBook. The problem here is that the possible permutations make writing algorithms difficult and you often need to impose additional constraints on your authors that are not expressed or enforced by the markup itself. This again diminishes functional lucidity, and compromises conformance. (An interesting property of this approach is that the flexibility of the language means that authors can choose to create documents that are deeply nested or very flat. This is not really a virtue, however, as it is not clear how this choice contributes to improved content quality.)</db:para>
</db:listitem>
<db:listitem>
<db:para>Define a smaller, stricter document domain language that is appropriate to the particular types of documents you want to write, possibly as restricted subset of an existing language like DocBook. The main difficulty with this approach is that it involves you in having to do your own language design, which many organization try to avoid. Once you have decided to go this route, going to the subject domain instead may be no more expensive while providing better functional lucidity and conformance.</db:para>
</db:listitem>
<db:listitem>
<db:para>Define a strict hierarchical document domain language that expresses the constraints you need and make people learn it. This works if you are able to recoup the expense of training your authors. It does not work if you want to include occasional authors in your pool of contributors.</db:para>
</db:listitem>
<db:listitem>
<db:para>Move content creation to the subject domain.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>In the document domain, however, you have to make a choice between enforcing a hierarchical model of a document or allowing a more linear one. You will almost certainly do this in the context of hierarchical syntax. You probably don’t want to go the WordPerfect route of separate on and off commands. But you do need to decide if you are going to allow arbitrary heading levels. Or, to put it another way, to model a document as a hierarchy of sections with each section having a title, or a single flow of text randomly interspersed with headings, or something in between.</db:para>
<db:para>The something-in-between option can seem appealing but you can end up with something really unconstrained, meaning that it is difficult to write reliable algorithms to process it. Here is the kind of issues you can run into:</db:para>
<db:para>Is a list part of the paragraph in which it occurs? Some markup languages, such as Markdown and SAM, take the view that lists are separate blocks that come after a preceding paragraph. But DITA, DocBook, and HTML will all let you place a list either inside or outside a paragraph:</db:para>
<db:programlisting>
&lt;p&gt; The primary colors are:
    &lt;ul&gt;
        &lt;li&gt;Red&lt;/li&gt;
        &lt;li&gt;Blue&lt;/li&gt;
        &lt;li&gt;Yellow&lt;/li&gt;
    &lt;/ul&gt;
&lt;/p&gt;

&lt;p&gt; Their complementary colors are:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Green&lt;/li&gt;
    &lt;li&gt;Orange&lt;/li&gt;
    &lt;li&gt;Purple&lt;/li&gt;
&lt;/ul&gt;
</db:programlisting>
<db:para>The interesting question here is whether these two structures should be formatted differently for output. Should the list that in inside the paragraph be indented, which the one that comes afterwards be printed flush left?</db:para>
<db:para>The default for HTML, at least in the browsers I tried it on (Edge, Internet Explorer, and Chrome) is that both are indented by the same amount, but of course you could change this with CSS and DocBook and DITA processors can do what they like.</db:para>
<db:para>But would it be a good idea to make a distinction between the two? Only if authors clearly understood the difference between the two and clearly know when they were choosing one or the other. (If they are writing in a visual editing view of an XML editor, then they almost certainly won’t know the difference.)</db:para>
<db:para>If you are designing your own markup language, do you want to allow both these forms? Probably not. The more permutations of structure your markup language allows, the more work it will be to write the algorithms to process it. Some allowance may be made for ease of authoring, if you wish, but it may be better to wait for authors to complain about a restriction like this than to build in all the possible variations in advance. (This is also a problem that is more likely to occur in an abstract language like XML than in a concrete language like Markdown or SAM, where the choice is baked into the syntax and the author does not have a choice to make.)</db:para>
</db:section>

<db:section>
<db:title>The role of syntax</db:title>
<db:para>The syntax of your markup language also plays a role in striking the right balance between hierarchy and functional lucidity. Fully explicit markup syntax like that of XML forces every element of the hierarchical structure of the document to the fore in the syntax. The syntax has explicit hierarchical constraints of its own (what XML calls the well-formedness constraint). This pushes the hierarchical structure in the author’s face, which detract from functional lucidity.</db:para>
<db:para>Languages like Markdown with implicit syntax are just as hierarchical as their equivalents with fully explicit syntax but they feel flatter. Thus where HTML make you write:</db:para>
<db:programlisting language="html">
&lt;html&gt;
    &lt;ol&gt;
        &lt;li&gt;
            &lt;p&gt;The first item.&lt;/p&gt;
            &lt;p&gt;A second paragraph in the first item.&lt;/p&gt;
        &lt;/li&gt;
        &lt;li&gt;
            &lt;p&gt;The second item.&lt;/p&gt;
    &lt;ol&gt;
&lt;/html&gt;
</db:programlisting>
<db:para>In MarkDown you write:</db:para>
<db:programlisting language="markdown">
* The first item.
  
  A second paragraph in the first item.
  
* The second item.
</db:programlisting>
<db:para>The latter has just as much structural hierarchy as the first, but feels much flatter. It uses indentation to indicate that the second paragraph belongs to the first list item, but that feels natural and obvious rather than contrived of imposed.</db:para>
<db:para>One of my motivations for creating SAM, which is designed for structured writing, and therefore, unavoidably, for hierarchical structures, was to express hierarchy implicit where possible and as naturally as possible where it cannot be implicit, for the sake of improve functional lucidity for strictly constrained structured writing languages. (First and foremost, I created it for myself, to improve functional lucidity for me in the structured writing I do, such as the writing of this book.)</db:para>
</db:section>
<db:section>
<db:title>Agreeing on boxes, names, and labels</db:title>
<db:para>The names and labels on boxes tell us what kind of thing is in the box. What kind of things they  tell us depends on the domain we are dealing with.</db:para>
<db:para>In the media domain they tell us what the words in the box look like, either directly (an actual format description) or by reference (the name of a style). In the document domain they tell us what part of a document the words are. In the management domain, they tell us what to do with the words under different circumstances. In the subject domain they tell us what the subject matter of the words is.</db:para>
<db:para>The box does not only have to have information from one domain on it. It is not uncommon to have a box with a name in the document domain and a label in the management domain or the subject domain. We saw and example of this in <db:xref linkend="chapter.subject-domain"/>:</db:para>
<db:programlisting language="xml">
&lt;section publication="Wine Weenie"&gt;
    &lt;title&gt;Wine match&lt;/title&gt;
    &lt;p&gt;Pinot Noir&lt;/p&gt;
&lt;/section&gt;
&lt;section publication="The Teetotaler's Trumpet"&gt;
    &lt;title&gt;Suggested beverage&lt;/title&gt;
    &lt;p&gt;Lemonade&lt;/p&gt;
&lt;/section&gt;
</db:programlisting>
<db:para>Here the <db:code>section</db:code> box is in the document domain, but the <db:code>publication</db:code> label is in the management domain.</db:para>
<db:para>The names and labels on the boxes tell us what constraints the words in the box obey, or, as we are writing, what constraints the words we write are expected to obey. Algorithms use the names and the labels to process the content, assuming that they accurately reflect the constraints.</db:para>
<db:para>For structured writing to work, it is essential that everyone involved understands and agrees on what the names and labels mean. If we don’t, the names and labels will not accurately reflect the constraints we expect, and the whole content quality project falls apart and the algorithms stop working.</db:para>
<db:para>Confusion and disagreement about what the names and labels of a particular language mean are not uncommon. Large document domain languages like DocBook and DITA have large vocabularies, and many of the names they offer are quite abstract. Questions about the right way to tag certain passages are common in the communities around these languages, and opinions can vary considerably in some cases. These disagreements don’t only affect low-level structures. In DITA, for example, it is common to debate if a topic is a concept or a task, while some writers choose to use only generic topics because they don’t feel the models of the task, concept, and reference topics fit the content they are creating.</db:para>
<db:para>Having precise definition of terms is important, therefore, in developing a structured writing language. But it is equally important that the language be functionally lucid. The authoring algorithm requires that creating structure should not come at the detriment of the writing itself. This requirement is not met if writers are constantly having to puzzle out or debate the right way to mark something up.</db:para>
<db:para>In the software world, meta models and abstraction are powerful tools for modeling systems. They provide clear high-level rules for the design of specific structures and create opportunities to reuse code for objects with a shared base model. But these tools can also lead to very abstract naming schemes and even to abstract structures. In the content world, such abstract names and structures can be formally correct but lack the kind of functional lucidity required for effective authoring.</db:para>
<db:para>The problem of defining a (mechanical structure) to express a (rhetorical structure) is not only one of defining a correct representation of the content. We also have to design and name structures that can be written by our intended set of authors without imposing a heavy burden on their attention. In other words, designing content structures, at least those intended for use by authors, is as much about interface design as it is about data structure design.</db:para>
<db:para>Clear concrete and specific names, and an organization of boxes that intuitively fits the subject matter, all make for easier authoring. There is no reason that such structures cannot be derived from abstract models, or that they cannot be mapped to abstract models after the fact, but it is important not to let the abstractions intrude too munch into the world of the author.</db:para>
<db:para>Of course, functional lucidity only matters for the formats that authors actually write in. As we have seen, the publishing algorithm typically consists of multiple steps, and each one of those steps can create a format that is closer to the media domain than the one before it. It is perfectly possible to design a document domain structure the only purpose of which is to serve as a step in the publishing chain. Separate authoring formats are created for authors to actually write in (perhaps subject domain formats or simplified highly constrained ad-hoc document domain formats). Content is transformed from these formats to the document domain format by the presentation algorithm and then the document domain format is translated in to various different media domain languages by the formatting routine. An arrangement like this eliminates the need to compromise between different demands in designing a single language, generally making each language in the chain simpler and more constrained, which in turn makes it each one easier to validate and to process.</db:para>
</db:section>
<db:section>
<db:title>Structure and annotation</db:title>
<db:para>Broadly speaking, structured markup provides two things: structure and annotation. Structure governs the relationship of pieces. It is structure that says that a list consists of list items, that an API reference must begin with a function signature followed by a list of parameter values, that says that an ingredient listing consists of the ingredient name followed by a quantity followed by a unit of measure, or that a section must begin with a title. It is in structure that we create, impose, and express most of the constraints that are fundamental to structured writing.</db:para>
<db:para>Every structure has a name (though the name is implicit in some forms of markup. The name of the structure is an annotation of the constraint that the structure imposes. (Remember that we defined structured writing as both imposing a constraint and recording that the constraint has been applied.)</db:para>
<db:para>The different structured writing domains are defined by what these annotation of structure are saying about the content they contain.</db:para>
<db:variablelist>
<db:varlistentry>
<db:term>Media Domain</db:term>
<db:listitem><db:para>The annotation says what the content should look like.</db:para></db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Document Domain</db:term>
<db:listitem><db:para>The annotation says what role the content plays in the document.</db:para></db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Subject Domain</db:term>
<db:listitem><db:para>The annotation relates the content to its subject matter.</db:para></db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Management Domain</db:term>
<db:listitem><db:para>The annotation says how the content should be managed.</db:para></db:listitem>
</db:varlistentry>
</db:variablelist>
<db:para>But the name of a structure only allow you to say one thing about the content. In some cases you may want to add more than one annotation to a structure. For instance, you might want to add a condition to a paragraph. In this case, the name of the structure annotates that it is a paragraph and you need an additional management-domain annotation to hold the condition.</db:para>
<db:para>This use of additional annotations is quite common. For instance:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>In DITA, the keyref attribute is used to add management domain metadata to a number of document structure elements.</db:para>
</db:listitem>
<db:listitem>
<db:para>In HTML, the style attribute can be used to add media domain metadata to the document structure.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>However, not all annotations are attached to structures. At a certain point in defining the structure of content we get down to what is essentially free-form narrative content -- that is, paragraphs of text. But even within a paragraph, that are pieces of text that we may want to annotate. Examples from each of the domains include:</db:para>
<db:variablelist>
<db:varlistentry>
<db:term>Media Domain</db:term>
<db:listitem><db:para>A <db:code>bold</db:code> or <db:code>strong</db:code> annotation on a piece of text you want to emphasize.</db:para></db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Document Domain</db:term>
<db:listitem><db:para>An <db:code>xref</db:code> annotation to create a reference to another part of the content.</db:para></db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Subject Domain</db:term>
<db:listitem><db:para>A <db:code>function</db:code> annotation to identify that a piece of text is the name of a function.</db:para></db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Management Domain</db:term>
<db:listitem><db:para>A conditional annotation to identify a piece of text that may be conditionally included or excluded from output.</db:para></db:listitem>
</db:varlistentry>
</db:variablelist>
<db:para>Different markup systems support structure and annotation in different ways.</db:para>
<db:section>
<db:title>Structure and annotation in SAM</db:title>
<db:para>In SAM (the language used for most of the examples in this book), there are a number of types of structure, but the main extensible structure is the block. Annotations are part of the definition of the language. Annotations can be added to blocks and can also float in text.</db:para>
<db:programlisting language="SAM">
section:(#annotations) Annotations
    This is a paragraph containing an {annotation}(concept).
</db:programlisting>
<db:para>In the example above, <db:code>section</db:code> is a structure containing a title and a paragraph. The <db:code>section</db:code> structure has an annotation which is contained in parentheses immediately after the colon that defines the structure. In this case it is an ID annotation and assigns the ID “annotations” to the structure.</db:para>
<db:para>The word “annotation” in the paragraph is annotated with a free-floating annotation. The curly braces delineated the text that is being annotated. The parentheses contain the annotation itself, which in this case is a type annotation, indicating that the word “annotation” is a reference to concept.</db:para>
</db:section>
<db:section>
<db:title>Structure and annotation in XML</db:title>
<db:para>In XML we have two principal types of markup, the element and the attribute. Elements are used to define structure and element names annotate those structures. Additional annotations take the form of attributes.  Annotations on phrases withing a body of text are also created with elements. Again, the element name provides the basic annotation and attributes can be used for additional annotations.</db:para>
<db:para>So the SAM example above could be expressed like this in XML:</db:para>
<db:programlisting language="XML">
&lt;section id="annotations"&gt;
    &lt;title&gt;Annotations&lt;/title&gt;
    &lt;p&gt;This is a paragraph containing an &lt;concept&gt;annotation&lt;/concept&gt;. 
</db:programlisting>
</db:section>
<db:section>
<db:title>Structure in attributes</db:title>
<db:para>Having said that in XML, elements denote structure and attributes are for additional annotations on that structure, we should note that there are exceptions. XML is a fully general markup syntax and therefore markup language designers can use it any way they like. In some case, language designers have decided to use attributes to denote structure.</db:para>
<db:para>Consider these examples of HTML Microformats from Wikipedia<db:footnote><db:para>https://en.wikipedia.org/wiki/Microformat</db:para></db:footnote>. The first example shows an address formatted as a list.</db:para>
<db:programlisting language="HTML">
&lt;ul&gt;
   &lt;li&gt;Joe Doe&lt;/li&gt;
   &lt;li&gt;The Example Company&lt;/li&gt;
   &lt;li&gt;604-555-1234&lt;/li&gt;
   &lt;li&gt;&lt;a href="http://example.com/"&gt;http://example.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</db:programlisting>
<db:para>Here the phrase <db:code>The Example Company</db:code> is contained in <db:code>li</db:code> tags. This is part of a list structure delineated by <db:code>ul</db:code> tags, so the markup is largely structural in the document domain. The <db:code>li</db:code> does not really tell you anything useful about what the content itself is about. It does not tell you anything useful beyond what document structure it belongs to. It is not much use as an annotation.</db:para>
<db:para>The second example adds hCard microformat markup:</db:para>
<db:programlisting language="HTML">
&lt;ul class="vcard"&gt;
   &lt;li class="fn"&gt;Joe Doe&lt;/li&gt;
   &lt;li class="org"&gt;The Example Company&lt;/li&gt;
   &lt;li class="tel"&gt;604-555-1234&lt;/li&gt;
   &lt;li&gt;&lt;a class="url" href="http://example.com/"&gt;http://example.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</db:programlisting>
<db:para>This example adds subject domain metadata in the form of the class attributes. For example, it says that the phrase <db:code>The Example Company</db:code> is a reference to an organization (<db:code>org</db:code>). So far this is just regular annotation.</db:para>
<db:para>However, there is not just annotation going on here. There is actually subject domain structure being expressed. Not only is the list item <db:code>The Example Company</db:code> annotated as <db:code>org</db:code>, the list that contains it is annotated as <db:code>vcard</db:code>. The meaning of <db:code>org</db:code> is actually dependent on it being part of a <db:code>vcard</db:code> structure.</db:para>
<db:para>In other words, the annotations in the sample above are equivalent to pure subject domain markup like this:</db:para>
<db:programlisting language="SAM">
vcard:
   fn: Joe Doe
   org: The Example Company
   tel: 604-555-1234
   url: http://example.com/
</db:programlisting>
<db:para>In other words again, the microformats are overlaying a second structure on the list structure. In the world of HTML, this makes sense. HTML needs to be a standardized document domain language so that browsers can display it for human reading. Humans don’t need the vCard annotations to recognize that the content is an address, but algorithms do. So the microformat adds a second, hidden, subject domain structure to the document for readers who are algorithms rather than people.</db:para>
<db:para>We noted in <db:xref linkend="chapter.definition"/> that structured writing constrains both the creation and the interpretation of content. In the normal case we expect that the creation of the content would be just as constrained as the interpretation. After all, it is hard to rely on the interpretation of structure if the creation of the structure is not constrained. However in this case the interpretation of the data is more constrained than the creation.</db:para>
<db:para>Authoring our content this way would obviously be inefficient and error prone. But this is only a problem if the content is actually authored in this format. If the content is authored in a format in which its creation is constrained to the same extent as we wish the output to be constrained, it does not actually matter that the resulting output constrains interpretation more than it constrains creation. Our concern as content creators is simply to make sure that any content we produce that promises to abide by a constraint actually does so, whether the format we deliver it in actually imposes that constraint or merely annotates it.</db:para>
<db:para>So, we can confidently produce this information using subject domain markup and then deliver it as HTML with hCard annotation markup using a presentation algorithm something like this (as with all example algorithms in this book, this is pseudocode):</db:para>
<db:programlisting language="pseudo">
match vcard
    create ul
        attribute class = "vcard"
        continue

match fn
    create li
        attribute class = "fn"
        continue

match org
    create li
        attribute class = "org"
        continue

match tel
    create li
        attribute class = "tel"
        continue

match url
    create li
        create a
            attribute class = "url"
            attribute href = contents
            continue
</db:programlisting>
</db:section>
<db:section>
<db:title>Structure vs annotation</db:title>
<db:para>If the distinction between structure and annotation -- between boxes and the labels on the boxes -- does not seem entirely solid to you, that is because it practice it can be quite fluid.</db:para>
<db:para>For instance, if we start with the principle that in XML elements are for structure and attributes are for additional annotation on a structure (which we have already poked holes in above), then surely it should be clear when we should use attributes and when we should use elements. But in practice it is often not clear at all.</db:para>
<db:para>Consider our previous example. It could be written this way, using just elements:</db:para>
<db:programlisting language="XML">
&lt;vcard&gt;
   &lt;fn&gt;Joe Doe&lt;/fn&gt;
   &lt;org&gt;The Example Company&lt;/org&gt;
   &lt;tel&gt;604-555-1234&lt;/tel&gt;
   &lt;url&gt;http://example.com/&lt;/url&gt;
&lt;/vcard&gt;
</db:programlisting>
<db:para>Or it could be written this way, using attributes:</db:para>
<db:programlisting language="XML">
&lt;vcard
   fn="Joe Doe"
   org="The Example Company"
   tel="604-555-1234"
   url="http://example.com/"
/&gt;
</db:programlisting>
<db:para>The first says that <db:code>fn</db:code>, <db:code>org</db:code>, <db:code>tel</db:code>, and <db:code>url</db:code> are independent structures that belong as members to a <db:code>vcard</db:code> structure. The second says that the <db:code>vcard</db:code> structure has a number of data fields -- annotations -- that complete its meaning.</db:para>
<db:para>Does this distinction matter terribly? Both allow you to get at the information you want. Both constrain both the creation and the interpretation of data. There are limits to the version that uses attributes. You can’t have more than one attribute with the same name, whereas you could have more than one member elements of the same name (multiple tel elements for someone with more than one telephone number for instance). Also, XML specifies that attributes are unordered, so can’t restrain either the order in which writers create them or the order in which the parser reports them to a processing application.</db:para>
<db:para>Given this, you may be wondering why people bother with attributes, since you can do the same things with elements and have both more flexibility and more capacity to impose constraints. Yet people continue to use attributes extensively when designing markup languages in XML.  When people create XML document types for representing data, rather than for writing document, they almost always use the attribute format, perhaps because it is slightly less verbose and slightly easier to read, or perhaps because as programmers they are accustomed to representing data as key/value pairs linked with <db:code>=</db:code> signs.</db:para>
<db:para>But for documents it is more complex. To understand why XML even has attributes, and why other languages, such as SAM or reStructuredText, also have similar mechanisms for adding annotations to blocks, we need to go back to the original concept of markup as something written onto a manuscript after the fact. Markup is an addition to the text, not part of it. The content of an element is part of the underlying text. Anything you want to add, therefore, cannot be element content, since that would be adding to the text. Everything else has to be added to element definitions as attributes.</db:para>
<db:para>This view is reinforced by the academic interest in markup as a way to prepare texts for study. Again, here, the text is preexisting and canonical. The markup is external to it and so everything that is external to the original text must be contained in the markup itself (as attributes) and noting that is internal to the original text must be removed or replaced by markup. Thus in this fragment of a Shakerpere play marked up by John Bosek we see that the original text is kept perfectly intact:</db:para>
<db:programlisting language="xml">
&lt;ACT&gt;
&lt;TITLE&gt;ACT I&lt;/TITLE&gt;
&lt;SCENE&gt;
&lt;TITLE&gt;SCENE I. Rousillon. The COUNT's palace.&lt;/TITLE&gt;
&lt;STAGEDIR&gt;
Enter BERTRAM, the COUNTESS of Rousillon, HELENA, and LAFEU, all in black
&lt;/STAGEDIR&gt;
&lt;SPEECH&gt;
&lt;SPEAKER&gt;COUNTESS&lt;/SPEAKER&gt;
&lt;LINE&gt;
In delivering my son from me, I bury a second husband.
&lt;/LINE&gt;
&lt;/SPEECH&gt;
&lt;SPEECH&gt;
&lt;SPEAKER&gt;BERTRAM&lt;/SPEAKER&gt;
&lt;LINE&gt;And I in going, madam, weep o'er my father's death&lt;/LINE&gt;
&lt;LINE&gt;anew: but I must attend his majesty's command, to&lt;/LINE&gt;
&lt;LINE&gt;whom I am now in ward, evermore in subjection.&lt;/LINE&gt;
&lt;/SPEECH&gt;
</db:programlisting>
<db:para>Had this markup employed the normal refactoring of text into markup that we have seen in our discussions of the document domains, then the number and title of scenes would have been factored out so that instead of:</db:para>
<db:programlisting language="xml">
&lt;SCENE&gt;
    &lt;TITLE&gt;SCENE I. Rousillon. The COUNT's palace.&lt;/TITLE&gt;
</db:programlisting>
<db:para>we might have factored out the scene number and the work ‘SCENE’ like this:</db:para>
<db:programlisting language="xml">
&lt;SCENE&gt;
    &lt;TITLE&gt;Rousillon. The COUNT's palace.&lt;/TITLE&gt;
</db:programlisting>
<db:para>Going further, we might have noted that the introduction of a scene is invariable the name of its location, so we might have done this:</db:para>
<db:programlisting language="xml">
&lt;SCENE&gt;
    &lt;LOCATION&gt;Rousillon. The COUNT's palace.&lt;/LOCATION&gt;
</db:programlisting>
<db:para>or even this:</db:para>
<db:programlisting language="xml">
&lt;SCENE location=Rousillon. The COUNT's palace."&gt;
</db:programlisting>
<db:para>And similarly, we might have replaced:</db:para>
<db:programlisting language="xml">
&lt;SPEECH&gt;
    &lt;SPEAKER&gt;BERTRAM&lt;/SPEAKER&gt;
</db:programlisting>
<db:programlisting language="xml">
&lt;SPEECH SPEAKER="BERTRAM"&gt;
</db:programlisting>
<db:para>Making a few changes like this in the markup would leave us with only the words actually spoken by the actors as the “text” of the play and everything else expressed as elements or attributes.</db:para>
<db:para>This actually makes quite a lot of sense, because all of the stage directions and attribution of speakers in a play is actually metadata annotating the speeches of the actors which are the only things the audience is actually supposed to hear.</db:para>
<db:para>So is the right way to markup a play to preserve the original printed text -- which includes all of the playwright’s metadata -- or is it better to separate the playwrights metadata from the speeches which are the ‘real’ play?</db:para>
<db:para>The answers to questions like this need not concern us greatly. The fact that such question exist, however, help us to understand both why a markup language like XML is structured the way it is, and why so many texts are marked up the way they are -- and why so many tagging languages are designed the way they are.</db:para>
<db:para>The way we, as practitioners of structured writing for content quality, settle these matters is by asking ourselves which approach best supports the structured writing algorithms that we want to implement, and always remembering that the reliability of every other algorithm depends on how well the conformance algorithms works, and that the conformance algorithm depends to a large extent on how the authoring algorithm designs for conformance and for functional lucidity.</db:para>
<db:para>In none of this are we in the least concerned about preserving the canonical nature of a preexisting text. There is no preexisting text. We are all about creating new texts. Because of this we have every reason to prefer to use sub-structures rather than annotations on existing structures, to express things like our vCard example. In fact, SAM, which is designed specifically for structured authoring, only supports this format:</db:para>
<db:programlisting language="SAM">
vcard:
   fn: Joe Doe
   org: The Example Company
   tel: 604-555-1234
   url: http://example.com/
</db:programlisting>
<db:para>SAM only supports a very limited set of annotations on blocks, all of which have predefined meetings. You could, in fact, eliminate annotations on blocks altogether, and use child blocks for everything, but I have supported a limited set of common management-domain block annotations in SAM, mostly to improve functional lucidity.</db:para>
<db:para>Support for free-floating annotation in text is another matter. Those you will always need for document-oriented markup and structured writing.</db:para>
<db:para>In summary, when defining the mechanical structure of your structured writing, don’t get hung up on what is text and what is markup. In each domain, text and markup together form a body of constrained content which can be successfully created by an author and successfully processes by one or more algorithms. Only when you resolve the content all the way to the media domain do you finally have to sort our exactly which characters appear in which order and decoration to represent that content to a particular audience. When we choose to create content in the other domains it is precisely because we want to exercise more control over these things, and to use algorithms to help us create and manage them. Whether some idea or constraint is expressed by text of markup in those domains should be based solely on what works best in those domains. (Which is precisely why attempting to do structured writing using a WYSIWYG editor is so counter productive, and why it is so important to ensure the functional lucidity of your markup as markup.)</db:para>
</db:section>
</db:section>
</db:chapter>
