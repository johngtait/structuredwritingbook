<?xml version="1.0"?>
<db:chapter xmlns:db="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:strings="http://exslt.org/strings" version="5.0" xml:id="chapter.mechanical-structure">
<db:title>Mechanical Structure</db:title>

<db:para>Mechanical structure is the way we record, encode, and enforce the rhetorical structure, or at least the parts of the rhetorical structure that we want to make accessible to algorithms.</db:para>
<db:para>The mechanical structure of structure writing is a computer data structure. However, conventional computer data structures like relational database tables do not work well for content because they are too regular to fit the shape of content. Creating structures that are regular enough for algorithms to deal with yet irregular enough to fit written language is an interesting problem to which more than one solution has been proposed.</db:para>
<db:para>Raw text is just a stream of characters. Inside that stream of characters, there are rhetorical structures like headings, bibliographical entries, bold text, chapters, ingredient lists, links, wine matches, tables, function signatures, and labeled lists. The question is, how do you express these various structures within the raw stream of characters?</db:para>
<db:para>The most common answer is that you divide the text up into a series of blocks, and divide the blocks into smaller blocks until all the structures you want to capture are contained in logical blocks. This is not the only way to do it. Some file formats, such as WordPerfect, use independent stop and start markers to delineate structures, meaning the the boundaries of structures can overlap. But while this kind of structured can work for the media domain, it is very difficult for many structured writing algorithms to work with. Therefore most structured writing today uses the nested block approach.<db:footnote>
<db:para>Is is technically possible to implement independent stop and start markers even in languages that are mainly block based. You simply define empty blocks for the start and stop markers. Both DITA and DocBook do this for things like delineating arbitrary bits of content for reuse and defining arbitrary spans of content for indexing. Both of these uses strike me as a really bad idea and I would recommend against their user in any content that has any lifespan beyond its first publication.</db:para>
</db:footnote></db:para>

<db:para>There are definitely cases in which the use of non-overlapping blocks for the mechanical structure of content does not fit with the rhetorical structures that we find in our content. This is more of an issue for the academic study of texts than for structured writing as a means of partitioning and redirecting complexity in the content system, but it can occur in both fields. Allowing overlapping fields, however, adds complexity to many of the structured writing algorithms, meaning it is almost never a worthwhile approach to partitioning our content.</db:para>
<db:para>For our purposes, therefore, I am going to deal with the mechanical structure of content strictly in terms of nested non-overlapping blocks.</db:para>
<db:section>
<db:title>Flat vs. nested structures</db:title>
<db:para>But even when we decided on the nested blocks approach, however, we are still left with some fundamental choices about mechanical structure. The first is flat vs. nested structure.</db:para>
<db:para>We noted in <db:xref linkend="chapter.document-domain"/> that in HTML, you have six levels of heading (<db:code>h1</db:code> through <db:code>h6</db:code>) whereas in DocBook you have only <db:code>title</db:code>. In DocBook, you can divide a document up into sections and nest sections inside sections. You can then print the titles of sections inside sections in a smaller font that the titles of first level sections. You get to have differences in heading size without having six different heading tags.</db:para>
<db:para>But the DocBook model assumes that the real structure of a document is  a hierarchy of nested sections and that the size of titles announces the steps up and down that hierarchical tree. HTML makes no such assumption. It will let you put a <db:code>&lt;h4&gt;</db:code> immediately after an <db:code>&lt;h1&gt;</db:code> if you want to. It treats documents as essentially flat structures punctuated by headings of various sizes as and where appropriate.</db:para>
<db:para>Which model of a document is correct? Which corresponds best to the rhetorical structure of the document? You can think of a document as being organized hierarchically, with major ideas expressed in sections, sub-ideas supporting the major ideas in subsections, etc. There are doubtless documents that fit that model. But you can also think of documents as being more like a journey in which headings function more like road signs. A city gets a big sign, a hamlet a small sign, and a town a medium sign. But the town is not inside the city, not the hamlet inside the town, and there is no guarantee that on leaving the city you will come to the town before you come to a hamlet.</db:para>
<db:para>Studies by Peter Flynn indicate that most authors think of the documents they are writing much more in terms of a punctuated linear model than a hierarchical model.</db:para>
<db:blockquote>
<db:attribution>Flynn2009</db:attribution><db:para>The classical theory, derived from computer science and graph theory, is that the document is a hierarchical tree (actually inverted: a root-system) and that all necessary actions can be seen in terms of navigation around the tree, and of insertion into and withdrawal from the the nodes which form the branches and leaves.</db:para>
<db:para>The conventional writer, however — and we expressly exclude the markup expert, as well as the experienced technical authors who responded to the survey — is by repute probably only marginally aware of this tree; but we have been unable to measure this at present. In this view, the document is seen as a continuous linear narrative, broken into successive divisions along semantic lines, and interspersed with explanatory material in the form of figures, tables, lists, and their derivatives.</db:para>
</db:blockquote>
<db:para>And as Flynn’s research illustrates, there is a good chance that the author is not thinking of their argument as consisting of a strict hierarchy of points either, but as a sequence of points with the occasional insertion of heading to break up the text or perhaps signal a change in emphasis or subject matter. Clearly defining the rhetorical structure of a document demands dividing it up into blocks such as introduction, ingredients, and preparation. As we have noted, treating these parts of the rhetorical structure as blocks is essential to establishing the context in which our block names are defined and by which our processing rules tell the difference between one type of block and another. This clearly involves asking the author to think a little bit more hierarchically than they might otherwise, which means imposing a little bit of complexity on them for the sake of all the partitioning and redirection of complexity we need to do for the content system overall. Some semantic and rhetorical blocks are going to be naturally more hierarchical than others as well. But there is no need to do any more of this than the needs of our partitioning system demand.</db:para>
<db:para>But if the constraints that we want to express in structured writing demand hierarchy, while functional lucidity demands more of a punctuated linear model, how do we reconcile these two opposing requirements in markup language design?</db:para>
<db:para>This is of greatest concern in the design of document domain languages. The structure of media domain languages is largely dictated by the shape and relationship of the media-domain object they are modeling. In the subject domain, we have abstracted content out of strict document order. Hierarchy in the subject domain tend to match the hierarchy of relationship in the subject matter itself.<db:footnote>
<db:para>Though this is not universal. Addresses, for instance, which are based on hierarchal locations, are modeled as flat ordered lists. The order reflect the hierarchy, but the nesting of city inside country and of street within city is not reflected in the structure of an address record.</db:para>
</db:footnote> In the document domain, however, it is a real concern. The document domain consists of abstractions of document structures and the nature of their relationship to the structure of thought in the text is not obvious.</db:para>

<db:para>The options available are:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Create a really flat document domain language. Examples are HTML and Markdown. The problem here is that they impose few constraints, and the lack of context-setting hierarchy makes it hard to model different types of document structures without creating hundred of tags -- which would negate any functional lucidity that you gained by keeping the language flat.</db:para>
</db:listitem>
<db:listitem>
<db:para>Create a hierarchical language that has a really permissive structure, so that you can put boxes inside boxes in lots of different ways. An example of this is DocBook. The problem here is that the possible permutations make writing algorithms difficult and you often need to impose additional constraints on your authors that are not expressed or enforced by the markup itself. This again diminishes functional lucidity, and compromises conformance. (An interesting property of this approach is that the flexibility of the language means that authors can choose to create documents that are deeply nested or very flat. This is not really a virtue, however, as it is not clear how this choice contributes to improved content quality.)</db:para>
</db:listitem>
<db:listitem>
<db:para>Define a smaller, stricter document domain language that is appropriate to the particular types of documents you want to write, possibly as restricted subset of an existing language like DocBook. The main difficulty with this approach is that it involves you in having to do your own language design, which many organization try to avoid. Once you have decided to go this route, going to the subject domain instead may be no more expensive while providing better functional lucidity and conformance.</db:para>
</db:listitem>
<db:listitem>
<db:para>Define a strict hierarchical document domain language that expresses the constraints you need and make people learn it. This works if you are able to recoup the expense of training your authors. It does not work if you want to include occasional authors in your pool of contributors.</db:para>
</db:listitem>
<db:listitem>
<db:para>Move content creation to the subject domain.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>In the document domain, however, you have to make a choice between enforcing a hierarchical model of a document or allowing a more linear one. You will almost certainly do this in the context of hierarchical syntax.  But you do need to decide if you are going to allow arbitrary heading levels. Or, to put it another way, to model a document as a hierarchy of sections with each section having a title, or a single flow of text randomly interspersed with headings, or something in between.</db:para>
<db:para>The something-in-between option can seem appealing but you can end up with something really unconstrained, meaning that it is difficult to write reliable algorithms to process it. Here is the kind of issues you can run into:</db:para>
<db:para>Is a list part of the paragraph in which it occurs? Some markup languages, such as Markdown and SAM, take the view that lists are separate blocks that come after a preceding paragraph. But DITA, DocBook, and HTML will all let you place a list either inside or outside a paragraph:</db:para>
<db:programlisting>
&lt;p&gt; The primary colors are:
    &lt;ul&gt;
        &lt;li&gt;Red&lt;/li&gt;
        &lt;li&gt;Blue&lt;/li&gt;
        &lt;li&gt;Yellow&lt;/li&gt;
    &lt;/ul&gt;
&lt;/p&gt;

&lt;p&gt; Their complementary colors are:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Green&lt;/li&gt;
    &lt;li&gt;Orange&lt;/li&gt;
    &lt;li&gt;Purple&lt;/li&gt;
&lt;/ul&gt;
</db:programlisting>
<db:para>The interesting question here is whether these two structures should be formatted differently for output. Should the list that in inside the paragraph be indented, which the one that comes afterwards be printed flush left?</db:para>
<db:para>The default for HTML, at least in the browsers I tried it on (Edge, Internet Explorer, and Chrome) is that both are indented by the same amount, but of course you could change this with CSS and DocBook and DITA processors can do what they like.</db:para>
<db:para>But would it be a good idea to make a distinction between the two? Only if authors clearly understood the difference between the two and clearly knew when they were choosing one or the other. (If they are writing in a visual editing view of an XML editor, then they almost certainly won’t know the difference.)</db:para>
<db:para>If you are designing your own markup language, do you want to allow both these forms? Probably not. The more permutations of structure your markup language allows, the more work it will be to write the algorithms to process it. Some allowance may be made for ease of authoring, if you wish, but it may be better to wait for authors to complain about a restriction like this than to build in all the possible variations in advance.</db:para>
</db:section>

<db:section>
<db:title>Agreeing on names</db:title>
<db:para>The names of blocks tell us what kind of thing is in the box. What kind of things they  tell us depends on the domain we are dealing with.</db:para>
<db:para>In the media domain they tell us what the words in the box look like, either directly (an actual format description) or by reference (the name of a style). In the document domain they tell us what part of a document the words are. In the management domain, they tell us what to do with the words under different circumstances. In the subject domain they tell us what the subject matter of the words is.</db:para>
<db:para>The block does not only have to have information from one domain on it. It is not uncommon to have a block with a name in the document domain and a label in the management domain or the subject domain. We saw and example of this in <db:xref linkend="chapter.subject-domain"/>:</db:para>
<db:programlisting language="xml">
&lt;section publication="Wine Weenie"&gt;
    &lt;title&gt;Wine match&lt;/title&gt;
    &lt;p&gt;Pinot Noir&lt;/p&gt;
&lt;/section&gt;
&lt;section publication="The Teetotaler's Trumpet"&gt;
    &lt;title&gt;Suggested beverage&lt;/title&gt;
    &lt;p&gt;Lemonade&lt;/p&gt;
&lt;/section&gt;
</db:programlisting>
<db:para>Here the <db:code>section</db:code> box is in the document domain, but the <db:code>publication</db:code> label is in the management domain.</db:para>
<db:para>The names and labels on the blocks tell us what constraints the structures inside the block obey, or, as we are writing, what constraints the words we write are expected to obey. Algorithms use the names and the labels to process the content, assuming that they accurately reflect the constraints.</db:para>
<db:para>For structured writing to work, it is essential that everyone involved understands and agrees on what the names and labels mean. If we don’t, the names and labels will not accurately reflect the constraints we expect, and the whole content quality project falls apart and the algorithms stop working.</db:para>
<db:para>Confusion and disagreement about what the names and labels of a particular language mean are not uncommon. Large document domain languages like DocBook and DITA have large vocabularies, and many of the names they offer are quite abstract. Questions about the right way to tag certain passages are common in the communities around these languages, and opinions can vary considerably in some cases. These disagreements don’t only affect low-level structures. In DITA, for example, it is common to debate if a topic that is operational but not procedural is a concept or a task. Some writers choose to use only generic topics because they don’t feel the models of the task, concept, and reference topics fit the content they are creating.</db:para>
<db:para>Having precise definition of terms is important, therefore, in developing a structured writing language. But it is equally important that the language be functionally lucid. The authoring algorithm requires that creating structure should not come at the detriment of the writing itself. This requirement is not met if writers are constantly having to puzzle out or debate the right way to mark something up.</db:para>
<db:para>In the software world, meta models and abstraction are powerful tools for modeling systems. They provide clear high-level rules for the design of specific structures and create opportunities to reuse code for objects with a shared base model. But these tools can also lead to very abstract naming schemes and even to abstract structures. In the content world, such abstract names and structures can be formally correct but lack the kind of functional lucidity required for effective authoring.</db:para>
<db:para>The problem of defining a (mechanical structure) to express a (rhetorical structure) is not only one of defining a correct representation of the content. We also have to design and name structures that can be written by our intended set of authors without imposing a heavy burden on their attention. In other words, designing content structures, at least those intended for use by authors, is as much about interface design as it is about data structure design.</db:para>
<db:para>Clear concrete and specific names, and an organization of boxes that intuitively fits the subject matter, all make for easier authoring. There is no reason that such structures cannot be derived from abstract models, or that they cannot be mapped to abstract models after the fact, but it is important not to let the abstractions intrude too munch into the world of the author.</db:para>
<db:para>Of course, functional lucidity only matters for the formats that authors actually write in. As we have seen, the publishing algorithm typically consists of multiple steps, and each one of those steps can create a format that is closer to the media domain than the one before it. It is perfectly possible to design a document domain structure for the sole purpose of of serving as a step in the publishing chain. Separate authoring formats are created for authors to actually write in (perhaps subject domain formats or simplified highly constrained ad-hoc document domain formats). Content is transformed from these formats to the document domain format by the presentation algorithm and then the document domain format is translated in to various different media domain languages by the formatting routine. An arrangement like this eliminates the need to compromise between different demands in designing a single language, generally making each language in the chain simpler and more constrained, which in turn makes it each one easier to validate and to process.</db:para>
</db:section>
<db:section>
<db:title>Constraint and annotation</db:title>
<db:para>Broadly speaking, structured markup provides two things: constraint and annotation. Constraint governs the relationship of pieces. It is constraint that says that a list consists of list items, that an API reference must begin with a function signature followed by a list of parameter values, that an ingredient listing consists of the ingredient name followed by a quantity followed by a unit of measure, or that a section must begin with a title.</db:para>
<db:para>Annotation adds information to the constrained structures. The name of the structure is its first and most important annotation. It is the annotation that expresses the core constraint that has been imposed. This may be supplemented by other annotations on the structure that further clarify the constraint that has been imposed, or contain other metadata, such as management domain annotation.</db:para>
<db:para>But we can also have unconstrained annotation, or at least, annotation whose usage is very lightly constrained. In some XML-based languages, for instance, there are sets of attributes that are allowed to appear on just about any element in the entire language. (ID attributes are an obvious example.) But the main source of unconstrained annotation are those that can float in the middle of a piece of text.</db:para>
<db:para>As we noted, we cannot capture the full rhetorical semantics of any piece of writing using simple linear or hierarchical structures. At some point we have to leave the writer free to express themselves in paragraphs of text on which we can impose no meaningful restriction. But we may still be very much interested in constraining the interpretation of many of the words and phrases used in those paragraphs.</db:para>
<db:para>Such annotations are constrained in the sense that there is a limited set of them available for use, but they are almost always unconstrained as to where and in what order they appear in the text -- for the very good reason the their text that they annotate obeys no regular rule or pattern.</db:para>
<db:para>Every structure has a name (though the name is implicit in some forms of markup. The name of the structure is an annotation of the constraint that the structure imposes. (Remember that we defined structured writing as both imposing a constraint and recording that the constraint has been applied.)</db:para>
<db:para>The different structured writing domains are defined by what these annotation of structure are saying about the content they contain.</db:para>
<db:variablelist>
<db:varlistentry>
<db:term>Media Domain</db:term>
<db:listitem><db:para>The annotation says what the content should look like.</db:para></db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Document Domain</db:term>
<db:listitem><db:para>The annotation says what role the content plays in the document.</db:para></db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Subject Domain</db:term>
<db:listitem><db:para>The annotation relates the content to its subject matter.</db:para></db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Management Domain</db:term>
<db:listitem><db:para>The annotation says how the content should be managed.</db:para></db:listitem>
</db:varlistentry>
</db:variablelist>
<db:para>But the name of a structure only allow you to say one thing about the content. In some cases you may want to add more than one annotation to a structure. For instance, you might want to add a condition to a paragraph. In this case, the name of the structure annotates that it is a paragraph and you need an additional management-domain annotation to hold the condition.</db:para>
<db:para>This use of additional annotations is quite common. For instance:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>In DITA, the keyref attribute is used to add management domain metadata to a number of document structure elements.</db:para>
</db:listitem>
<db:listitem>
<db:para>In HTML, the style attribute can be used to add media domain metadata to the document structure.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>However, not all annotations are attached to structures. At a certain point in defining the structure of content we get down to what is essentially free-form narrative content -- that is, paragraphs of text. But even within a paragraph, there are pieces of text that we may want to annotate. Examples from each of the domains include:</db:para>
<db:variablelist>
<db:varlistentry>
<db:term>Media Domain</db:term>
<db:listitem><db:para>A <db:code>bold</db:code> or <db:code>strong</db:code> annotation on a piece of text you want to emphasize.</db:para></db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Document Domain</db:term>
<db:listitem><db:para>An <db:code>xref</db:code> annotation to create a reference to another part of the content.</db:para></db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Subject Domain</db:term>
<db:listitem><db:para>A <db:code>function</db:code> annotation to identify that a piece of text is the name of a function.</db:para></db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Management Domain</db:term>
<db:listitem><db:para>A conditional annotation to identify a piece of text that may be conditionally included or excluded from output.</db:para></db:listitem>
</db:varlistentry>
</db:variablelist>
<db:para>Different markup systems support structure and annotation in different ways.</db:para>
<db:section>
<db:title>Secondary structures of interpretation</db:title>
<db:para>Under normal circumstance, the structures that constrain the content also constrain its interpretation. But there are cases in which annotations are added to structures to constrain a different interpretation of the content from the one specified by the structure that contains it, and not only of individual fields, but of a structure as a whole.</db:para>
<db:para>Consider these examples of HTML Microformats from Wikipedia<db:footnote><db:para>https://en.wikipedia.org/wiki/Microformat</db:para></db:footnote>. The first example shows an address formatted as a list.</db:para>
<db:programlisting language="HTML">
&lt;ul&gt;
   &lt;li&gt;Joe Doe&lt;/li&gt;
   &lt;li&gt;The Example Company&lt;/li&gt;
   &lt;li&gt;604-555-1234&lt;/li&gt;
   &lt;li&gt;&lt;a href="http://example.com/"&gt;http://example.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</db:programlisting>
<db:para>Here the phrase <db:code>The Example Company</db:code> is contained in <db:code>li</db:code> tags. This is part of a list structure delineated by <db:code>ul</db:code> tags, so the markup is largely structural in the document domain. The <db:code>li</db:code> does not really tell you anything useful about what the content itself is about. It does not tell you anything useful beyond what document structure it belongs to.</db:para>
<db:para>The second example adds hCard microformat markup:</db:para>
<db:programlisting language="HTML">
&lt;ul class="vcard"&gt;
   &lt;li class="fn"&gt;Joe Doe&lt;/li&gt;
   &lt;li class="org"&gt;The Example Company&lt;/li&gt;
   &lt;li class="tel"&gt;604-555-1234&lt;/li&gt;
   &lt;li&gt;&lt;a class="url" href="http://example.com/"&gt;http://example.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</db:programlisting>
<db:para>This example adds subject domain metadata in the form of the class attributes. For example, it says that the phrase <db:code>The Example Company</db:code> is a reference to an organization (<db:code>org</db:code>). This annotation is not modifying or refining the constraint expressed by the <db:code>li</db:code> tag. It is saying something else entirely.</db:para>
<db:para>But this is not just about suggesting a different way of interpreting <db:code>The Example Company</db:code> (as an organization name, as well as as a list item).  There is actually a complex subject domain structure being expressed. Not only is the list item <db:code>The Example Company</db:code> annotated as <db:code>org</db:code>, the list that contains it is annotated as <db:code>vcard</db:code>. The constraint of interpretation provided by <db:code>org</db:code> is actually dependent on it being part of a <db:code>vcard</db:code> structure.</db:para>
<db:para>In other words, the secondary structure created by the annotations in the sample above is equivalent to pure subject domain markup like this:</db:para>
<db:programlisting language="SAM">
vcard:
   fn: Joe Doe
   org: The Example Company
   tel: 604-555-1234
   url: http://example.com/
</db:programlisting>
<db:para>In other words again, the microformats are overlaying a second structure on the list structure. In the world of HTML, this makes sense. HTML needs to be a standardized document domain language so that browsers can display it for human reading. Humans don’t need the vCard annotations to recognize that the content is an address, but algorithms do. So the microformat adds a second, hidden, subject domain structure to the document for readers who are algorithms rather than people.</db:para>
<db:para>Structured writing constrains both the creation and the interpretation of content. In the normal case we expect that the creation of the content would be just as constrained as the interpretation. After all, it is hard to rely on the interpretation of structure if the creation of the structure is not constrained. However in this case the interpretation of the data is more constrained than the creation.</db:para>
<db:para>Authoring our content this way would obviously be inefficient and error prone. But this is only a problem if the content is actually authored in this format. If the content is authored in a format in which its creation is constrained to the same extent as we wish the output to be constrained, it does not actually matter that the resulting output constrains interpretation more than it constrains creation. Our concern as content creators is simply to make sure that any content we produce that promises to abide by a constraint actually does so, whether the format we deliver it in actually imposes that constraint or merely annotates it.</db:para>
<db:para>So, we can confidently produce this information using subject domain markup and then deliver it as HTML with hCard annotation markup using a presentation algorithm something like this (as with all example algorithms in this book, this is pseudocode):</db:para>
<db:programlisting language="pseudo">
match vcard
    create ul
        attribute class = "vcard"
        continue

match fn
    create li
        attribute class = "fn"
        continue

match org
    create li
        attribute class = "org"
        continue

match tel
    create li
        attribute class = "tel"
        continue

match url
    create li
        create a
            attribute class = "url"
            attribute href = contents
            continue
</db:programlisting>
</db:section>
<db:section>
<db:title>Elements vs. attributes</db:title>
<db:para>Sometimes the name of a block is not sufficient to fully describe the constraints it meets. In these cases, we can add additional metadata to a block. Different markup languages do this in different ways. We’ll look as the issue using XML for an example. In XML a block is represented by an element and any additional metadata you add to an element is called an attribute.</db:para>
<db:para>While the need for attributes is clear enough in general, they create lots of question about when it makes sense to add an attribute to an element and when it makes sense to add a nested block containing the same information.</db:para>
<db:para>Consider, for example, this XML element that contains no content but two attributes:</db:para>
<db:programlisting language="xml">
&lt;author-name first="Mark" last="Baker"&gt;
</db:programlisting>
<db:para>the element is named <db:code>author-name</db:code> and it has two attributes named <db:code>first</db:code> and <db:code>last</db:code> that contain my first and last name respectively.</db:para>
<db:para>Why is this marked up like this and not like this:</db:para>
<db:programlisting language="xml">
&lt;author-name&gt;
    &lt;first&gt;Mark&lt;/first&gt;
    &lt;last&gt;Baker&lt;/first&gt;
</db:programlisting>
<db:para>Both these constructs express the same information in a way that clearly constrains how author names are to be written and how the markup of author names is to be interpreted by algorithms.</db:para>
<db:para>Is one of these options correct and the other incorrect? When should you use attributes and when should you use elements?</db:para>
<db:para>Consider our vcard example. It could be written this way, using just elements:</db:para>
<db:programlisting language="XML">
&lt;vcard&gt;
   &lt;fn&gt;Joe Doe&lt;/fn&gt;
   &lt;org&gt;The Example Company&lt;/org&gt;
   &lt;tel&gt;604-555-1234&lt;/tel&gt;
   &lt;url&gt;http://example.com/&lt;/url&gt;
&lt;/vcard&gt;
</db:programlisting>
<db:para>Or it could be written this way, using attributes:</db:para>
<db:programlisting language="XML">
&lt;vcard
   fn="Joe Doe"
   org="The Example Company"
   tel="604-555-1234"
   url="http://example.com/"
/&gt;
</db:programlisting>
<db:para>The first says that <db:code>fn</db:code>, <db:code>org</db:code>, <db:code>tel</db:code>, and <db:code>url</db:code> are independent structures that belong as members to a <db:code>vcard</db:code> structure. The second says that the <db:code>vcard</db:code> structure has a number of data fields -- annotations -- that complete its meaning.</db:para>
<db:para>Does this distinction matter terribly? Both allow you to get at the information you want. Both constrain both the creation and the interpretation of data. There are limits to the version that uses attributes. You can’t have more than one attribute with the same name, whereas you could have more than one member elements of the same name (multiple tel elements for someone with more than one telephone number for instance). Also, XML specifies that attributes are unordered, so can’t restrain either the order in which writers create them or the order in which the parser reports them to a processing application.</db:para>
<db:para>Given this, you may be wondering why people bother with attributes, since you can do the same things with elements and have both more flexibility and more capacity to impose constraints. Yet people continue to use attributes extensively when designing markup languages in XML.  When people create XML document types for representing data, rather than for writing document, they almost always use the attribute format, perhaps because it is slightly less verbose and slightly easier to read, or perhaps because as programmers they are accustomed to representing data as key/value pairs linked with <db:code>=</db:code> signs.</db:para>
<db:para>But for documents it is more complex. To understand why XML even has attributes, and why other languages, such as SAM or reStructuredText, also have similar mechanisms for adding annotations to blocks, we need to go back to the original concept of markup as something written onto a manuscript after the fact. Markup is an addition to the text, not part of it. The content of an element is part of the underlying text. Anything you want to add, therefore, cannot be element content, since that would be adding to the text. Everything else has to be added to element definitions as attributes.</db:para>
<db:para>This view is reinforced by the academic interest in markup as a way to prepare texts for study. Again, here, the text is preexisting and canonical. The markup is external to it and so everything that is external to the original text must be contained in the markup itself (as attributes) and noting that is internal to the original text must be removed or replaced by markup. Thus in this fragment of a Shakerpere play marked up by John Bosek we see that the original text is kept perfectly intact:</db:para>
<db:programlisting language="xml">
&lt;ACT&gt;
&lt;TITLE&gt;ACT I&lt;/TITLE&gt;
&lt;SCENE&gt;
&lt;TITLE&gt;SCENE I. Rousillon. The COUNT's palace.&lt;/TITLE&gt;
&lt;STAGEDIR&gt;
Enter BERTRAM, the COUNTESS of Rousillon, HELENA, and LAFEU, all in black
&lt;/STAGEDIR&gt;
&lt;SPEECH&gt;
&lt;SPEAKER&gt;COUNTESS&lt;/SPEAKER&gt;
&lt;LINE&gt;
In delivering my son from me, I bury a second husband.
&lt;/LINE&gt;
&lt;/SPEECH&gt;
&lt;SPEECH&gt;
&lt;SPEAKER&gt;BERTRAM&lt;/SPEAKER&gt;
&lt;LINE&gt;And I in going, madam, weep o'er my father's death&lt;/LINE&gt;
&lt;LINE&gt;anew: but I must attend his majesty's command, to&lt;/LINE&gt;
&lt;LINE&gt;whom I am now in ward, evermore in subjection.&lt;/LINE&gt;
&lt;/SPEECH&gt;
</db:programlisting>
<db:para>Had this markup employed the normal refactoring of text into markup that we have seen in our discussions of the document domains, then the number and title of scenes would have been factored out so that instead of:</db:para>
<db:programlisting language="xml">
&lt;SCENE&gt;
    &lt;TITLE&gt;SCENE I. Rousillon. The COUNT's palace.&lt;/TITLE&gt;
</db:programlisting>
<db:para>we might have factored out the scene number and the work ‘SCENE’ like this:</db:para>
<db:programlisting language="xml">
&lt;SCENE&gt;
    &lt;TITLE&gt;Rousillon. The COUNT's palace.&lt;/TITLE&gt;
</db:programlisting>
<db:para>Going further, we might have noted that the introduction of a scene is invariable the name of its location, so we might have done this:</db:para>
<db:programlisting language="xml">
&lt;SCENE&gt;
    &lt;LOCATION&gt;Rousillon. The COUNT's palace.&lt;/LOCATION&gt;
</db:programlisting>
<db:para>or even this:</db:para>
<db:programlisting language="xml">
&lt;SCENE location=Rousillon. The COUNT's palace."&gt;
</db:programlisting>
<db:para>And similarly, we might have replaced:</db:para>
<db:programlisting language="xml">
&lt;SPEECH&gt;
    &lt;SPEAKER&gt;BERTRAM&lt;/SPEAKER&gt;
</db:programlisting>
<db:programlisting language="xml">
&lt;SPEECH SPEAKER="BERTRAM"&gt;
</db:programlisting>
<db:para>Making a few changes like this in the markup would leave us with only the words actually spoken by the actors as the “text” of the play and everything else expressed as elements or attributes.</db:para>
<db:para>This actually makes quite a lot of sense, because all of the stage directions and attribution of speakers in a play is actually metadata annotating the speeches of the actors which are the only things the audience is actually supposed to hear.</db:para>
<db:para>So is the right way to markup a play to preserve the original printed text -- which includes all of the playwright’s metadata -- or is it better to separate the playwrights metadata from the speeches which are the ‘real’ play?</db:para>
<db:para>The answers to questions like this need not concern us greatly. The fact that such question exist, however, help us to understand both why a markup language like XML is structured the way it is, and why so many texts are marked up the way they are -- and why so many tagging languages are designed the way they are.</db:para>
<db:para>The way we, as practitioners of structured writing for content quality, settle these matters is by asking ourselves which approach best supports the structured writing algorithms that we want to implement, and always remembering that the reliability of every other algorithm depends on how well the conformance algorithms works, and that the conformance algorithm depends to a large extent on how the authoring algorithm designs for conformance and for functional lucidity.</db:para>
<db:para>In none of this are we in the least concerned about preserving the canonical nature of a preexisting text. There is no preexisting text. We are all about creating new texts. Because of this we have every reason to prefer to use sub-structures rather than annotations on existing structures, to express things like our vCard example. In fact, SAM, which is designed specifically for structured authoring, only supports this format:</db:para>
<db:programlisting language="SAM">
vcard:
   fn: Joe Doe
   org: The Example Company
   tel: 604-555-1234
   url: http://example.com/
</db:programlisting>
<db:para>SAM only supports a very limited set of annotations on blocks, all of which have predefined meetings. You could, in fact, eliminate annotations on blocks altogether, and use child blocks for everything, but I have supported a limited set of common management-domain block annotations in SAM, mostly to improve functional lucidity.</db:para>
<db:para>Support for free-floating annotation in text is another matter. Those you will always need for document-oriented markup and structured writing.</db:para>
<db:para>In summary, when defining the mechanical structure of your structured writing, don’t get hung up on what is text and what is markup. In each domain, text and markup together form a body of constrained content which can be successfully created by an author and successfully processes by one or more algorithms. Only when you resolve the content all the way to the media domain do you finally have to sort our exactly which characters appear in which order and decoration to represent that content to a particular audience. When we choose to create content in the other domains it is precisely because we want to exercise more control over these things, and to use algorithms to help us create and manage them. Whether some idea or constraint is expressed by text of markup in those domains should be based solely on what works best in those domains. (Which is precisely why attempting to do structured writing using a WYSIWYG editor is so counter productive, and why it is so important to ensure the functional lucidity of your markup as markup.)</db:para>
</db:section>
</db:section>
</db:chapter>
