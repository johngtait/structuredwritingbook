<?xml version="1.0"?>
<db:chapter xmlns:db="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:strings="http://exslt.org/strings" version="5.0">
<db:title>Principles of structure</db:title>

<db:section>
<db:title>Names and objects</db:title>
<db:para>Fundamentally, creating a structure for writing means creating boxes for words and giving names to those boxes. It may also involve putting a label on the box with additional information on it. The name and the label on the box tells us something about the words in the box. What kind of things they  tell us obviously depends on the domain we are dealing with.</db:para>
<db:para>In the media domain they tell us what something looks like, either directly (an actual format description) or by reference (the name of a style). In the document domain they tell us what part of a document the words are. In the management domain, they tell us what to do with the content under different circumstances. In the subject domain they tell us what the subject matter of the words is.</db:para>
<db:para>The box does not only have to have information from one domain on it. It is not uncommon to have a box with a name in the document domain and a label in the management domain or the subject domain.</db:para>
<db:para>The names and labels on the boxes tell us what constraints the words in the box obey, or, as we are writing, what constraints the words we write are expected to obey. Algorithms use the names and the labels to process the content, assuming that they accurately reflect the constraints.</db:para>
<db:para>For structured writing to work, therefore, it is essential that everyone involved understand and agrees on what the names and labels mean. If we don’t the names and labels will not accurately reflect the constraints we expect, and the whole content quality project falls apart and the algorithms stop working.</db:para>
<db:para>Confusion and disagreement about what the names and labels of a particular language mean are not uncommon. Large document domain languages like DocBook and DITA have large vocabularies, and many of the names they offer are quite abstract. Questions about the right way to tag certain passages are common in the communities around these languages, and opinions can vary considerably in some cases. These disagreements don’t only affect low-level structures. In DITA, for example, it is common to debate if a topic is a reference or a task, while some writers choose to use only generic topics because they don’t feel the models of the task, concept, and reference topics fit the content they are creating.</db:para>
<db:para>Having precise definition of terms is important, therefor, in developing a structured writing language. But it is equally important that the language be lucid. The authoring algorithm requires that creating structure should not come at the detriment of the writing itself. This requirement is not met if writers are constantly having to puzzle out or debate the right way to mark something up.</db:para>
<db:para>In the software world, meta models and abstraction are powerful tools for modeling systems. They provide clear high-level rules for the design of specific structures and create opportunities to reuse code for objects with a shared base model. But these tools can also lead to very abstract naming schemes and even to abstract structures. (The way the boxes are organized can be lucid or opaque to the author just as much as the way they are named and labeled.)</db:para>
<db:para>Clear concrete and specific names, and an organization of boxes that intuitively fits the subject matter, all make for easier authoring. There is no reason that such structures cannot be derived from abstract models, or that they cannot be mapped to abstract models after the fact, but it is important not to let the abstractions intrude too munch into the world of the author.</db:para>
</db:section>
<db:section>
<db:title>Functional lucidity</db:title>
<db:para>Successful authoring depends on a property I am going to call “functional lucidity”. Functional lucidity means the way that you actually use language when you are writing, which is to say the way that you use language when you are in the throes of figuring out what you want to say and how you want to say it. If you are asked to add markup to your content as you write, if you are asked to shape your content according to the constraints that a structured writing language dictates, then the lucidity of that markup and the structures it defines are vital to your success. The names of the structures, the order in which they occur should spring into your mind as readily (if not more so) that the words and phrases and ideas you are trying to record on paper.</db:para>
<db:para>As anyone who has struggled to write even a paragraph in a language they are only beginning to learn can attest, writing in a language in which you are not fluent is painful. The effort of finding words and correct grammatical structures takes all of the attention that should be reserved for what you are trying to say. Writing in a tagging language where the tags don’t make intuitive sense, when the structures don’t seem to fit the thoughts you are trying to express, is very much like this. Lucidity is essential to avoid having the markup absorb all of the attention that should be focused on the content.</db:para>
<db:para>Functional lucidity is not an absolute property, of course. What is lucid for one writer may be opaque to another. In particular, professional technical writers who have been used to writing in structured document domain templates in applications like FrameMaker may find a markup language like DocBook functionally lucid, whereas someone not used to thinking in these terms would find it difficult and distracting. On the other hand, those writers used to FrameMaker often find DITA’s structure difficult to get used to because they do not find its approach to topic lucid. To still others it seems very natural.</db:para>
<db:para>But while different writers may have different degrees of experience and familiarity with abstract document structures, all writers should have familiarity with the subject matter they are writing about. Thus a well-designed subject domain language tends naturally have functional lucidity for everyone who is likely to use it. (Though writers can sometimes disagree about what needs to be said on a subject and how it should be said.)</db:para>
</db:section>
<db:section>
<db:title>Functional lucidity and a layer architecture</db:title>
<db:para>A layered architecture can be very valuable in providing functional lucidity to a variety of authors. To build a publishing system that is capable of managing a wide variety of content, it is often necessary to create a lot of abstractions in your document markup. If you ask authors to write content directly in those abstract structures you may find that they struggle with the abstraction, and with the complexity and the range of options that go with a language that is designed to handle so many different source and publication types. Providing a set of separate authoring languages (perhaps simplified document domain, perhaps subject-specific subject domain), can deliver functionally lucid authoring languages to different types of authors, greatly improving the authoring process.</db:para>
<db:para>At the same time, the simplicity of these special-purpose languages can allow you to be much clearer about what the names and labels mean in the context of that language. Providing and agreeing on precise meanings for terms is much easier the smaller the group of people you are dealing with and the smaller the range of subject matter you are addressing. We have relatively limited vocabularies and we reuse words and phrases between different domain of discourse all the time. Agreeing on what a term means across all domains of discourse is virtually impossible. Agreeing on what it means in a limited domain with a limited audience is much easier.</db:para>
<db:para>For purposes of rolling up content from many domains into one larger content set, you will definitely have situations in which the same names and labels are used to mean different things. But this is not a problem as long as you know which domain each piece of content comes from. In other words, every tagging language defines a set of names and labels for content in the context of a particular namespace. (Namespaces are an explicit concept in tagging languages like XML and SAM.)</db:para>
<db:para>Placing names into namespaces does not magically resolve all disagreements about what to call things in a wider information space. But it does allow for an <annotation type="role">information architect</annotation> to choose an definitive mapping of names from each namespace into the enterprise namespace. The results may still be disputable, but at least they will be consistent. And if they are disputed, and a different mapping is accepted, only the mapping has to change to put the new system into effect. As long as each pieces of content is tagged correctly according to the rules of its local namespace, it does not have to change just because the rules of the enterprise namespace change.</db:para>
<db:para>Achieving agreement (and, what is really more important, functional lucidity) within a local domain is easier in some domains than others. The media domain is highly concrete, so there really is not much room for disagreement there. Styles, though, are often given names from the document domain, as they are really a step into the document domain, and this can lead to disagreements because of the more abstract nature of the document domain.</db:para>
<db:para>The document domain is the most difficult place to achieve either agreement or functional lucidity. (By functional lucidity, I mean that the language seems easy to use and obvious when you are actually writing as opposed to when you are attempting to hammer out agreement in a committee room.) The document domain is inherently an abstract place, and there are always different ways to abstract from the concrete reality of web pages and books, particularly because of how different hypertext media domains are from paper media domains and the difficulty of truly abstracting beyond those differences. Thus you will frequently hear argument between the proponents of various document domain languages about the correctness and usability of their choices. For instance, partisans of Markdown may praise its functional lucidity (it is very easy to write in) which partisans of ReStructuredText may praise its greater abstraction and range of application.</db:para>
<db:para>The management domain is quite concrete, like the media domain, but more arbitrary. It consists either of commands or of management metadata, both of which are particular to a specific management system. Difficulties here are likely to be more about the management processes to be implemented rather than the correct naming of things.</db:para>
</db:section>
<db:section>
<db:title>Linear vs Hierarchical Structure</db:title>
<db:para>All the examples of markup that we have looked at to this point have been hierarchical in nature. That is, the markup starts at a single root structure and consists of other structured nested neatly inside that root.</db:para>
<db:para>This is not the only way to do markup. Older markup systems, in particular media domain systems intended principally for typesetting, were linear in nature. Such systems allowed users to turn on and off feature independently.</db:para>
<db:para>For example, the word processor WordPerfect takes what it calls a “streaming approach” to document structure in which features are turned on and remain on until they are turned off. Thus in Word Perfect, your could do this, with bold starting and then italic starting, the bold stopping and finally italic stopping:</db:para>
<db:programlisting>
This text is [B&gt;bold, [I&gt;this is bold and italic,&lt;B] and this is just italic&lt;I].
</db:programlisting>
<db:para>This would print as:</db:para>
<db:blockquote>
<db:para>This text is <db:emphasis role="bold">bold,</db:emphasis> <db:emphasis role="bold"><db:emphasis>this is bold and italic,</db:emphasis></db:emphasis> <db:emphasis>and this is just italic</db:emphasis>.</db:para>
</db:blockquote>
<db:para>This overlapping of structures is illegal in XML, so in HTML, for instance, you can’t do this:</db:para>
<db:programlisting>
&lt;p&gt;This text is &lt;b&gt;bold, &lt;i&gt;this is bold and italic,&lt;/b&gt; and this is just italic&lt;/i&gt;.&lt;/p&gt;
</db:programlisting>
<db:para>You have to do this, keeping everything nested with no overlapping structures:</db:para>
<db:programlisting>
&lt;p&gt;This text is &lt;b&gt;bold,&lt;/b&gt; &lt;i&gt;&lt;b&gt;this is bold and italic,&lt;/b&gt;&lt;/i&gt; &lt;i&gt;and this is just italic&lt;/i&gt;.&lt;/p&gt;
</db:programlisting>
<db:para>There is more to this question than trivial examples like this. In the academic study of text markup, where markup is used not for the preparation of documents but to mark them up for academic study, there is an debate about whether the hierarchical structure of XML-based languages actually reflects the real structure of the text.</db:para>
<db:para>We noted earlier that in HTML, you have six levels of heading (<db:code>h1</db:code> through <db:code>h6</db:code>) whereas in DocBook you have only <db:code>title</db:code>. In DocBook, you can divide a document up into sections and nest sections inside sections. You can then print the titles of sections inside sections in a smaller font that the titles of first level sections. You get to have differences in heading size without having six different heading tags.</db:para>
<db:para>But the DocBook model assumes that the real structure of a document is actually a hierarchy of nested sections and that the size of titles announces the steps up and down that hierarchical tree. HTML makes no such assumption. It will let you put a <db:code>&lt;h4&gt;</db:code> immediately after an <db:code>&lt;h1&gt;</db:code> if you want to. It treats document as essentially flat structure punctuated by headings of various sizes as and where appropriate. (HTML syntax follows XML’s nested model, but it simply does not define document structures in a highly nested fashion like DocBook. Until HTML, HTLM did not even have a <db:code>section</db:code> element.)</db:para>
<db:para>Which model of a document is correct? You can think of a document as being organized hierarchically, with major ideas expressed in sections, sub-ideas support the major ideas in subsections, etc. There are doubtless documents that fit that model. But you can also think of documents as being more like a journey in which headings function more like road signs. A city gets a big sign, a hamlet a small sign, and a town a medium sign. But the town is not inside the city, not the hamlet inside the town, and there is no guarantee that on leaving the city you will come to the town before you come to a hamlet.</db:para>
<db:blockquote>
<db:olink targetptr="Flynn2009"/><db:para>The classical theory, derived from computer science and graph theory, is that the document is a hierarchical tree (actually inverted: a root-system) and that all necessary actions can be seen in terms of navigation around the tree, and of insertion into and withdrawal from the the nodes which form the branches and leaves.</db:para>
<db:para>The conventional writer, however — and we expressly exclude the markup expert, as well as the experienced technical authors who responded to the survey — is by repute probably only marginally aware of this tree; but we have been unable to measure this at present. In this view, the document is seen as a continuous linear narrative, broken into successive divisions along semantic lines, and interspersed with explanatory material in the form of figures, tables, lists, and their derivatives.</db:para>
</db:blockquote>
<db:para>Today, very few markup languages take the streaming approach of WordPerfect. The problem with it is that when you want to deal with any structure that is naturally hierarchical, the ability to start and stop structures independently just gets in the way and makes things hard to handle. But even with markup languages that are syntactically hierarchical, like XML, you can still define markup languages that are largely flat (like HTML) or more hierarchical (like DocBook).</db:para>
<db:para>This is a concern mainly in the design of document domain languages. The structure of media domain languages is largely dictated by the shape and relationship of the media-domain object they are modeling. In the subject domain, we have abstracted content out of strict document order. Hierarchy in the subject domain tend to match the hierarchy of relationship in the subject matter itself. (Though this is not universal. Addresses, for instance, which are based on hierarchal locations, are modeled are flat ordered lists. The order reflect the hierarchy, but the nesting of city inside country and of street within city is not reflected in the structure of an address record.) In the document domain, however, it is a real concern. The document domain consists of abstractions of document structures and the nature of their relationship to the structure of thought in the text is not obvious.</db:para>
<db:para>In the document domain, however, you have to make a choice between enforcing a hierarchical model of a document or allowing a more linear one. You will almost certainly do this in the context of hierarchical syntax. You probably don’t want to go the WordPerfect route of separate on and off commands. But you do need to decide if you are going to allow arbitrary heading levels. Or, to put it another way, to model a document as a hierarchy of sections with each section having a title, or a single flow of text randomly interspersed with headings, or something in between.</db:para>
<db:para>The something in between option can seem appealing but can you can end up with something really unconstrained, meaning that it is difficult to write reliable algorithms to process it. Here is the kind of issues you can run into:</db:para>
<db:para>Is a list part of the paragraph in which it occurs? Some markup languages, such as Markdown and SAM, take the view that lists are separate blocks that come after a preceding paragraph. But DITA, DocBook, and HTML will all let you place a list either inside or outside a paragraph:</db:para>
<db:programlisting>
&lt;p&gt; The primary colors are:
    &lt;ul&gt;
        &lt;li&gt;Red&lt;/li&gt;
        &lt;li&gt;Blue&lt;/li&gt;
        &lt;li&gt;Yellow&lt;/li&gt;
    &lt;/ul&gt;
&lt;/p&gt;

&lt;p&gt; Their complementary colors are:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Green&lt;/li&gt;
    &lt;li&gt;Orange&lt;/li&gt;
    &lt;li&gt;Purple&lt;/li&gt;
&lt;/ul&gt;
</db:programlisting>
<db:para>The interesting question here is whether these two structures should be formatted differently for output. Should the list that in inside the paragraph be indented, which the one that comes afterwards be printed flush left?</db:para>
<db:para>The default for HTML, at least in the browsers I tried it on (Edge, Internet Explorer, and Chrome) is that both are indented by the same amount, but of course you could change this with CSS and DocBook and DITA processors can do what they like.</db:para>
<db:para>But would it be a good idea to make a distinction between the two? Only if authors clearly understood the difference between the two and clearly know when they were choosing one or the other. (If they are writing in a visual editing view of an XML editor, then they almost certainly won’t know the difference.)</db:para>
<db:para>If you are designing your own markup language, do you want to allow both these forms? Probably not. The more permutations of structure your markup language allows, the more work it will be to write the algorithms to process it. Some allowance may be made for ease of authoring, if you wish, but it may be better to wait for authors to complain about a restriction like this than to build in all the possible variations in advance. (This is also a problem that is more likely to occur in an abstract language like XML than in a concrete language like Markdown or SAM, where the choice is baked into the syntax and the author does not have a choice to make.</db:para>
</db:section>
<db:section>
<db:title>Content in two dimensions</db:title>
<db:para>The notion of separating content from formatting works quite well when the content is a string of words. A string of words has only one dimension: length. A printed string, of course, has two dimensions: length and height, since each letter had a height and a width. (The depth of the ink is irrelevant for this purpose.) But the height and the width of letters is a pure media-domain concern. When we separate content from formatting, we separate the font from the character and are left with a string of characters whose length is measured not in inches but in character count. And this works very nicely because unless we get silly with the size and shape of the viewport that we flow the characters into, and a rendering algorithm can flow characters onto a page with reasonable results.</db:para>
<db:para>There can, indeed, be some issues with such rendering algorithms when it comes to hyphenation, widows and orphans, and the location of titles relative to the text, but with the appropriate document domain markup to delineate basic document structures, algorithms can handle these issues reasonably well. (They can’t edit the text itself to make a line break work better, as some human typesetters will do, but that kind of manipulation is rarely needed.)</db:para>
<db:para>But when it comes to content that has two dimensions, things get more difficult. The main problem cases are:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>tables</db:para>
</db:listitem>
<db:listitem>
<db:para>graphics and other media</db:para>
</db:listitem>
<db:listitem>
<db:para>preformatted text, such as program listings, that have meaningful line breaks</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<bibliography>
<entry xml:id="Flynn2009">
<db:para>Flynn, Peter. “Why writers don’t use XML: The usability of editing software for structured documents.” Presented at Balisage: The Markup Conference 2009, Montréal, Canada, August 11 - 14, 2009. In Proceedings of Balisage: The Markup Conference 2009. Balisage Series on Markup Technologies, vol. 3 (2009). doi:10.4242/BalisageVol3.Flynn01.</db:para>
</entry>
</bibliography>
</db:chapter>
