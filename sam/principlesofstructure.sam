chapter: Principles of structure

    <<<(annotations.sam)
    
    Structured writing it an attempt to improve the quality of written work. It's intended outcome is a piece of writing that works well for its intended purpose. (In contrast, as noted in the foreword, to certain academic or archival use of textual markup where the intent is to represent aspects of content to downstream algorithms regardless of its quality or usefulness.) All writing has structure, from the basic grammatic structures that make sentences comprehensible to the larger rhetorical structures the make information accessible or frame an argument cogently and persuasively. 
    
    While structured writing is not an {ontology}(concept) and does not attempt to express the actual information in a piece of writing, it does aim to support the creation of an effective rhetorical structure, to the extend this is feasible. There is, therefore, a relationship between the rhetorical structure and mechanical structured created by markup. 
    
    section: Rhetorical structure
	
		The rhetorical structure of a piece of content is how it tells its story. For many types of stories, the optimal rhetorical structure is quite consistent and often well known. In other cases, the best rhetorical structure can be determined both by a careful consideration of what needs to be said and by experience and testing with readers. Content quality is greatly enhanced when the rhetorical structure is well defined and followed consistently. Also, a well defined rhetorical structured provide an effective baseline against which to compare and measure proposed improvements. Using an explicit predefined rhetorical structure helps enhance and maintain content quality.
        
        In the {subject domain chapter}[#chapter.subject-domain] we looked at how structured writing in the subject domain can capture the rhetorical structure of a recipe in various ways to serve various business purposes.
        
        A recipe is a fairly well known type of information. The various parts can be organized and presented in different ways, but most people recognize a recipe when they see one. This makes a recipe an example of what I call a {topic pattern}(concept). Any specific markup language that you define for creating recipes would be called a recipe {topic type}. Different organizations may create different recipe topic types to impose constraints on the recipe format that are specific to their business needs. Each of these recipe topic types is an interpretation of the recipe topic pattern. The topic patterns is an example of rhetorical structure; the topic type is an example of mechanical structure. 
        
        Since the point of structured writing it to improve content quality, the definition of topic types should begin with an exploration of topic patterns.  
        
        In some cases, topic patterns are immediately obvious because they have a visual shape. The various components of a recipe just happen to look physically different on a page (which is why the recipe is the most popular structured writing example). There is the picture, the introduction, which is a block, the ingredients, which are a list, and the steps, which are a numbered list. The recipe topic patters is visually distinctive even without looking at a word of the text. 
        
        However, topic patterns are not about elements that are visually distinct. They are about the rhetorical structure of the content. They are about the different types of information that are required, they way they are expressed, and the order they are presented in. There may be considerable variation in the second two properties. Whether we would count these variations are options within one topic pattern or as defining different topic patterns should probably depend on their effect. Any organization and means of expression that has the same rhetorical affect we can reasonable count as the same pattern. 

        (Naturally, variations in the topic pattern, though legitimate, make it harder to authors, to validate what is written, and to format and publish it consistently. For this reason, topic types usually constrain the topic pattern significantly, insisting on one particular variation as the standard approach.) 

        When you look at a page that appears to be just a sequence of paragraph with perhaps some subheadings thrown it, it is easy to assume that there is not particular topic pattern present. But this is not necessarily true at all. It a consistent set of information is being presented for a particular purpose, and we can find (or reasonably imagine) that same set of information being assembled for the same purpose, to describe another object of the same type, then we have a topic pattern. And where we have a topic pattern, we can define a topic type. 
        
        This is not to say that once you define a topic type, you will be able to take the markup that you define and wrap it around every existing example of the topic pattern without changing a word. (Again, the point of structured writing is to improve content, not to faithfully represent its current state.) Topic types are more precise than topic patterns and existing unstructured topics that follow a topic pattern will a almost always have to be edited to fit a topic type. 
        
        What you will find when you start to move content that meets a topic pattern into a defined topic type is that a lot of the content does not fit the topic pattern particularly well. You will find some instances that only partially fit, but which omit information commonly found in the pattern (and perhaps required in the type). You will find that some instance contain information not found in most instance of the pattern, and not supported by the type. You will find information not expressed in the way that the topic type expects. 
        
        These discoveries mean one of four things:
        
        * The discernment of topic patterns in incorrect and you actually have content from a different pattern.
        
        * The definition of the topic type is incorrect and needs to be modified to more correctly reflect the topic pattern. 
        
        * The content is a variation of the topic pattern that is deliberately not supported by the topic type and needs to be edited to fit. 
        
        * The content is deficient and needs to be upgraded so that it fulfills it purpose correctly, as defined by the topic type. 

        Interpreting the mismatch between existing content and the topic type can make or break your entire structured writing project. There is a huge temptation to treat existing text as canonical and try to shape the model to fit it. But as we have stressed several time, the purpose of structured writing it not to represent existing texts, but to make content better. If your current content processed are so good that all your existing content will fit your new structures perfectly, then you are not realizing any gain in content quality and you are wasting your time. Finding content that does not fit the models is not a sign that the models are broken, but that the process is working. 
        
        This does not mean that the models never need to be changed. But it does mean that you change the models to match the things you discover about the best rhetorical structured for your content to achieve your business goals, not to make your existing content, or even the new content that authors want to write, fit the model. 
        
        This does mean that applying structure to your existing content is not a trivial or mechanical task. The purpose, after all, is to improve the quality of the existing content, and that is going to mean additional research and writing work to bring the content up to standard. 
        
        (Let's make this distinction clear: people often convert content from one file format to another, including for binary formats to markup formats. This is a mechanical process, though one that may require some cleanup. It does not, in itself, impose any additional constraints on the content. It merely changes the syntax that expresses those constraints. This kind of conversion is often possible to {document domain} formats like DITA and DocBook. This does not mean that the resulting DocBook or DITA output will correctly express the full range of constraints that these formats are capable of. You can also do a reliable transformation from one subject domain format to another (say from a relational database to XML markup). But your cannot do a reliable mechanical transformation of document domain content to the subject domain. The subject domain imposes constraints that may be expressed rhetorically in the document domain, but are not expressed mechanically. These conversions are writing tasks, not something than can be done mechanically.)
        
        section: Rhetorical metamodels
        
            There are different ways of thinking about the rhetorical structure of content. Above, I describe the topic pattern of a recipe as consisting of a picture, an introduction, ingredients, and a list of preparation steps. This is a {subject domain} pattern for a recipe. 

            However, we could notice that there are a great many other type of information with a similar pattern. For instance, a knitting pattern has a very similar pattern. There is usually a picture of the garment you will be knitting, an introduction describing the project, a list of the yarns and needles you will require, and a list of steps for knitting and assembling the pieces. Lots of other things look similar. Instructions for assembling flat pack furniture, for example, or planting flowers in your garden. 

            None of these things are the same topic pattern. You would not confuse a recipe with a knitting pattern. And each of them can have specific information fields that would make no sense for the others. A pot roast will never have washing instructions. A flat pack bookcase will never have a wine match. Nonetheless, they all have the basic pattern of picture, description, list of stuff you need, steps to complete. 

            This is what we might call a meta-pattern. It is pattern not based on seeing similarities between texts, but on seeing similarities in the patterns of texts. The meta pattern is not useful for creating content directly, but it can potentially provide hints that help us develop individual topic patterns. 

            Not only are there meta-patterns for topics, like the make-thing-out-of-stuff meta pattern described above, there are also meta patterns for the different types of information that go into a meta pattern, such as the picture, description, list of stuff you need, and steps to complete. These are sometimes called "information types" (a confusing term, since text at any scale expresses information).
            
            Two notable examples of these information type meta patterns are found in {Information Mapping}(method) and {DITA}. Information Mapping proposes that document are composed of just six information types: procedure, process, principle, concept, structure, fact. Document are then constructed of some arrangement of information blocks of one of these six types, which it calls a map. 
            
            In other words, Information Mapping proposes that a topic pattern is always composed of some combination of these information types. 
            
            {DITA} proposes something similar, but it proposes (or originally proposed) just three types: concept, task, and reference, which, confusingly, it calls topic types. Like information mapping, DITA assembles documents out of these topic (information) types using a map. 
            
            In DITA terms, then, our recipe topic pattern would consist of one concept topic (the introduction), one reference topic (the list of ingredients), and one task topic (the preparation steps). And our make-thing-out-of-stuff meta-pattern would similarly consist of one concept topic (description), one reference topic (list of stuff you need), and one task topic (steps to complete). (DITA's information model does not include pictures. It just provides a mechanism for including them.)
            
            What neither DITA nor Information Mapping provide is any way to model the larger recipe pattern. DITA will let you write a map to combine a concept topic containing an introduction (which presumably is where you would include the picture), a reference topic containing a list of ingredients, and a task topic containing preparation instructions. But it does not give you a way to specify that a recipe topic consists of one concept topic, one reference topic, and one task topic. In other words, DITA does not provide any way to define larger types or the overall rhetorical structure of documents.
            
          
            What {DITA} does do is provide a way to specify a concrete instance type of any of its meta-types. The list of ingredients in a recipe is an instance of the meta-pattern list of stuff your need in the make-thing-out-of-stuff meta-pattern. But a list of ingredients has a specific structure that is not the same as the list of pieces in a flat-pack furniture box, for instance. It consists of an ingredient name, a quantity, and a unit of measure. The unit of measure is vital in an ingredient listing because not all ingredients are quantified in the same way. You don't measure eggs the same way you measure flour, for instance. 
            
            To express this constraint, DITA will let you specialize the reference topic type to create a list-of-ingredients topic type that imposes (and records) this constraint. You could then construct a recipe using a introduction-to-recipe topic (a specialization of concept), a list-of-ingredients topic, and a preparation steps topic (a specialization of task). However, it still would not give you a way to specify that a recipe consists of these three topic types in this order. 
            
            Actually, it is possible to define a recipe topic types in DITA, but this involves having a different idea about how atomic the basic DITA topic types are. Some DITA practitioners might say that a recipe is not a map made up of three information types, but a single task topic. In this view, a task topic is much more than what Information Mapping would call a procedure. It allows for the introduction of a task, a list of requirements, and the procedure steps all within the definition of a single topic. I have asked a number of DITA practitioners how a recipe should be modeled in DITA and have received both answers from multiple people. 
            
            One of the key tensions in DITA content modeling has to do with reuse. DITA topics are not only units of information typing, they are units of reuse. This approach in which a recipe is a single topic leaves you with fewer larger units of content, which makes individual topics harder to reuse. In practice, it seems that different DITA users make different decisions about how atomic their topic types should be, based on their business needs. This is no doubt a practical way to approach things, but it suggests that the meta model is not strongly influencing everyday practice.  
            
            This, in turn, suggests that the idea of basing structured writing structures on meta models is a difficult one to put into practice in a transparent way. It is not clear that attempting to define or use meta models in the development of content structures has any obvious benefits over defining concrete models directly based on an observation of the types of information that people need.
            
            The fact that neither Information Mapping nor DITA provides any kind of larger scale meta model for describing large content structures that correspond to the rhetorical structure of larger scale content also suggests that it is not particularly helpful in support the goal of structured writing to improve the quality of content. 
            
            For this reason, I am not planning to talk about meta models for content any further in this book. I will stick to describing concrete models for particular purposes. This does not preclude the development of useful meta models in the future. In fact, the clear definition of working concrete models is probably a necessary first step towards any such development. 

            Finally we should note that some people believe that meta models of a still larger scale are possible and could be of benefit in content management and the definition of content sets. These efforts are interesting, but I regard them as out of scope for this book, at least until they demonstrate a clear benefit to more local information design. 

    section: Names and objects
        Fundamentally, creating a structure for writing means creating boxes for words and giving names to those boxes. It may also involve putting a label on the box with additional information on it. The name and the label on the box tells us something about the words in the box. What kind of things they  tell us obviously depends on the domain we are dealing with. 
        
        In the {media domain} they tell us what something looks like, either directly (an actual format description) or by reference (the name of a style). In the {document domain} they tell us what part of a document the words are. In the {management domain}, they tell us what to do with the content under different circumstances. In the {subject domain} they tell us what the subject matter of the words is. 
        
        The box does not only have to have information from one domain on it. It is not uncommon to have a box with a name in the document domain and a label in the management domain or the subject domain. 
        
        The names and labels on the boxes tell us what constraints the words in the box obey, or, as we are writing, what constraints the words we write are expected to obey. Algorithms use the names and the labels to process the content, assuming that they accurately reflect the constraints. 
        
        For structured writing to work, therefore, it is essential that everyone involved understand and agrees on what the names and labels mean. If we don't the names and labels will not accurately reflect the constraints we expect, and the whole content quality project falls apart and the algorithms stop working. 
        
        Confusion and disagreement about what the names and labels of a particular language mean are not uncommon. Large document domain languages like DocBook and DITA have large vocabularies, and many of the names they offer are quite abstract. Questions about the right way to tag certain passages are common in the communities around these languages, and opinions can vary considerably in some cases. These disagreements don't only affect low-level structures. In DITA, for example, it is common to debate if a topic is a reference or a task, while some writers choose to use only generic topics because they don't feel the models of the task, concept, and reference topics fit the content they are creating. 
        
        Having precise definition of terms is important, therefor, in developing a structured writing language. But it is equally important that the language be lucid. The {authoring algorithm} requires that creating structure should not come at the detriment of the writing itself. This requirement is not met if writers are constantly having to puzzle out or debate the right way to mark something up. 
        
        In the software world, meta models and abstraction are powerful tools for modeling systems. They provide clear high-level rules for the design of specific structures and create opportunities to reuse code for objects with a shared base model. But these tools can also lead to very abstract naming schemes and even to abstract structures. (The way the boxes are organized can be lucid or opaque to the author just as much as the way they are named and labeled.) 
        
        Clear concrete and specific names, and an organization of boxes that intuitively fits the subject matter, all make for easier authoring. There is no reason that such structures cannot be derived from abstract models, or that they cannot be mapped to abstract models after the fact, but it is important not to let the abstractions intrude too munch into the world of the author. 
        
    
    section: Linear vs Hierarchical Structure
    
        All the examples of markup that we have looked at to this point have been hierarchical in nature. That is, the markup starts at a single root structure and consists of other structured nested neatly inside that root. 
        
        This is not the only way to do markup. Older markup systems, in particular media domain systems intended principally for typesetting, were linear in nature. Such systems allowed users to turn on and off feature independently. 
        
        For example, the word processor WordPerfect takes what it calls a "streaming approach" to document structure in which features are turned on and remain on until they are turned off. Thus in Word Perfect, your could do this, with bold starting and then italic starting, the bold stopping and finally italic stopping:
        
        ```
            This text is [B>bold, [I>this is bold and italic,<B] and this is just italic<I].
            
        This would print as:
        
        """
            This text is {bold,}(bold) {this is bold and italic,}(bold)(italic) {and this is just italic}(italic). 
            
        This overlapping of structures is illegal in XML, so in HTML, for instance, you can't do this:
        
        ```
            <p>This text is <b>bold, <i>this is bold and italic,</b> and this is just italic</i>.</p>
            
        You have to do this, keeping everything nested with no overlapping structures:
        
        ```
            <p>This text is <b>bold,</b> <i><b>this is bold and italic,</b></i> <i>and this is just italic</i>.</p>
            
        There is more to this question than trivial examples like this. In the academic study of text markup, where markup is used not for the preparation of documents but to mark them up for academic study, there is an debate about whether the hierarchical structure of XML-based languages actually reflects the real structure of the text. 
        
        We noted earlier that in HTML, you have six levels of heading (`h1` through `h6`) whereas in DocBook you have only `title`. In DocBook, you can divide a document up into sections and nest sections inside sections. You can then print the titles of sections inside sections in a smaller font that the titles of first level sections. You get to have differences in heading size without having six different heading tags. 
        
        But the DocBook model assumes that the real structure of a document is actually a hierarchy of nested sections and that the size of titles announces the steps up and down that hierarchical tree. HTML makes no such assumption. It will let you put a `<h4>` immediately after an `<h1>` if you want to. It treats document as essentially flat structure punctuated by headings of various sizes as and where appropriate. (HTML syntax follows XML's nested model, but it simply does not define document structures in a highly nested fashion like DocBook. Until HTML, HTLM did not even have a `section` element.)
        
        Which model of a document is correct? You can think of a document as being organized hierarchically, with major ideas expressed in sections, sub-ideas support the major ideas in subsections, etc. There are doubtless documents that fit that model. But you can also think of documents as being more like a journey in which headings function more like road signs. A city gets a big sign, a hamlet a small sign, and a town a medium sign. But the town is not inside the city, not the hamlet inside the town, and there is no guarantee that on leaving the city you will come to the town before you come to a hamlet.   
        
        """[#Flynn2009]
            The classical theory, derived from computer science and graph theory, is that the document is a hierarchical tree (actually inverted: a root-system) and that all necessary actions can be seen in terms of navigation around the tree, and of insertion into and withdrawal from the the nodes which form the branches and leaves.
            
            The conventional writer, however — and we expressly exclude the markup expert, as well as the experienced technical authors who responded to the survey — is by repute probably only marginally aware of this tree; but we have been unable to measure this at present. In this view, the document is seen as a continuous linear narrative, broken into successive divisions along semantic lines, and interspersed with explanatory material in the form of figures, tables, lists, and their derivatives. 

        
        Today, very few markup languages take the streaming approach of WordPerfect. The problem with it is that when you want to deal with any structure that is naturally hierarchical, the ability to start and stop structures independently just gets in the way and makes things hard to handle. But even with markup languages that are syntactically hierarchical, like XML, you can still define markup languages that are largely flat (like HTML) or more hierarchical (like DocBook). 
        
        This is a concern mainly in the design of {document domain} languages. The structure of media domain languages is largely dictated by the shape and relationship of the media-domain object they are modeling. In the subject domain, we have abstracted content out of strict document order. Hierarchy in the subject domain tend to match the hierarchy of relationship in the subject matter itself. (Though this is not universal. Addresses, for instance, which are based on hierarchal locations, are modeled are flat ordered lists. The order reflect the hierarchy, but the nesting of city inside country and of street within city is not reflected in the structure of an address record.) In the document domain, however, it is a real concern. The document domain consists of abstractions of document structures and the nature of their relationship to the structure of thought in the text is not obvious. 
        
        In the document domain, however, you have to make a choice between enforcing a hierarchical model of a document or allowing a more linear one. You will almost certainly do this in the context of hierarchical syntax. You probably don't want to go the WordPerfect route of separate on and off commands. But you do need to decide if you are going to allow arbitrary heading levels. Or, to put it another way, to model a document as a hierarchy of sections with each section having a title, or a single flow of text randomly interspersed with headings, or something in between.

        The something in between option can seem appealing but can you can end up with something really unconstrained, meaning that it is difficult to write reliable algorithms to process it. Here is the kind of issues you can run into:
        
        Is a list part of the paragraph in which it occurs? Some markup languages, such as Markdown and SAM, take the view that lists are separate blocks that come after a preceding paragraph. But DITA, DocBook, and HTML will all let you place a list either inside or outside a paragraph:
        
        ```
            <p> The primary colors are:
                <ul>
                    <li>Red</li>
                    <li>Blue</li>
                    <li>Yellow</li>
                </ul>
            </p>
            
            <p> Their complementary colors are:</p>
            <ul>
                <li>Green</li>
                <li>Orange</li>
                <li>Purple</li>
            </ul>
            
        The interesting question here is whether these two structures should be formatted differently for output. Should the list that in inside the paragraph be indented, which the one that comes afterwards be printed flush left? 
        
        The default for HTML, at least in the browsers I tried it on (Edge, Internet Explorer, and Chrome) is that both are indented by the same amount, but of course you could change this with CSS and DocBook and DITA processors can do what they like. 
        
        But would it be a good idea to make a distinction between the two? Only if authors clearly understood the difference between the two and clearly know when they were choosing one or the other. (If they are writing in a visual editing view of an XML editor, then they almost certainly won't know the difference.)
        
        If you are designing your own markup language, do you want to allow both these forms? Probably not. The more permutations of structure your markup language allows, the more work it will be to write the algorithms to process it. Some allowance may be made for ease of authoring, if you wish, but it may be better to wait for authors to complain about a restriction like this than to build in all the possible variations in advance. (This is also a problem that is more likely to occur in an {abstract language} like {XML} than in a concrete language like {Markdown} or {SAM}, where the choice is baked into the syntax and the author does not have a choice to make.
        
    section: Content in two dimensions
    
        The notion of separating content from formatting works quite well when the content is a string of words. A string of words has only one dimension: length. A printed string, of course, has two dimensions: length and height, since each letter had a height and a width. (The depth of the ink is irrelevant for this purpose.) But the height and the width of letters is a pure {media-domain} concern. When we separate content from formatting, we separate the font from the character and are left with a string of characters whose length is measured not in inches but in character count. And this works very nicely because unless we get silly with the size and shape of the viewport that we flow the characters into, and a {rendering algorithm} can flow characters onto a page with reasonable results. 
        
        There can, indeed, be some issues with such rendering algorithms when it comes to hyphenation, widows and orphans, and the location of titles relative to the text, but with the appropriate {document domain} markup to delineate basic document structures, algorithms can handle these issues reasonably well. (They can't edit the text itself to make a line break work better, as some human typesetters will do, but that kind of manipulation is rarely needed.)
        
        But when it comes to content that has two dimensions, things get more difficult. The main problem cases are:
        
        * tables
        * graphics and other media
        * preformatted text, such as program listings, that have meaningful line breaks
        
        
    bibliography:
        entry:(#Flynn2009)
            Flynn, Peter. “Why writers don't use XML: The usability of editing software for structured documents.” Presented at Balisage: The Markup Conference 2009, Montréal, Canada, August 11 - 14, 2009. In Proceedings of Balisage: The Markup Conference 2009. Balisage Series on Markup Technologies, vol. 3 (2009). doi:10.4242/BalisageVol3.Flynn01.            
        
        
    section: Metadata

        We live in the age of metadata, so much so that the word metadata has almost come to replace the word data itself and has come to be applied to almost any form of data that describes a resource. For example, we hear a lot about law enforcement getting access to metadata related to phone calls, which simply means the data about which number called which number and for how long.  
        
        In the {definition of structured writing}[#chapter.definition] I said that structured writing is writing that obeys constraints and that records the fact that it obeys constraints.
        
        The standard definition of metadata is data that describes data. This can make it seem like an optional extra, as something added on top of something that already exists. But actually there is no data without metadata. Data is a formalization of information. It makes a set of promises about what the information means -- that is, how it is constrained. Metadata is the record of those promises/constraints. Without it, you have no formal assurance that the information is what it seems to be. 
        
        Structure is the imposition and recording of constraints. The recording of constraints is metadata. Structure, therefore, consists of metadata. Where you have structure, you have metadata. Where you have metadata, you have structure. 
        
        Recipes contain lists of ingredients. If you record a recipe in the document domain, you will record that list of ingredients using a list structure. In this case the constraint you are imposing, and therefore the metadata you are recoding is: this is a list and these are list items. This metadata does not record that the items in the list are ingredients. 
        
        Human being recognize the list of ingredients for what it is based on familiarity with the pattern and recognition of the names of foodstuffs. This is fine for humans, but still a little iffy for our current generation of AI algorithms. Writing an algorithm to reliably recognize ingredients in recipe, while not impossible, is a lot of work.
        
        Move that recipe into the subject domain, however, and you replace a list structure with an ingredients structure. In this case the constraint you are imposing, and therefore the metadata you are recording, is: this a a collection of ingredients, and each one of them is an ingredient. Writing a reliable algorithm to recognize ingredients based on explicit metadata that says they are ingredients is simple. 
        
        This is not to say that a list structure is not metadata also. It is. It is document domain metadata. It formally identifies the list items structure as a list item. It makes it easy to write algorithms that recognize lists. This  allows you to reliably format it as a list item in whatever media you choose to publish it in. 
        
        Subject domain metadata that identifies an ingredient as an ingredient provide a different promise, one that allows us to do more with the data. 
        
        The purpose of attaching metadata to content is to make the content into data. The reason for making content into data is to make it accessible to algorithms. The best way to think about metadata is in terms of the algorithms it enables. Broadly, the areas in which we want to apply algorithms to content are publishing, finding, validating, and auditing.
        
        Basic publishing algorithms can be performed using document domain metadata alone. But as we have seen, publishing related algorithms such as differential single sourcing, content reuse, and content generation also require subject domain metadata. Finding requires subject domain metadata because we search for content based largely on its subject matter. Validating, which deals with whether content meets its defined constraints, depends on the metadata of the domain in which the content is recorded. Auditing, which deals with whether content meets business requirements, generally requires subject-domain metadata as most business requirements are in the subject domain.  
        
        But this does not mean that all content get captured in the subject domain. There is another way to apply subject domain metadata to content besides recording the content in the subject domain. This is to apply subject domain metadata externally to the content or an an overlay to the document domain structures in which the content is recorded. 
        
        For example, if you wanted to have access to the data on which ingredients were mentioned in each recipe (perhaps as an aid to finding recipes), you could record the recipe itself in the document domain and then place it in a relational database table with a many-to-many relationship to a table that listed all know ingredients
        
        # Example
        
        Systems designed primarily for document domain content creation, such as DITA, can include formalized structures for attaching subject domain metadata to document domain structures. In DITA, the primary such mechanism is the {subject schema}(concept "DITA subject schema").
        
        One of the primary contrasts between the document domain and the subject domain then is not that subject domain metadata is entirely missing from the document domain, but that in document domain systems, subject domain metadata is stored separately from the document domain markup, whereas in the subject domain it is integrated into the content itself. 
        
        This should not lead us to think that the two approaches are equivalent. They vary substantially in capability, implementation requirements and ease of use.
        
        For example, when we talked about {differential single sourcing}(concept) we saw that subject domain content could be transformed into radically different document domain structures for publication in different media. (A table for paper vs. an interactive widget online, for instance.) Attaching subject domain metadata to a piece of content that contains a document domain structure (such as a table) does not give you the capability to differentially single source it to different structures for other media.
        
        One area in which external subject-domain metadata excels is finding and filtering. You can certainly find and filter on subject domain content, but because there are many different subject domain structures, it can be non-trivial to figure out how to write the query expression that does the finding and filtering you require. By contrast, external subject domain metadata can be stored in normalized data structures that are consistent and therefore easier to write queries for. This consistency also allows tools and systems to put high-level interfaces over these query mechanisms for users that don't know how to write queries themselves. As such, the approach is widely favored in content management systems.
        
        On the other hand, there is a limit to how fine grained a find and filter operation can be with external metadata. If you want the advantage of external metadata stored in normalized structures for ease of querying, it can only discriminate down to the level of the pieces of content it is applied to. It can retrieve that whole content unit, but not pieces of it. 
        
        For validation, it comes down to a matter of what constraints you want to validate against. As we have seen, moving content to the subject domain allows us to factor out many of the constraints that we want to apply to the document domain and to express and enforce the constraints we want to apply to how the content treats its subject matter. If content quality is your primary reason for adopting structured writing, these advantages are hard to ignore. 

        For auditing, the situation is much the same. If you are looking to audit the consistency of your publishing system, document domain metadata will suffice. If you are looking to audit your coverage of subject matter, external subject domain metadata attached to document domain content will give you a high level look at your coverage, but tell you little about quality or how well subjects are being covered. 
        
        When it comes to easy of use, there are things in favor of each approach. If you have standardized document structures and standardized metadata structures, then users only have to learn those structures.
        
        On the other hand, separating subject metadata from the writing of the content itself means that writers have to do two separate jobs. Rather than creating the metadata as they write in the subject domain, they have to write in the document domain and then create separate subject domain metadata to describe the document they have just written. This create more work for the writer, and has frequently prove error prone. 
        
        This can significantly impact the quality of both the content and the metadata. Because the document domain does not impose any constraints on how a subject is treated, it it quite easy to apply subject domain metadata to content that simply does not merit it. If metadata is supposed to express a promise that certain constraints have been met, this creates a broken promise. 
        
        The fact is, promising that a constraint has been met without validating that it has actually been met is a recipe for broken promises. Attaching subject domain metadata externally to document domain structures always runs into this problem. No factoring our of enforcing of the subject-related constraints has been enforced. There has not even been effective subject-domain guidance provided to the writer while writing the content. 
        
        I noted above that external subject domain metadata excels in the area of finding because it makes it easy to write queries on standardized metadata structures. But there is a large caveat to this, which is data quality. It the promises the metadata makes are not kept by the content itself, the value and reliability of searches is severely diminished. 
        
        At the end of the day, the value of any system is constrained by the quality of its data. Content management systems often fail or underperform because of poor quality data caused by a poor fit between content and its metadata. In particular, there is a tendency for data quality to decline over time. Systems based on this approach need to be aware of the problem and vigilant to prevent it.
        
        We should also note that the two approaches are not mutually exclusive. The subject metadata used in both cases is essentially the same, since it describes the same subject. There is no reason, therefore, why you cannot take subject domain content, with its integrated metadata, and extract the metadata to an external metadata store. This way you can use the same query interface to find the content without giving up the validation and auditing capability of subject domain content or the finer-grained application of metadata that the subject domain enables. This approach can significantly approve the quality of the metadata in the system because all the subject domain guidance and constraints have been applied to the content before it is stored. Thus, as long as the content itself is correct, there cannot be a mismatch between what the metadata promises and what the content delivers.
        
        There are ease of use advantages to his approach as well. Since the system metadata is extracted from the content metadata, the writer does not have to enter the metadata separately from the content after is is written. 
        
        
        Metadata is confusing because it is recursive. If metadata is the data to describes data, it is also the data that describes the metadata. The data/metadata distinction is not one of type -- metadata is not a different kind of thing from data -- it is one of relationship. It is a father/son distinction, not a cat/dog distinction. One man can be both a father and son. What we call him depends on what relationship we are looking at at a given moment. 
        
        In structured writing, we add structure to content to replace the things we have factored out. That structure is metadata to the data that is the text of the file. But if we store that file in any kind of repository, the information that identifies the file in that repository is metadata to the file as a whole. But that is not the only kind of metadata for that file. If the structure of the file is described by a schema, the schema is also metadata for the file. 
        
        Metadata is not a nice to have add on to data. There is no data without metadata. If Acme corporation does a survey that finds 9 out of 10 people rank Acme number one in their industry, the fact that this survey was conducted by the CEO at the company picnic the week before promotions are announced it the metadata that tells you what the data means. But we're not done yet because the specification of the schema language it the metadata that tells you what the schema means.  And then of course, there is the specification of the markup to consider. The XML specification is part of the metadata for every XML document in existence. And we are still not be done, because the XML specification uses a formal grammar description language, called {BNF}(language) then the specification of that language is metadata for the schema language description. Check out this document which forms part of the chain of metadata supporting XML: {Guide to the W3C XML Specification ("XMLspec") DTD, Version 2.1}(https://www.w3.org/XML/1998/06/xmlspec-report-v21.htm#AEN56).
        
        So, every piece of data has a spreading tree of metadata supporting it, which, if traced to its roots, inevitably leads to plain language documents that explain things in human terms.
        
        One of the great questions about metadata is where it should live: with the data it describes or separate from it. For much metadata the answer is obvious. It lives separately because its scope is wider than one resource. An XML document does not include the XML spec. But for metadata that is unique to an individual resource, the question is an important one. 

        Most early graphic file formats only stored the image. Most modern format also store extensive metadata. Your digital camera files store all kinds of information about the camera and the settings that were used to take the shot, and even the geographic coordinates of where the shot was taken, if the camera has a GPS receiver. 

        In part the argument is about who is responsible for creating the metadata. In the case of the photo, the metadata is in the file because the camera is the best placed instrument to record it. Sometimes it is about whether the metadata is intrinsic or extrinsic to the content. Sometimes it is about control.

        For example, should the history of a file be stored in the file or in the repository. Storing it in the file lessens the file's dependence on the repository and makes it more portable. But a repository vendor may prefer to sell you a system in which to uninstall their repository would be to loose all your file history. If file status information is only stored in a workflow system, for instance, it is very hard to move away from that system. It it is stored in the file, it is easy to move away, and also to edit when not connected to the system, which can save you on licences. 
    
    section: Structure and annotation
    
        
        Broadly speaking, structured markup provides two things: structure and annotation. Structure governs the relationship of pieces. It is structure that says that a list consists of list items, that an API reference must begin with a function signature followed by a list of parameter values, that says that an ingredient listing consists of the ingredient name followed by a quantity followed by a unit of measure, or that a section must begin with a title. It is in structure that we create, impose, and express most of the {constraints}(concept) that are fundamental to structured writing.
        
        Whenever you place content in a structure, you are saying something about that content. What kind of thing you are saying about it depends on the domain of the markup. 
        
        |Media Domain| The structure says what the content should look like. 
        
        |Document Domain| The structure says what role the content plays in the document.
        
        |Subject Domain| The structure relates the content to its subject matter.
        
        |Management Domain| The structure says how the content should be managed.
        
        But markup structures, such as XML elements, only allow you to say one thing about the content they contain. Suppose you want to say more than one thing about a piece of content? In that case, you can add annotations to express additional information. 
        
        The information in annotations does not have to be in the same domain as the structure they apply to. For instance:

        * In {DITA}(language), the {keyref}(attribute (DITA)) attribute is used to add {management domain}(concept) metadata to a number of document structure elements.
        
        * In {HTML}(language), the style attribute can be used to add {media domain}(concept) metadata to the document structure.
        
        But not all annotations add additional information to structures. It is possible to have annotations that stand alone. At a certain point in defining the structure of content we get down to what is essentially free-form narrative content -- that is, paragraphs of text. But even within a paragraph, that are pieces of text that we want to add metadata to for use by downstream processes. Examples from each of the domains include:
        
        |Media Domain| A `bold` or `strong` annotation on a piece of text you want to emphasize.
        
        |Document Domain| An `xref` annotation to create a reference to another part of the content.
        
        |Subject Domain| A `function` annotation to identify that a piece of text is the name of a function.
        
        |Management Domain| A conditional annotation to identify a piece of text that may be conditionally included or excluded from output. 
        
        section: Structure and annotation in SAM
        
            In SAM, there are a number of types of structure, but the main extensible structure is the block. Annotations are part of the definition of the language. Annotations can be added to blocks and call also float in text. 
            
            ```(SAM)
                section:(#annotations) Annotations
                    This is a paragraph containing an {annotation}(concept).

            
            In the example above, `section` is a structure containing a title and a paragraph. The `section` structure has an annotation which is contained in parentheses immediately after the colon that defines the structure. In this case it is an ID annotation and assigns the ID "annotations" to the structure.
            
            The word "annotation" in the paragraph is annotated with a free-floating annotation. The curly braces delineated the text that is being annotated. The parentheses contain the annotation itself, which in this case is a type annotation, indicating that the word "annotation" is a reference to concept. 
        
        section: Structure and annotation in XML
        
            In XML we have two principle types of markup, the element and the attribute. These more or less correspond to the distinction I have made here between structure and annotation. Elements are for structure. Attributes are for annotation. The only caveat is that XML does not allow for free-floating annotations. To create an annotation inside a paragraph, you have to use an element. A paragraph (or any other block of text) with elements floating in it is called "mixed content". 

            So the SAM example above could be expressed like this in XML:
            
            ```(XML)
                <section id="annotations">
                    <title>Annotations</title>
                    <p>This is a paragraph containing an <concept>annotation</concept>.

        
        section: Structure in attributes    
            
            While SAM draws a distinction between structure and annotation, XML, as we have seen, does not. Its distinction between element and attribute roughly corresponds to my distinction, but not entirely so. This is a reflection of the fact that while SAM is designed for documents, XML is deliberately more general and designed for data applications where the structure and annotation distinction may not apply, or may not apply in the same way as it does in documents. 

            This means that it is possible to design XML languages that use attributes (normally an annotation mechanism) to express structure.        
            
            Consider these {examples of HTML Microformats from Wikipedia}(https://en.wikipedia.org/wiki/Microformat). The first example shows an address formatted as a list. 
            
            ```(HTML)
                <ul>
                   <li>Joe Doe</li>
                   <li>The Example Company</li>
                   <li>604-555-1234</li>
                   <li><a href="http://example.com/">http://example.com/</a></li>
                </ul>

            
            Here the phrase `The Example Company` is contained in `li` tags. This is part of a list structure delineated by `ul` tags, so the markup is largely structural in the document domain. The `li` does not really tell you anything useful about what the content itself is about. It does not tell you anything useful beyond what document structure it belongs to. It is not much use as an annotation.   

            The second example adds hCard microformat markup:
            
            ```(HTML)
                <ul class="vcard">
                   <li class="fn">Joe Doe</li>
                   <li class="org">The Example Company</li>
                   <li class="tel">604-555-1234</li>
                   <li><a class="url" href="http://example.com/">http://example.com/</a></li>
                </ul>

           
            This example adds subject domain metadata in the form of the class attribute. For example, it says that the phrase `The Example Company` is a reference to an organization (`org`). So far this is just regular annotation. 
            
            However, there is not just annotation going on here. There is actually subject domain structure being expressed. Not only is the list item `The Example Company` annotated as `org`, the list that contains it is annotated as `vcard`. The meaning of `org` is actually dependent on it being part of a `vcard` structure.
            
            In other words, the annotations in the sample above are equivalent to pure subject domain markup like this:
            
            ```(HTML)
                <vcard>
                   <fn>Joe Doe</fn>
                   <org>The Example Company</org>
                   <tel>604-555-1234</tel>
                   <url>http://example.com/</url>
                </vcard>

            
            In other words, the microformats are overlaying a second structure on the list structure. In the world of HTML, this makes sense. HTML needs to be a standardized document domain language so that browsers can display it for human reading. Humans don't need the vCard annotations to recognize that the content is an address, but algorithms do. So the microformat adds a second, hidden, subject domain structure to the document for readers who are algorithms rather than people. 
            
            Authoring our content this way would obviously be inefficient. But as we have seen, we can process subject domain structures to produce document domain structures with the {presentation algorithm}(algorithm). If you write this content in the subject using markup like the above, you could transform it to the HTML with microformats example shown above with a presentation algorithm like this:
            
            ```(pseudo)
                match vcard
                    create ul
                        attribute class = "vcard"
                        continue

                match fn
                    create li
                        attribute class = "fn"
                        continue

                match org
                    create li
                        attribute class = "org"
                        continue

                match tel
                    create li
                        attribute class = "tel"
                        continue

                match url
                    create li
                        create a
                            attribute class = "url"
                            attribute href = contents
                            continue

            
            In other words, we can factor out the document domain structure from the HTML for authoring and storage and then factor it back in for output. 
            
        section: Structure or annotation
        
            Since both structures and annotations can contain information about content, you often have to decide whether to use one of the other to capture some of the metadata you need. Here are some of the basic considerations:
            
            Annotations are more difficult to constrain than structures. It is not that you can't constrain which annotation apply to which structures. In XML, for instance, you could require that every element `a` have an attribute `b`. But while that may work in some cases, it only applies if `b` is relevant to all instance of `a`, and with most of the things you want attributes for, that is not the case. So that means the `b` needs to be optional, which means it is less constrained. (There is a constraint on which attributes *may* occur, but not on which *must* occur.)
            
            Structures provide superior guidance. Even if all you need for downstream processing is metadata that could be provided by annotations, using structures makes it easier to guide authors to provide the metadata you need, and to audit the content to make sure the information has been provided correctly. 
            
            Structures establish context. As we have seen, the ability to establish context is key to many algorithms. Annotations exist in the context established by structures, but do not create new context themselves. 
            
            Similarly, if you are annotating words and phrases within a paragraph, it is difficult to constrain which words should be annotated or how. If you really need a particular piece of information to be constrained consistently, you probably need to factor out the paragraph and capture it as a set of field structures that can be properly constrained and audited. (You can turn it back into a paragraph in the {presentation algorithm} if you want to publish it that way.}
            
            #example
            
            Secondly, annotation are generally harder for writers to create than structures. This depends in part on which markup languages you are using, and which editing tools, but in XML, for instance, where annotation are usually created using attributes, a string of attributes on an element can make the document very hard to read in plain text view, which most XML editors, which are generally optimized for document domain editing, make it much more difficult to add attributes than elements, and generally hide attributed from view (at least by default) making it harder to edit them, or to see how they impact the overall structure of the document. 
            
            Of course, if you need to add more than one piece of {metadata}(concept) to a piece of content, you will have to use annotations to do it because one structure, by itself, can only express one piece of information. However, by moving your content to a different domain, you may be able to avoid the need to use as many annotations. When you write content in the document domain, for example, any media, subject, or management domain metadata you want to add to the information must be expressed as annotations. But if you move your content to the subject domain, you can often factor out the document domain, media, and management domain structures, meaning you can rely on the subject domain structures alone and have less need for additional annotations.

            (It should be noted here that it is uncommon to have a real world tagging language that is entirely in one domain. While media domain languages are often entirely in the media domain, document domain languages commonly include some subject domain structures or annotations and often extensive management domain structures and annotations. Even subject domain languages usually need at least basic document structures like paragraphs and lists, and may also need some management domain structures and annotations for management information that cannot easily be factored out into sensible subject domain structures.)        
            
            Structures are more expressive than annotation. Structures break a document into pieces and label the pieces. This allows you to see the structure of the document as a whole and reflect on it as a whole. It allows you to navigate the document more easily and audit it more thoroughly. In a markup language like SAM which deliberately expresses the structure, it is easier to take in the structure of the document at a glance. 
            
            # Note that storing document domain content in a subject domain CMS schema is another case of overlying the domains. 
            


            What happens when you need to format part of your document differently, but your document domain language does not have a document domain structure for the document element you are creating? For example, if your document domain language is HTML, it does not have any structures for common document domain objects like procedures, sidebars, of bibliographies? 

            Of course, you can create these things in an HTML document, using regular features like lists, divs, and paragraphs. To indicate how they are to be formatted, though, you will have to either apply style information directly in the file, or else add some kind of metadata that indicates the special role that the list, div, or paragraph is playing. In HTML, the normal strategy is to use a class attribute. So, you could support special styling of a procedure list by giving it a class attribute of "procedure":

            ```(HTML)
                <ol class="procedure">
                    <li>Lather.</li>
                    <li>Rinse.</li>
                    <li>Repeat.</li>
                <ol>


            This is, in some ways, like giving HTML a procedure document domain object. We can now format as a procedure. And because we are using a hierarchical system, we don't need to add class attributes to the li elements to format them different. We can set an invariant rule that all li elements that are children of an ol element of class "procedure" will be formatted a certain way.

            ```(CSS)
                ol.procedure li
                {
                }


            We said that when we define a style, we are extending the media domain. In the same way, if we work in the document domain, we often need to extend the document domain we are working in. HTML is not an extensible language. To fill the need for an extensible document domain language, the W3C adopted XML (eXtensible Markup Language). XML allows you to extend your document domain (or any other domain) in two ways:

            1. by creating brand new structures in that domain. 
            2. by using attributes to specify additional type information for an existing structure.

            Another method for extending the document domain is provided by {DITA}(language) through it specialization mechanism, which allows you to create a new structure by specializing an existing one. In practice, this means defining a new structure but with the difference that the system knows about the new structures relationship to the old one, so that if you specialize a numbered list, the system knows that your new list is a type of numbered list.

            Yet another method is provided by {SPFE}(tool), which supports creating a library of structures from which you can select the ones you want to build a set of document domain (or other domain) structures for your use.

            We will look in detail later at ways of extending your document domain objects. For now, lets begin by looking at what the document domain looks like, and why you want to add additional kinds of document domain objects.

    section: Taxonomy and controlled vocabulary
    section: Ontology
        Finally it is worth saying a word about ontology. Ontology (in the information processing sense) is an attempt to create a formal mapping of the relationships between entities in the real world such that algorithms can draw inferences and reach conclusions about them.  
        
        In many way, therefore, an ontology is an attempt to do for algorithms what content does for humans. After all, one of the main reasons that we read is so that we can understand the world better, understand what various objects and institutions are and how they relate to each other, statically and in action, so that we can decide what to do. 
        
        In some sense, therefore, ontology is the ultimate in {subject domain} markup. And just as {subject domain} markup can be used to drive content management functions, so there are attempts to use ontologies to drive content management functions, especially at the enterprise level. One should also be able to generate human-readable content from an ontology, given a sufficiently sophisticated algorithm and a sufficiently sophisticated ontology. 
        
        All of this is very much outside our scope in this book. {Subject domain} markup is an attempt to capture certain aspects of the subject matter of a work. But it is not an attempt to model the argument of a work. Given the passage:
        
        ```(sam)
            In {Rio Bravo}(movie), {the Duke}(actor "John Wayne") plays an ex-Union colonel.
            
        The subject domain is content to formalize the fact that Rio Bravo is a movie and that "the Duke" is a reference to the actor John Wayne. It does not model the relationship between the two. An ontology would want to model the "starred in" relationship between John Wayne and Rio Bravo, whereas the subject domain is content to leave this to the text. 
        
        Similarly, this {subject domain} markup does not both to denote that Union is a reference to both a country and its armed forces, and the colonel is a rank in those armed forces. It does not denote these things because this particular markup language is concerned with movies and these facts are entirely incidental to the movie business. A full ontological treatment of the passage above, however, would need to model those relationships. 
        
        Structured writing does make certain aspects of content clear to algorithms, but not with the intention of making it possible for the algorithms to act on the information in that content. It only does what is necessary to allow human authors to use algorithms as tools to improve the quality of the content they prepare for human readers. 
    