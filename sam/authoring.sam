chapter:(#chapter.authoring) Authoring

    <<<(annotations.sam)

    It may not be immediately obvious that authoring is an algorithm. It is not something done to content, rather it is the process that creates content. The creation of content is obviously a process and activity, but it is (for the most part) performed by people rather than machines, and it is not obvious that it is done using a set of fixed processing rules, which would define it as an algorithm.
    
    But as I have emphasized throughout the chapters on algorithms, structured writing algorithms always begin with structures. Unstructured writing is not an algorithm (or at least, it is a more advanced AI algorithm that we yet know how to write). It is a human action, and an action of the imagination. But structured writing requires something more. It requires that authors not only create content, but that they create content in structures that can drive all the other structured writing algorithms that we want to implement. 
    
    Creating content in such structures is an activity over and above the pure act of writing content. The only way we get content in the right structures is if authors create those structures as they write. Our structured writing system can only be a good as the structured content our writers create. Getting the best possible structure from our writers, therefore is key to all of the algorithms and all of the benefits of structured writing. This is not something we can afford to leave to chance. We need to be systematic about it. We need an authoring algorithm. 
    
    Like all other structured writing algorithm, the authoring algorithm begins with the design of structures. Creating a set of content structures while thinking only about how they will feed publishing or content management algorithms is a recipe for a system that is difficult to use, expensive to implement and run, and subject to ongoing data problems. You will not get good data for any downstream algorithms unless your structures are engineered for ease of correct authoring. 
    
    All forms of structured writing, even in the {media domain} require authors to do something other than simply write. Since writing is an intellectually challenging activity that requires full attention, adding structured writing requirements into the mix necessarily takes away some of the attention that should otherwise be given to content, which obviously has the potential to reduce the quality of the content. Clearly, therefore, we need to make sure that the intrusion of structured writing requirements onto the writing process is a minimal as possible. 
    
    But the equation is not quite so simple as this. Structured writing may be an additional requirement, but quality writing does not result from an author simply spilling words onto a page or screen in stream of consciousness fashion. Writing is a design activity. It creates a structure of words that conveys complex ideas and information about the real world. It very much matters that the author says the right things using the right words in the right order. If structured writing techniques can help with this literary design work, they can lessen the intellectual burden on the author, and thus potentially improve the quality of the content. 
    
    Of course, structured writing can improve {content quality}(algorithm) in other ways. Most of the algorithms we have looked at pertain to content quality in one way or another, such as improved linking or better management of terminology. Still, these algorithms work on the structures that the authors create. If those structures are weak, there is a limit to what downstream algorithms can do to improve quality. It really all begins with getting the right structures correctly and reliably applied by authors as they write. 
    
    In media-domain systems like word processor and desktop publishing systems, the writer is asked to think about formatting structures while writing. One of the traditional arguments for structured writing is to relieve the writer of the burden of thinking about (and manipulating) formatting so they can focus on writing. 
    
    This means moving to the document domain. But in the document domain, the writer has a new set of structures to think about: document domain structures. Is it easier on the writer to think about and manipulate document domain structures than media domain structures? In some cases, yes. For instance, writing a blog post or a web page in MarkDown may be less cumbersome for some writers than using a WYSIWYG HTML editor.
    
    However, Markdown does not contain enough structure, or enough constraints on its structure, to enable many of the algorithms we have talked about. It offers little support for {composition}, {reuse}, or {single sourcing}, for instance, and virtually zero support for {conformance}. 
    
    If we want to support these algorithms, we will need something more structured, and this can easily mean something that requires more of the author's attention. If we are proposing to implement management-intensive algorithms, such as {reuse}, it can mean that authors need to learn and manipulate an entire management system and the management policies that the organization puts in place around it. Depending on how complex these policies are and how foreign they are to the author's experience, this can create a burden far greater that that of creating and manipulating formatting according to a style guide. 
    
    We could look at this and say, okay, yes, authoring is now more difficult and more complex than it was before because of all this additional structure and all that authors need to learn to apply that structure, but we are getting additional advantages as well, so it is worth it overall. The problem is, as authoring get more difficult, authors do all of the component tasks less well. Attention is a finite resource. The more of the writer's attention is required on structure, the less is available for writing, and the quality of the writing suffers. And as the quality of the writing suffers, the writer becomes frustrated with the system, and becomes more interested in getting their ideas down than in obeying the onerous structural rules that are getting in their way. When that happens, the quality of the structure suffers as well. And if both the quality of the writing and the quality of the structures decline, all of your algorithms become less reliable, compromising all of benefits you hoped to obtain.
    
    To look at this another way, the more complex your system becomes, and the more algorithms you are attempting to support, the more important {conformance} becomes. But as we saw when we looked at the {conformance algorithm}, conformance is fundamentally a human activity. Good conformance results from creating structures that are easy to conform to. It all begins with authoring. Unfortunately, authoring is often the last thing people think about in designing content management sand structured writing systems
    
    One of the most familiar tropes of the content management industry is that problems with content management systems are not technology problems, they are human problems. The solution, this trope suggests, lies in better change management and more training. The presumption here is that the tools work fine if only you give them correct input. If the input is incorrect, that is the fault of the humans who create the input. But this is an argument we would not accept for any other kind of system. For any other kind of system we would say, "this system is too hard to use", not "the problem is everybody needs to be better trained and more accepting of change". This is really an excuse for poor system design. If humans cannot conform to the structures that the system requires, the fault is in the system design. The structures should be redesigned to be easier to conform to.
    
    
    How is designing structures for ease of authoring consistent with designing them to match the specific constraints that we want to impose for the sake of quality and efficient processing? As we have seen, as we have seen, moving from the {media domain} to the {document domain} allows us to factor out or impose certain structural constraints, but often require the introduction of the management domain to impose content management constraints. These complexities detract from ease of authoring. But we have also seen that in moving to the subject domain we can factor out many of the document domain and management domain structures that we need for our publishing process and then reintroduce them during the {publishing} process. Designing structures for authoring, therefore, often consists of factoring out complex publishing and content management structures using subject-domain structures that are lucid for authors.

    One of the most important consequences of this, both for ease of authoring and reliability of data, is that in the subject domain, you are not asking the author to think and to structure content in terms of algorithms. In this sense, the move to the subject domain not only factors out specific constraints from the author, it factors out the need to think in algorithms at all, leaving the author free to think in terms of subject matter. This freedom to focus on content is a property I call functional lucidity.
    
    section: Functional lucidity
    
        Functional lucidity means the way that you actually use language when you are writing, which is to say the way that you use language when you are in the throes of figuring out what you want to say and how you want to say it. If you are asked to add markup to your content as you write, if you are asked to shape your content according to the constraints that a structured writing language dictates, then the lucidity of that markup and the structures it defines are vital to your success. The names of the structures, the order in which they occur should spring into your mind as readily (if not more so) that the words and phrases and ideas you are trying to record on paper. 
        
        As anyone who has struggled to write even a paragraph in a language they are only beginning to learn can attest, writing in a language in which you are not fluent is painful. The effort of finding words and correct grammatical structures takes all of the attention that should be reserved for what you are trying to say. Writing in a tagging language where the tags don't make intuitive sense, when the structures don't seem to fit the thoughts you are trying to express, is very much like this. Lucidity is essential to avoid having the markup absorb all of the attention that should be focused on the content. 
        
        Functional lucidity is not an absolute property, of course. What is lucid for one writer may be opaque to another. In particular, professional technical writers who have been used to writing in structured {document domain} templates in applications like FrameMaker may find a markup language like {DocBook} functionally lucid, whereas someone not used to thinking in these terms would find it difficult and distracting. On the other hand, those writers used to FrameMaker often find DITA's structure difficult to get used to because they do not find its approach to topic lucid. To still others it seems very natural. 
        
        But while different writers may have different degrees of experience and familiarity with abstract document structures, all writers should have familiarity with the subject matter they are writing about. Thus a well-designed {subject domain} language tends to naturally have functional lucidity for everyone who is likely to use it. (Though writers can sometimes disagree about what needs to be said on a subject and how it should be said.)
        
        There are a number of challenges to functional lucidity:
    
        section: Local and global names

            A big part of functional lucidity is the ability to call things by the names that are familiar to you. We noted in the discussion of the {relevance algorithm} that the use of clearly labeled unambiguous identifiers can help algorithms determine the relevance of a piece of content. The problem is, not everything has a globally unambiguous identifier (such as a company stock ticker) and even for things that do, the author may know know what those identifies are off the top of their heads (for instance, many authors may know the names of companies like Apple, Google, and Microsoft but not know their full ticker symbol. Forcing them to look them up every time you want to to unambiguously identify a company will add a lot of overhead to the authoring process, and it will also make the markup of the information more complex, again impacting the efficiency of authoring. 

            Fortunately, we don't have to unambiguously identify everything we write about at a global scale. We only have to ambiguously identify it within the context of the content we are writing. There is actually a universal truth about language in this. Very few words have only one meaning or identify only one thing. "Sun" is a big ball of burning gas and a computer company that was bought by Oracle. We distinguish these meaning by context, and we can distinguish content identifiers by context in the same way. 
            
            In fact, doing the identification in context is actually more accurate, since there is less possibility of accidentally introducing a confusion with a usage you are not aware of. The more highly contextualized an identifier is, the less ambiguous it is (as long as you specify both the context and the identifier you are looking for).
    
        section: Granularity
        
            There can be a conflict between ease of authoring and ease of {content management}. Content management may want to manage content down to a fine level of granularity, especially for purposes of content reuse. This content management algorithm may be best served by managing fairly small chunks of content -- semantic units rather than narrative units. But for the writer, something less than a narrative unit can be difficult. It can be difficult for the author to get a sense of how the semantic block they are writing will meet the reader's needs when they don't see the narrative block it will fit into. It is hard to create parts rather than wholes unless the parts are really well defined. A writer might carry the whole of an essay in their head, for instance, and be able to structure it well on that basis. But if they are making only parts and cannot see the wholes that will be created, it is hard to correctly structure a part without very clear and explicit guidance.  

        
        
    section: Functional lucidity and a layered architecture
        
        A layered architecture can be very valuable in providing functional lucidity to a variety of authors. To build a publishing system that is capable of managing a wide variety of content, it is often necessary to create a lot of abstractions in your document markup. If you ask authors to write content directly in those abstract structures you may find that they struggle with the abstraction, and with the complexity and the range of options that go with a language that is designed to handle so many different source and publication types. Providing a set of separate authoring languages (perhaps simplified {document domain}, perhaps subject-specific {subject domain}), can deliver functionally lucid authoring languages to different types of authors, greatly improving the authoring process. 
        
        At the same time, the simplicity of these special-purpose languages can allow you to be much clearer about what the names and labels mean in the context of that language. Providing and agreeing on precise meanings for terms is much easier the smaller the group of people you are dealing with and the smaller the range of subject matter you are addressing. We have relatively limited vocabularies and we reuse words and phrases between different domain of discourse all the time. Agreeing on what a term means across all domains of discourse is virtually impossible. Agreeing on what it means in a limited domain with a limited audience is much easier. 

        For purposes of rolling up content from many domains into one larger content set, you will definitely have situations in which the same names and labels are used to mean different things. But this is not a problem as long as you know which domain each piece of content comes from. In other words, every tagging language defines a set of names and labels for content in the context of a particular namespace. (Namespaces are an explicit concept in tagging languages like XML and SAM.)
        
        Placing names into namespaces does not magically resolve all disagreements about what to call things in a wider information space. But it does allow for an {information architect} to choose an definitive mapping of names from each namespace into the enterprise namespace. The results may still be disputable, but at least they will be consistent. And if they are disputed, and a different mapping is accepted, only the mapping has to change to put the new system into effect. As long as each pieces of content is tagged correctly according to the rules of its local namespace, it does not have to change just because the rules of the enterprise namespace change. 

        Achieving agreement (and, what is really more important, functional lucidity) within a local domain is easier in some domains than others. The {media domain} is highly concrete, so there really is not much room for disagreement there. Styles, though, are often given names from the document domain, as they are really a step into the document domain, and this can lead to disagreements because of the more abstract nature of the document domain. 
        
        The {document domain} is the most difficult place to achieve either agreement or functional lucidity. (By functional lucidity, I mean that the language seems easy to use and obvious when you are actually writing as opposed to when you are attempting to hammer out agreement in a committee room.) The document domain is inherently an abstract place, and there are always different ways to abstract from the concrete reality of web pages and books, particularly because of how different hypertext media domains are from paper media domains and the difficulty of truly abstracting beyond those differences. Thus you will frequently hear argument between the proponents of various document domain languages about the correctness and usability of their choices. For instance, partisans of Markdown may praise its functional lucidity (it is very easy to write in) which partisans of ReStructuredText may praise its greater abstraction and range of application. 
        
        The {management domain} is quite concrete, like the {media domain}, but more arbitrary. It consists either of commands or of management metadata, both of which are particular to a specific management system. Difficulties here are likely to be more about the management processes to be implemented rather than the correct naming of things. 
        
        
        
        
    section: Simplicity and Clarity

        One of the biggest benefits of subject domain markup for authors is a much higher degree of functional lucidity compared with a typical document domain language. 
        
        While a general document domain language like {DocBook}(language) needs to have structures for a wide range of document structures, a recipe markup language such as we have developed in this chapter, has only a few simple elements. Better still, there are very few permutations of those elements. Because subject domain languages do not specify document order, we don't need to allow for many possible document orderings in the language, thus reducing the permutations we have to allow for and deal with. The synthesis algorithm can take the named structures of the subject domain markup and order them in any way you like.
        
        Because subject domain structure describe the subject matter they contain, they are also much clearer to authors, who may not understand complex document structures (or, more often, the subtle distinctions between several similar document structures), but who do (we hope) understand their subject matter. 
        
        The combination of simplicity and clarity mean that in many cases you can get authors to create subject-domain structured content with little or no training. For instance, even if we add some additional fields to our recipe markup, you could still hand a sample like the one below to an author and ask them to follow it as a template, without giving them any training or any special tools.
        
        ```(sam)
            recipe: Hard Boiled Egg
                introduction:
                    A hard boiled egg is simple and nutritious.
                ingredients:: ingredient, quantity
                    eggs, 12
                    water, 2qt
                preparation:
                    1. Place eggs in pan and cover with water.
                    2. Bring water to a boil.
                    3. Remove from heat and cover for 12 minutes.
                    4. Place eggs in cold water to stop cooking.
                    5. Peel and serve.
                prep-time: 15 minutes
                serves: 6
                wine-match: champagne and orange juice
                beverage-match: orange juice
                nutrition:
                    serving: 1 large (50 g)
                    calories: 78
                    total-fat: 5 g
                    saturated-fat: 0.7 g
                    polyunsaturated-fat: 0.7 g    
                    monounsaturated-fat: 2 g    
                    cholesterol: 186.5 mg    
                    sodium: 62 mg    
                    potassium: 63 mg    
                    total-carbohydrate: 0.6 g    
                    dietary-fiber: 0 g    
                    sugar: 0.6 g    
                    protein: 6 g    
        
        
        Of course, the downside is that recipe markup is only good for one thing: recipes. A general document domain language can be used to write all kinds of documents. It will not enforce or record nearly as many constraints, or enable nearly as many options for validation or publishing, and it won't be nearly as clear and simple for authors to use. But neither will it require you to create subject domain languages for each of the subjects you write about. At first glance, that may seem like a slam dunk case for sticking with the document domain, as the idea of inventing subject domain languages and the synthesis and presentation algorithms to go with them may seem daunting. But as we will see, the decision is not so clear cut, as sticking with he document domain comes with a lot of complexity, and sometimes custom development, that may not be apparent at first.

