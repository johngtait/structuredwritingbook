chapter:(#chapter.mechanical-structure) Mechanical Structure

    <<<(annotations.sam)
    
    Structured writing is writing the obeys constraints and records the constraints it obeys. If the constraints it obeys are its rhetorical structure, the way is records those constraints is its mechanical structure. The mechanical structure of structure writing is a compute data structure. However, conventional computer data structures like relational database tables do not work well for content because they are too regular to fit the shape of content. Creating structures that are regular enough for algorithms to deal with yet irregular enough to fit written language is an interesting problem to which more than one solution has been proposed.
    
    Raw text is just a stream of characters. Inside that stream of characters, there are rhetorical structures like headings, bibliographical entries, bold text, chapters, allusions, references, links, tables, and labeled lists. The question is, how do you express these various structures on top of the raw stream of characters?
    
    One way is to indicate with some kind of markup the place were a rhetorical structure beings or ends. 
    
    ```
        This text is [B>bold<B].
        
    What happens if a different rhetorical structure overlaps with this one?

    ```
        This text is [B>bold, [I>this is bold and 
        italic,<B] and this is just italic<I].

    For some markup system, such as that used in the word processor WordPerfect, this works perfectly fine. But this approach really puts a damper on the kinds of algorithms you can run. Many algorithms depend on their ability to isolate certain elements of a text for processing. Suppose your source text contains markup like this:

    ```
        Use the [B>[function-name>print()<B]<function-name] to print.
        
    If a conformance algorithm is trying to validate function names in a text, it is not going to see `print()` as the value of the function name, but `print()<B]`. That is messy to deal with, to say the least. It is messy to write and maintain as well, which is why WordPerfect had a reveal codes mode that allowed the writer to go in and fix up broken markup when things got messy. Thus this approach to markup is not used much anymore. 
    
    To avoid this mess, most modern markup systems treat the text stream as consisting of a set of non-overlapping blocks. Blocks can nest inside other blocks, and even inside the content of other blocks, but two blocks can never overlap each other. This makes it much easier for algorithms to process markup but it means that in cases were rhetorical structures do overlap, you have to resort to convoluted markup like this:

    ```
        <p>This text is <b>bold,</b> <i><b>this is bold 
        and italic,</b></i> <i>and this is just italic</i>.</p>
    
            
    There is more to this question than trivial examples like this. In the academic study of text markup, where markup is used not for the preparation of documents but to mark them up for academic study, there is an debate about whether the hierarchical structure of XML-based languages actually reflects the real structure of the text. 
        
    From a structured writing perspective, we don't have to worry so much about whether the markup is objectively true to the text. Our concern is to create structures that improve the quality of content and enable the structured writing algorithms we want to use. 
        
    A hierarchical model is almost universally preferred. Whether they truly represent the structure of text or not, hierarchical models are easier to define and process and provide an easier way to express constraints. 
        
    section: Flat vs. nested structures
    
        But even when we choose the hierarchical approach to markup design, we are still left with some fundamental choices about structure. The first is flat vs. nested structure.  
        
        We noted in [#chapter.document-domain] that in HTML, you have six levels of heading (`h1` through `h6`) whereas in DocBook you have only `title`. In DocBook, you can divide a document up into sections and nest sections inside sections. You can then print the titles of sections inside sections in a smaller font that the titles of first level sections. You get to have differences in heading size without having six different heading tags. 
        
        But the DocBook model assumes that the real structure of a document is  a hierarchy of nested sections and that the size of titles announces the steps up and down that hierarchical tree. HTML makes no such assumption. It will let you put a `<h4>` immediately after an `<h1>` if you want to. It treats documents as essentially flat structures punctuated by headings of various sizes as and where appropriate. 
        
        Which model of a document is correct? You can think of a document as being organized hierarchically, with major ideas expressed in sections, sub-ideas supporting the major ideas in subsections, etc. There are doubtless documents that fit that model. But you can also think of documents as being more like a journey in which headings function more like road signs. A city gets a big sign, a hamlet a small sign, and a town a medium sign. But the town is not inside the city, not the hamlet inside the town, and there is no guarantee that on leaving the city you will come to the town before you come to a hamlet.   
        
        Studies by Peter Flynn indicate that most authors think of the documents they are writing much more in terms of a punctuated linear model than a hierarchical model.
        
        """[#Flynn2009]
            The classical theory, derived from computer science and graph theory, is that the document is a hierarchical tree (actually inverted: a root-system) and that all necessary actions can be seen in terms of navigation around the tree, and of insertion into and withdrawal from the the nodes which form the branches and leaves.
            
            The conventional writer, however — and we expressly exclude the markup expert, as well as the experienced technical authors who responded to the survey — is by repute probably only marginally aware of this tree; but we have been unable to measure this at present. In this view, the document is seen as a continuous linear narrative, broken into successive divisions along semantic lines, and interspersed with explanatory material in the form of figures, tables, lists, and their derivatives. 

        The return from subjection problem, which comes up again and again in structured writing, both at the rhetorical and mechanical level, is an illustration of this point. Within a section, you can create one or more nested subsections. If one applies a hierarchical logic to the design of the document, the role of the subsection is to treat a secondary or supporting point for the main section. In this logic, on ought to be able to return to the section level after a set so subsections in order to sum up the overall point of the section. Logically you might also wish to return to the section level of discourse between subsections so as to locate the matter of the subsection in the narrative of the section. 
        
        You could certainly create structured writing section and subjection structures that would let you follow this logic. The problem is, how would you publish this structure. While it is not impossible to imagine a way to format something like this, it would clearly be a violation of all the norms of document layout and organization. In a normal document, if you want to sum up a section after several subjections, you introduce a subheading "Conclusion" after the end of the last subsection. The role of the conclusion is to sum up the section as a whole, so it is not a subsection hierarchical logic of the document, it is a return to the section level.

        But no one, to the best of my knowledge, as ever tried to actually mark it up that way. The conclusion will be marked up as another subsection. And any material that relates a subjection to the matter of the section will be contained within the subsection itself. Thus the section/subsection structure of a document does not reflect any hierarchical logic in the rhetorical structure of the argument, it actually just groups content under different levels of headings. 

        And as Flynn's research illustrates, there is a good chance that the author is not thinking of their argument as consisting of a strict hierarchy of points either, but as a sequence of points with the occasional insertion of heading to break up the text or perhaps signal a change in emphasis or subject matter. 
        
        
        To think of it yet another way, a text is a flattening of the representation of a complex reality -- the world -- a reality whose complexity can no more be fairly represented by as a hierarchy than it can by a simple sequence. The building up of the picture of the real world, in all its complexity, is not the job of the document outline, but the job of the whole of the text, of every verb, adjective, and noun, or every sentence, and simile and symbol and story that the writer can assemble to guide the reader to the full grasp of the complex world they are describing. To suggest, therefore, that the mechanical structure of a markup language can capture the full rhetorical structure of a piece of writing is absurd. It can, at best, capture certain aspects of that rhetorical structure, and outside of that it works best when it stays out of the writer's way as much as possible. 
        
        
        
        But if the {constraints} that we want to express in structured writing demand hierarchy, while {functional lucidity} demands more of a punctuated linear model, how do we reconcile these two opposing requirements in markup language design? 
        
        This is of greatest concern in the design of {document domain} languages. The structure of {media domain} languages is largely dictated by the shape and relationship of the media-domain object they are modeling. In the {subject domain}, we have abstracted content out of strict document order. Hierarchy in the {subject domain} tend to match the hierarchy of relationship in the subject matter itself.[*1] In the {document domain}, however, it is a real concern. The document domain consists of abstractions of document structures and the nature of their relationship to the structure of thought in the text is not obvious. 
        
        footnote:(*1)
            Though this is not universal. Addresses, for instance, which are based on hierarchal locations, are modeled as flat ordered lists. The order reflect the hierarchy, but the nesting of city inside country and of street within city is not reflected in the structure of an address record.
        
        The options available are:
        
        * Create a really flat document domain language. Examples are HTML and Markdown. The problem here is that they impose few constraints, and the lack of context-setting hierarchy makes it hard to model different types of document structures without creating hundred of tags -- which would negate any {functional lucidity} that you gained by keeping the language flat.
        
        * Create a hierarchical language that has a really permissive structure, so that you can put boxes inside boxes in lots of different ways. An example of this is DocBook. The problem here is that the possible permutations make writing algorithms difficult and you often need to impose additional constraints on your authors that are not expressed or enforced by the markup itself. This again diminishes {functional lucidity}, and compromises {conformance}. (An interesting property of this approach is that the flexibility of the language means that authors can choose to create documents that are deeply nested or very flat. This is not really a virtue, however, as it is not clear how this choice contributes to improved content quality.)
        
        * Define a smaller, stricter document domain language that is appropriate to the particular types of documents you want to write, possibly as restricted subset of an existing language like DocBook. The main difficulty with this approach is that it involves you in having to do your own language design, which many organization try to avoid. Once you have decided to go this route, going to the {subject domain} instead may be no more expensive while providing better {functional lucidity} and {conformance}. 
        
        * Define a strict hierarchical document domain language that expresses the constraints you need and make people learn it. This works if you are able to recoup the expense of training your authors. It does not work if you want to include occasional authors in your pool of contributors. 
        
        * Move content creation to the {subject domain}. 
        
        In the {document domain}, however, you have to make a choice between enforcing a hierarchical model of a document or allowing a more linear one. You will almost certainly do this in the context of hierarchical syntax.  But you do need to decide if you are going to allow arbitrary heading levels. Or, to put it another way, to model a document as a hierarchy of sections with each section having a title, or a single flow of text randomly interspersed with headings, or something in between.

        The something-in-between option can seem appealing but you can end up with something really unconstrained, meaning that it is difficult to write reliable algorithms to process it. Here is the kind of issues you can run into:
        
        Is a list part of the paragraph in which it occurs? Some markup languages, such as Markdown and SAM, take the view that lists are separate blocks that come after a preceding paragraph. But DITA, DocBook, and HTML will all let you place a list either inside or outside a paragraph:
        
        ```
            <p> The primary colors are:
                <ul>
                    <li>Red</li>
                    <li>Blue</li>
                    <li>Yellow</li>
                </ul>
            </p>
            
            <p> Their complementary colors are:</p>
            <ul>
                <li>Green</li>
                <li>Orange</li>
                <li>Purple</li>
            </ul>
            
        The interesting question here is whether these two structures should be formatted differently for output. Should the list that in inside the paragraph be indented, which the one that comes afterwards be printed flush left? 
        
        The default for HTML, at least in the browsers I tried it on (Edge, Internet Explorer, and Chrome) is that both are indented by the same amount, but of course you could change this with CSS and DocBook and DITA processors can do what they like. 
        
        But would it be a good idea to make a distinction between the two? Only if authors clearly understood the difference between the two and clearly know when they were choosing one or the other. (If they are writing in a visual editing view of an XML editor, then they almost certainly won't know the difference.)
        
        If you are designing your own markup language, do you want to allow both these forms? Probably not. The more permutations of structure your markup language allows, the more work it will be to write the algorithms to process it. Some allowance may be made for ease of authoring, if you wish, but it may be better to wait for authors to complain about a restriction like this than to build in all the possible variations in advance.
        
    bibliography:
        entry:(#Flynn2009)
            Flynn, Peter. “Why writers don't use XML: The usability of editing software for structured documents.” Presented at Balisage: The Markup Conference 2009, Montréal, Canada, August 11 - 14, 2009. In Proceedings of Balisage: The Markup Conference 2009. Balisage Series on Markup Technologies, vol. 3 (2009). doi:10.4242/BalisageVol3.Flynn01.        
        
        
    section: The role of syntax
    
        The syntax of your markup language also plays a role in striking the right balance between hierarchy and {functional lucidity}. Fully explicit markup syntax like that of XML forces every element of the hierarchical structure of the document to the fore in the syntax. The syntax has explicit hierarchical constraints of its own (what XML calls the well-formedness constraint). This pushes the hierarchical structure in the author's face, which detract from {functional lucidity}. 
        
        Languages like Markdown with implicit syntax are just as hierarchical as their equivalents with fully explicit syntax but they feel flatter. Thus where HTML make you write:
        
        ```(html)
            <html>
                <ol>
                    <li>
                        <p>The first item.</p>
                        <p>A second paragraph in the first item.</p>
                    </li>
                    <li>
                        <p>The second item.</p>
                <ol>
            </html>
            
        In {MarkDown} you write:
        
        ```(markdown)
            * The first item.
              
              A second paragraph in the first item.
              
            * The second item.
            
        The latter has just as much structural hierarchy as the first, but feels much flatter. It uses indentation to indicate that the second paragraph belongs to the first list item, but that feels natural and obvious rather than contrived or imposed. 
        
        If a structured writing language divides all content up into blocks and nested blocks, XML-based languages make all such blocks completely explicit by markup up the beginning and end of every block. {Lightweight languages} like {Markdown} use a more implicit syntax better reflects the implicit structure of formatted text itself.  
        
        One of my motivations for creating SAM, which is designed for structured writing, and therefore, unavoidably, for hierarchical structures, was to express hierarchy implicit where possible and as naturally as possible where it cannot be implicit, for the sake of improve functional lucidity for strictly constrained structured writing languages. (First and foremost, I created it for myself, to improve functional lucidity for me in the structured writing I do, such as the writing of this book.) 
        

    section: Agreeing on boxes, names, and labels
        
        The names and labels on blocks tell us what kind of thing is in the box. What kind of things they  tell us depends on the domain we are dealing with. 
        
        In the {media domain} they tell us what the words in the box look like, either directly (an actual format description) or by reference (the name of a style). In the {document domain} they tell us what part of a document the words are. In the {management domain}, they tell us what to do with the words under different circumstances. In the {subject domain} they tell us what the subject matter of the words is. 
        
        The block does not only have to have information from one domain on it. It is not uncommon to have a block with a name in the document domain and a label in the management domain or the subject domain. We saw and example of this in [#chapter.subject-domain]:
        
        ```(xml)
            <section publication="Wine Weenie">
                <title>Wine match</title>
                <p>Pinot Noir</p>
            </section>
            <section publication="The Teetotaler's Trumpet">
                <title>Suggested beverage</title>
                <p>Lemonade</p>
            </section>

        Here the `section` box is in the document domain, but the `publication` label is in the management domain.
        
        The names and labels on the blocks tell us what constraints the structures inside the block obey, or, as we are writing, what constraints the words we write are expected to obey. Algorithms use the names and the labels to process the content, assuming that they accurately reflect the constraints. 
        
        For structured writing to work, it is essential that everyone involved understands and agrees on what the names and labels mean. If we don't, the names and labels will not accurately reflect the constraints we expect, and the whole content quality project falls apart and the algorithms stop working. 
        
        Confusion and disagreement about what the names and labels of a particular language mean are not uncommon. Large document domain languages like {DocBook} and {DITA} have large vocabularies, and many of the names they offer are quite abstract. Questions about the right way to tag certain passages are common in the communities around these languages, and opinions can vary considerably in some cases. These disagreements don't only affect low-level structures. In {DITA}, for example, it is common to debate if a topic that is operational but not procedural is a concept or a task. Some writers choose to use only generic topics because they don't feel the models of the task, concept, and reference topics fit the content they are creating. 
        
        Having precise definition of terms is important, therefore, in developing a structured writing language. But it is equally important that the language be {functionally lucid}. The {authoring algorithm} requires that creating structure should not come at the detriment of the writing itself. This requirement is not met if writers are constantly having to puzzle out or debate the right way to mark something up. 
        
        In the software world, meta models and abstraction are powerful tools for modeling systems. They provide clear high-level rules for the design of specific structures and create opportunities to reuse code for objects with a shared base model. But these tools can also lead to very abstract naming schemes and even to abstract structures. In the content world, such abstract names and structures can be formally correct but lack the kind of {functional lucidity} required for effective authoring.        
        
        The problem of defining a (mechanical structure) to express a (rhetorical structure) is not only one of defining a correct representation of the content. We also have to design and name structures that can be written by our intended set of authors without imposing a heavy burden on their attention. In other words, designing content structures, at least those intended for use by authors, is as much about interface design as it is about data structure design. 
        
        Clear concrete and specific names, and an organization of boxes that intuitively fits the subject matter, all make for easier authoring. There is no reason that such structures cannot be derived from abstract models, or that they cannot be mapped to abstract models after the fact, but it is important not to let the abstractions intrude too munch into the world of the author. 
    
        Of course, functional lucidity only matters for the formats that authors actually write in. As we have seen, the {publishing algorithm} typically consists of multiple steps, and each one of those steps can create a format that is closer to the media domain than the one before it. It is perfectly possible to design a document domain structure for the sole purpose of of serving as a step in the publishing chain. Separate authoring formats are created for authors to actually write in (perhaps {subject domain} formats or simplified highly constrained ad-hoc document domain formats). Content is transformed from these formats to the document domain format by the {presentation algorithm} and then the document domain format is translated in to various different media domain languages by the {formatting routine}. An arrangement like this eliminates the need to compromise between different demands in designing a single language, generally making each language in the chain simpler and more constrained, which in turn makes it each one easier to {validate} and to process.

    section: Constraint and annotation
    
        Broadly speaking, structured markup provides two things: constraint and annotation. Constraint governs the relationship of pieces. It is constraint that says that a list consists of list items, that an API reference must begin with a function signature followed by a list of parameter values, that an ingredient listing consists of the ingredient name followed by a quantity followed by a unit of measure, or that a section must begin with a title. 
        
        Annotation adds information to the constrained structures. The name of the structure is its first and most important annotation. It is the annotation that expresses the core constraint that has been imposed. This may be supplemented by other annotations on the structure that further clarify the constraint that has been imposed, or contain other metadata, such as management domain annotation. 
        
        But we can also have unconstrained annotation, or at least, annotation whose usage is very lightly constrained. In some XML-based languages, for instance, there are sets of attributes that are allowed to appear on just about any element in the entire language. (ID attributes are an obvious example.) But the main source of unconstrained annotation are those that can float in the middle of a piece of text.  
        
        As we noted, we cannot capture the full rhetorical semantics of any piece of writing using simple linear or hierarchical structures. At some point we have to leave the writer free to express themselves in paragraphs of text on which we can impose no meaningful restriction. But we may still be very much interested in constraining the interpretation of many of the words and phrases used in those paragraphs.
        
        Such annotations are constrained in the sense that there is a limited set of them available for use, but they are almost always unconstrained as to where and in what order they appear in the text -- for the very good reason the their text that they annotate obeys no regular rule or pattern. 
        
        Every structure has a name (though the name is implicit in some forms of markup. The name of the structure is an annotation of the constraint that the structure imposes. (Remember that we defined structured writing as both imposing a constraint and recording that the constraint has been applied.)
        
        The different structured writing domains are defined by what these annotation of structure are saying about the content they contain. 
        
        |Media Domain| The annotation says what the content should look like. 
        
        |Document Domain| The annotation says what role the content plays in the document.
        
        |Subject Domain| The annotation relates the content to its subject matter.
        
        |Management Domain| The annotation says how the content should be managed.
        
        But the name of a structure only allow you to say one thing about the content. In some cases you may want to add more than one annotation to a structure. For instance, you might want to add a condition to a paragraph. In this case, the name of the structure annotates that it is a paragraph and you need an additional management-domain annotation to hold the condition.  
        
        This use of additional annotations is quite common. For instance:

        * In {DITA}(language), the {keyref}(attribute (DITA)) attribute is used to add {management domain}(concept) metadata to a number of document structure elements.
        
        * In {HTML}(language), the style attribute can be used to add {media domain}(concept) metadata to the document structure.
        
        However, not all annotations are attached to structures. At a certain point in defining the structure of content we get down to what is essentially free-form narrative content -- that is, paragraphs of text. But even within a paragraph, there are pieces of text that we may want to annotate. Examples from each of the domains include:
        
        |Media Domain| A `bold` or `strong` annotation on a piece of text you want to emphasize.
        
        |Document Domain| An `xref` annotation to create a reference to another part of the content.
        
        |Subject Domain| A `function` annotation to identify that a piece of text is the name of a function.
        
        |Management Domain| A conditional annotation to identify a piece of text that may be conditionally included or excluded from output. 
        
        Different markup systems support structure and annotation in different ways. 
        
        
        section: Secondary structures of interpretation    
            
            Under normal circumstance, the structures that constrain the content also constrain its interpretation. But there are cases in which annotations are added to structures to constrain a different interpretation of the content from the one specified by the structure that contains it, and not only of individual fields, but of a structure as a whole. 

            Consider these {examples of HTML Microformats from Wikipedia}[https://en.wikipedia.org/wiki/Microformat]. The first example shows an address formatted as a list. 
            
            ```(HTML)
                <ul>
                   <li>Joe Doe</li>
                   <li>The Example Company</li>
                   <li>604-555-1234</li>
                   <li><a href="http://example.com/">http://example.com/</a></li>
                </ul>

            
            Here the phrase `The Example Company` is contained in `li` tags. This is part of a list structure delineated by `ul` tags, so the markup is largely structural in the document domain. The `li` does not really tell you anything useful about what the content itself is about. It does not tell you anything useful beyond what document structure it belongs to.    

            The second example adds hCard microformat markup:
            
            ```(HTML)
                <ul class="vcard">
                   <li class="fn">Joe Doe</li>
                   <li class="org">The Example Company</li>
                   <li class="tel">604-555-1234</li>
                   <li><a class="url" href="http://example.com/">http://example.com/</a></li>
                </ul>

           
            This example adds subject domain metadata in the form of the class attributes. For example, it says that the phrase `The Example Company` is a reference to an organization (`org`). This annotation is not modifying or refining the constraint expressed by the `li` tag. It is saying something else entirely. 
            
            But this is not just about suggesting a different way of interpreting `The Example Company` (as an organization name, as well as as a list item).  There is actually a complex {subject domain} structure being expressed. Not only is the list item `The Example Company` annotated as `org`, the list that contains it is annotated as `vcard`. The constraint of interpretation provided by `org` is actually dependent on it being part of a `vcard` structure.
            
            In other words, the secondary structure created by the annotations in the sample above is equivalent to pure subject domain markup like this:
            
            ```(SAM)
                vcard:
                   fn: Joe Doe
                   org: The Example Company
                   tel: 604-555-1234
                   url: http://example.com/
            
            In other words again, the microformats are overlaying a second structure on the list structure. In the world of HTML, this makes sense. HTML needs to be a standardized {document domain} language so that browsers can display it for human reading. Humans don't need the vCard annotations to recognize that the content is an address, but algorithms do. So the microformat adds a second, hidden, {subject domain} structure to the document for readers who are algorithms rather than people. 
            
            We noted in [#chapter.definition] that structured writing constrains both the creation and the interpretation of content. In the normal case we expect that the creation of the content would be just as constrained as the interpretation. After all, it is hard to rely on the interpretation of structure if the creation of the structure is not constrained. However in this case the interpretation of the data is more constrained than the creation. 
            
            Authoring our content this way would obviously be inefficient and error prone. But this is only a problem if the content is actually authored in this format. If the content is authored in a format in which its creation is constrained to the same extent as we wish the output to be constrained, it does not actually matter that the resulting output constrains interpretation more than it constrains creation. Our concern as content creators is simply to make sure that any content we produce that promises to abide by a constraint actually does so, whether the format we deliver it in actually imposes that constraint or merely annotates it. 
            
            So, we can confidently produce this information using subject domain markup and then deliver it as HTML with hCard annotation markup using a presentation algorithm something like this (as with all example algorithms in this book, this is pseudocode):
            
            ```(pseudo)
                match vcard
                    create ul
                        attribute class = "vcard"
                        continue

                match fn
                    create li
                        attribute class = "fn"
                        continue

                match org
                    create li
                        attribute class = "org"
                        continue

                match tel
                    create li
                        attribute class = "tel"
                        continue

                match url
                    create li
                        create a
                            attribute class = "url"
                            attribute href = contents
                            continue

            
            
        section: Elements vs. attributes
        
            Another issue in the design of the mechanical structure of a markup language is that of elements vs attributes. Elements and attributes are the core markup structures of XML, and many other markup systems make the same distinctions in one way or another. The simplest way to state it is that attributes add additional annotation to an element. So, for instance, in:

            ```(xml)
                <author-name first="Mark" last="Baker">
                
            the element is named `author-name` and it has two attributes named `first` and `last` that contain my first and last name respectively. 
            
            Why is this marked up like this and not like this:
            
            ```(xml)
                <author-name>
                    <first>Mark</first>
                    <last>Baker</first>
                    
            Both these constructs express the same information in a way that clearly constrains how author names are to be written and how the markup of author names is to be interpreted by algorithms. 
            
            Is one of these options correct and the other incorrect? When should you use attributes and when should you use elements?          

            Consider our vcard example. It could be written this way, using just elements:       

            ```(XML)
                <vcard>
                   <fn>Joe Doe</fn>
                   <org>The Example Company</org>
                   <tel>604-555-1234</tel>
                   <url>http://example.com/</url>
                </vcard>

            Or it could be written this way, using attributes:
            
            ```(XML)
                <vcard
                   fn="Joe Doe"
                   org="The Example Company"
                   tel="604-555-1234"
                   url="http://example.com/"
                />
            
            The first says that `fn`, `org`, `tel`, and `url` are independent structures that belong as members to a `vcard` structure. The second says that the `vcard` structure has a number of data fields -- annotations -- that complete its meaning. 
            
            Does this distinction matter terribly? Both allow you to get at the information you want. Both constrain both the creation and the interpretation of data. There are limits to the version that uses attributes. You can't have more than one attribute with the same name, whereas you could have more than one member elements of the same name (multiple tel elements for someone with more than one telephone number for instance). Also, XML specifies that attributes are unordered, so can't restrain either the order in which writers create them or the order in which the parser reports them to a processing application. 

            Given this, you may be wondering why people bother with attributes, since you can do the same things with elements and have both more flexibility and more capacity to impose constraints. Yet people continue to use attributes extensively when designing markup languages in XML.  When people create XML document types for representing data, rather than for writing document, they almost always use the attribute format, perhaps because it is slightly less verbose and slightly easier to read, or perhaps because as programmers they are accustomed to representing data as key/value pairs linked with `=` signs.

            But for documents it is more complex. To understand why XML even has attributes, and why other languages, such as SAM or reStructuredText, also have similar mechanisms for adding annotations to blocks, we need to go back to the original concept of markup as something written onto a manuscript after the fact. Markup is an addition to the text, not part of it. The content of an element is part of the underlying text. Anything you want to add, therefore, cannot be element content, since that would be adding to the text. Everything else has to be added to element definitions as attributes. 

            This view is reinforced by the academic interest in markup as a way to prepare texts for study. Again, here, the text is preexisting and canonical. The markup is external to it and so everything that is external to the original text must be contained in the markup itself (as attributes) and noting that is internal to the original text must be removed or replaced by markup. Thus in this fragment of a Shakerpere play marked up by John Bosek we see that the original text is kept perfectly intact:
            
            ```(xml)
                <ACT>
                <TITLE>ACT I</TITLE>
                <SCENE>
                <TITLE>SCENE I. Rousillon. The COUNT's palace.</TITLE>
                <STAGEDIR>
                Enter BERTRAM, the COUNTESS of Rousillon, HELENA, and LAFEU, all in black
                </STAGEDIR>
                <SPEECH>
                <SPEAKER>COUNTESS</SPEAKER>
                <LINE>
                In delivering my son from me, I bury a second husband.
                </LINE>
                </SPEECH>
                <SPEECH>
                <SPEAKER>BERTRAM</SPEAKER>
                <LINE>And I in going, madam, weep o'er my father's death</LINE>
                <LINE>anew: but I must attend his majesty's command, to</LINE>
                <LINE>whom I am now in ward, evermore in subjection.</LINE>
                </SPEECH>
            
            Had this markup employed the normal refactoring of text into markup that we have seen in our discussions of the {document}(concept "document domain"} and {subject}(concept "subject domain") domains, then the number and title of scenes would have been factored out so that instead of:
            
            ```(xml)
                <SCENE>
                    <TITLE>SCENE I. Rousillon. The COUNT's palace.</TITLE>
            
            we might have factored out the scene number and the work 'SCENE' like this:
            
            ```(xml)
                <SCENE>
                    <TITLE>Rousillon. The COUNT's palace.</TITLE>
            
            Going further, we might have noted that the introduction of a scene is invariable the name of its location, so we might have done this:
            
            ```(xml)
                <SCENE>
                    <LOCATION>Rousillon. The COUNT's palace.</LOCATION>

            or even this:

            ```(xml)
                <SCENE location=Rousillon. The COUNT's palace.">
            
            And similarly, we might have replaced:
            
            ```(xml)
                <SPEECH>
                    <SPEAKER>BERTRAM</SPEAKER>

            ```(xml)
                <SPEECH SPEAKER="BERTRAM">
                
            Making a few changes like this in the markup would leave us with only the words actually spoken by the actors as the "text" of the play and everything else expressed as elements or attributes. 

            This actually makes quite a lot of sense, because all of the stage directions and attribution of speakers in a play is actually metadata annotating the speeches of the actors which are the only things the audience is actually supposed to hear. 

            So is the right way to markup a play to preserve the original printed text -- which includes all of the playwright's metadata -- or is it better to separate the playwrights metadata from the speeches which are the 'real' play?

            The answers to questions like this need not concern us greatly. The fact that such question exist, however, help us to understand both why a markup language like XML is structured the way it is, and why so many texts are marked up the way they are -- and why so many tagging languages are designed the way they are. 

            The way we, as practitioners of structured writing for content quality, settle these matters is by asking ourselves which approach best supports the structured writing algorithms that we want to implement, and always remembering that the reliability of every other algorithm depends on how well the conformance algorithms works, and that the conformance algorithm depends to a large extent on how the authoring algorithm designs for conformance and for functional lucidity. 

            In none of this are we in the least concerned about preserving the canonical nature of a preexisting text. There is no preexisting text. We are all about creating new texts. Because of this we have every reason to prefer to use sub-structures rather than annotations on existing structures, to express things like our vCard example. In fact, SAM, which is designed specifically for structured authoring, only supports this format:             
            
            ```(SAM)
                vcard:
                   fn: Joe Doe
                   org: The Example Company
                   tel: 604-555-1234
                   url: http://example.com/
            
            SAM only supports a very limited set of annotations on blocks, all of which have predefined meetings. You could, in fact, eliminate annotations on blocks altogether, and use child blocks for everything, but I have supported a limited set of common {management-domain} block annotations in SAM, mostly to improve functional lucidity. 
            
            Support for free-floating annotation in text is another matter. Those you will always need for document-oriented markup and structured writing. 
        
            In summary, when defining the mechanical structure of your structured writing, don't get hung up on what is text and what is markup. In each domain, text and markup together form a body of constrained content which can be successfully created by an author and successfully processes by one or more algorithms. Only when you resolve the content all the way to the media domain do you finally have to sort our exactly which characters appear in which order and decoration to represent that content to a particular audience. When we choose to create content in the other domains it is precisely because we want to exercise more control over these things, and to use algorithms to help us create and manage them. Whether some idea or constraint is expressed by text of markup in those domains should be based solely on what works best in those domains. (Which is precisely why attempting to do structured writing using a WYSIWYG editor is so counter productive, and why it is so important to ensure the functional lucidity of your markup as markup.)
        
        
        
        
            

    